<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Git基础（3）：撤消操作和远程仓库的使用]]></title>
      <url>http://gongchuangsu.com/2016/12/07/Git/03-git-basics(3)/</url>
      <content type="html"><![CDATA[<h1 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h1><h2 id="commit-–amend"><a href="#commit-–amend" class="headerlink" title="commit –amend"></a>commit –amend</h2><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。这是我们可以运行带有<code>--amend</code>选项的<code>commit</code>命令尝试重新提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 修改最近一次提交的提交信息</span><br><span class="line">$ git commit --amend -m &quot;XXX&quot;</span><br><span class="line">// 向最近一次提交添加漏掉的几个文件</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p>
<h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><p>如果想取消暂存区域的某个文件，可使用以下命令来取消暂存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在调用<code>reset</code>命令时，如果加上<code>--hard</code>选项，如<code>$ git reset --hard HEAD~~</code>，会导致分支向前移动，导致文件丢失。</p>
</blockquote>
<a id="more"></a>
<h2 id="使用rebase-i修改提交"><a href="#使用rebase-i修改提交" class="headerlink" title="使用rebase -i修改提交"></a>使用rebase -i修改提交</h2><p>如果要修改第一次提交，需使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i --root</span><br></pre></td></tr></table></figure></p>
<p>如果要修改最近n次提交，需使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~n</span><br></pre></td></tr></table></figure></p>
<h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><p>如果你对某个文件做了修改，但还没保存至暂存区域，这时，你想撤销修改，将它还原成提交时的样子，该怎么做呢？可使用以下命令进行执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>
</blockquote>
<h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>通过运行<code>git remote</code>命令，查看已经配置的远程仓库服务器，它会列出指定的每一个远程服务器的简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：远程仓库服务器的默认名称为 <code>origin</code>。</p>
</blockquote>
<p>可以通过指定选项 <code>-v</code>，显示需要读写远程仓库使用的Git保存的简写与其对应的URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/GongchuangSu/GitInAction.git (fetch)</span><br><span class="line">origin  https://github.com/GongchuangSu/GitInAction.git (push)</span><br></pre></td></tr></table></figure></p>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>通过运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 指令，添加一个新的远程Git仓库，同时可以指定一个能够轻松引用的简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add gs https://github.com/GrantSu/GitInAction</span><br><span class="line">$ git remote -v</span><br><span class="line">gs      https://github.com/GrantSu/GitInAction (fetch)</span><br><span class="line">gs      https://github.com/GrantSu/GitInAction (push)</span><br><span class="line">origin  https://github.com/GongchuangSu/GitInAction.git (fetch)</span><br><span class="line">origin  https://github.com/GongchuangSu/GitInAction.git (push)</span><br></pre></td></tr></table></figure></p>
<h2 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h2><p>通过运行 <code>git remote rename</code> 命令，可以修改一个远程仓库的简写名。如将<code>gs</code>重命名为<code>grant</code>，可以进行如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename gs grant</span><br><span class="line">$ git remote</span><br><span class="line">grant</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>通过运行 <code>git remote rm</code> 命令，可以移除某个远程仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm grant</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<h2 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h2><p>通过运行 <code>git fetch [remote-name]</code> 访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch gs</span><br><span class="line">From https://github.com/GrantSu/GitInAction</span><br><span class="line"> * [new branch]      master     -&gt; gs/master</span><br></pre></td></tr></table></figure></p>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>通过运行 <code>git push [remote-name] [branch-name]</code> 命令，将要分享的项目推送到上游。如想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时，可使用以下指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</p>
</blockquote>
<h2 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>通过运行 <code>git remote show [remote-name]</code> 命令，查看某一个远程仓库的更多信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/GongchuangSu/GitInAction.git</span><br><span class="line">  Push  URL: https://github.com/GongchuangSu/GitInAction.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://git-scm.com/book/zh" target="_blank" rel="external">https://git-scm.com/book/zh</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git基础（2）：查看提交历史]]></title>
      <url>http://gongchuangsu.com/2016/12/06/Git/02-git-basics(2)/</url>
      <content type="html"><![CDATA[<p>我们可以通过 <code>git log</code> 命令来查看某个项目的提交历史。<br>下面我会通过一个<a href="https://github.com/GongchuangSu/HelloWeb" target="_blank" rel="external">开源项目</a>进行示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit f886a577726ea88afbae8556370f68ec060d6338</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 20:25:07 2016 +0800</span><br><span class="line"></span><br><span class="line">    解决用户名重复注册问题</span><br><span class="line"></span><br><span class="line">commit 875e76e39d537ccc8bef91a07e967d8dceb5b401</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 11:18:55 2016 +0800</span><br><span class="line"></span><br><span class="line">    添加正则表达式检验用户输入注册信息</span><br><span class="line"></span><br><span class="line">commit 254d361eb465c9675f6d46b35098ddfa28e936d2</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 10:09:03 2016 +0800</span><br><span class="line"></span><br><span class="line">    更新用户注册处理，自动添加默认角色信息</span><br><span class="line"></span><br><span class="line">commit 3581b5e867d4e401c6d9e84c0d203039ee22c503</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Sun Dec 4 22:23:11 2016 +0800</span><br><span class="line"></span><br><span class="line">    解决数据写入数据库乱码问题</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。默认情况下，会列出以下信息：</p>
<ul>
<li>每次提交的 SHA-1 校验和</li>
<li>作者的名字</li>
<li>电子邮件地址</li>
<li>提交时间</li>
<li>提交说明</li>
</ul>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交，接下来我们介绍些最常用的。</p>
<h2 id="常用选项-p"><a href="#常用选项-p" class="headerlink" title="常用选项-p"></a>常用选项<strong>-p</strong></h2><p><code>-p</code>选项用来显示每次提交的内容的差异，后面可以加上<code>-2</code>选项用来显示最近两次的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p -2</span><br><span class="line">commit f886a577726ea88afbae8556370f68ec060d6338</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 20:25:07 2016 +0800</span><br><span class="line"></span><br><span class="line">    解决用户名重复注册问题</span><br><span class="line"></span><br><span class="line">diff --git a/src/main/java/com/gongchuangsu/helloweb/controller/LoginController.                                                                                                                java b/src/main/java/com/gongchuangsu/helloweb/controller/LoginController.java</span><br><span class="line">index 5538349..a1358d7 100644</span><br><span class="line">--- a/src/main/java/com/gongchuangsu/helloweb/controller/LoginController.java</span><br><span class="line">+++ b/src/main/java/com/gongchuangsu/helloweb/controller/LoginController.java</span><br><span class="line">@@ -1,7 +1,5 @@</span><br><span class="line"> package com.gongchuangsu.helloweb.controller;</span><br><span class="line"></span><br><span class="line">-import java.util.List;</span><br><span class="line">-</span><br><span class="line"> import javax.validation.Valid;</span><br><span class="line"></span><br><span class="line"> import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">@@ -40,6 +38,8 @@ public class LoginController &#123;</span><br><span class="line">                        @Valid User user, Errors errors)&#123;</span><br><span class="line">                if(errors.hasErrors())</span><br><span class="line">                        return &quot;register&quot;;</span><br><span class="line">+               if(userService.userExists(user.getUsername()))^M</span><br><span class="line">+                       return &quot;redirect:/register?userExists=true&quot;;^M</span><br><span class="line">                userService.addUser(user);</span><br><span class="line">                return &quot;redirect:.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="常用选项–stat"><a href="#常用选项–stat" class="headerlink" title="常用选项–stat"></a>常用选项<strong>–stat</strong></h2><p>如果想看到每次提交的简略的统计信息，可以使用<code>--stat</code>选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat -2</span><br><span class="line">commit f886a577726ea88afbae8556370f68ec060d6338</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 20:25:07 2016 +0800</span><br><span class="line"></span><br><span class="line">    解决用户名重复注册问题</span><br><span class="line"></span><br><span class="line"> .../helloweb/controller/LoginController.java          |   4 ++--</span><br><span class="line"> .../java/com/gongchuangsu/helloweb/dao/UserDao.java   |   2 +-</span><br><span class="line"> .../gongchuangsu/helloweb/service/IUserService.java   |   1 +</span><br><span class="line"> .../gongchuangsu/helloweb/service/UserService.java    |   5 +++++</span><br><span class="line"> src/main/webapp/WEB-INF/views/register.jsp            |   7 +++++++</span><br><span class="line"> .../helloweb/controller/LoginController.class         | Bin 1921 -&gt; 2083 bytes</span><br><span class="line"> 6 files changed, 16 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line">commit 875e76e39d537ccc8bef91a07e967d8dceb5b401</span><br><span class="line">Author: GongchuangSu &lt;sgc0515@gmail.com&gt;</span><br><span class="line">Date:   Mon Dec 5 11:18:55 2016 +0800</span><br><span class="line"></span><br><span class="line">    添加正则表达式检验用户输入注册信息</span><br><span class="line"></span><br><span class="line"> src/main/java/com/gongchuangsu/helloweb/model/User.java | 9 +++++++--</span><br><span class="line"> src/main/webapp/WEB-INF/views/register.jsp              | 1 +</span><br><span class="line"> 2 files changed, 8 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，<code>--stat</code>选项在每次提交的下面列出了以下信息：</p>
<ul>
<li>所有被修改过的文件</li>
<li>被修改过的文件有多少行被删除或添加了</li>
<li>有多少文件被修改了</li>
<li>最后还有一个总结</li>
</ul>
<h2 id="常用选项–pretty"><a href="#常用选项–pretty" class="headerlink" title="常用选项–pretty"></a>常用选项<strong>–pretty</strong></h2><p>这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项还有一些内建的自选项可使用。如<code>oneline</code> 将每个提交放在一行显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">f886a577726ea88afbae8556370f68ec060d6338 解决用户名重复注册问题</span><br><span class="line">875e76e39d537ccc8bef91a07e967d8dceb5b401 添加正则表达式检验用户输入注册信息</span><br><span class="line">254d361eb465c9675f6d46b35098ddfa28e936d2 更新用户注册处理，自动添加默认角色信息</span><br><span class="line">3581b5e867d4e401c6d9e84c0d203039ee22c503 解决数据写入数据库乱码问题</span><br><span class="line">2e59b4e6e1bedab65e5889c5aff38a20f79f4bd5 更新表格，从数据库读取数据并显示</span><br><span class="line">89f490bcf4ca9b5a16547e24185164fa8a4d5438 添加注册页面</span><br><span class="line">4ba60a0ac7a69b73b0007765dca1ad1c0448e578 集成Hibernate持久化框架</span><br><span class="line">bcf801a98d29356d85cda0112cc65df4f099e93b 更新登陆界面</span><br><span class="line">7c04deb2466686c6c0495f402d4989c499230c11 添加remember-me功能</span><br><span class="line">c5dda853704738a5d6376655c12d5c6a01dae6bc 更新登陆验证</span><br><span class="line">0207b56879aadbbb5366d3ac99f26d8b450d1ea5 添加Spring Security的JSP标签库</span><br><span class="line">a20fda8dbe190bcb8c625853b2785a3362aefca9 添加Spring Security框架，用于身份验证和请求拦截</span><br></pre></td></tr></table></figure></p>
<p>但最有意思的是 format，可以定制要显示的记录格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br><span class="line">f886a57 - GongchuangSu, 20 hours ago : 解决用户名重复注册问题</span><br><span class="line">875e76e - GongchuangSu, 29 hours ago : 添加正则表达式检验用户输入注册信息</span><br><span class="line">254d361 - GongchuangSu, 30 hours ago : 更新用户注册处理，自动添加默认角色信息</span><br><span class="line">3581b5e - GongchuangSu, 2 days ago : 解决数据写入数据库乱码问题</span><br><span class="line">2e59b4e - GongchuangSu, 2 days ago : 更新表格，从数据库读取数据并显示</span><br></pre></td></tr></table></figure></p>
<p>下表列出了常用的格式占位符写法及其代表的意义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%H</td>
<td style="text-align:left">提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%h</td>
<td style="text-align:left">提交对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%t</td>
<td style="text-align:left">树对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%P</td>
<td style="text-align:left">父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">父对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left">%an</td>
<td style="text-align:left">作者（author）的名字</td>
</tr>
<tr>
<td style="text-align:left">%ae</td>
<td style="text-align:left">作者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left">%ad</td>
<td style="text-align:left">作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td style="text-align:left">%ar</td>
<td style="text-align:left">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:left">%cn</td>
<td style="text-align:left">提交者(committer)的名字</td>
</tr>
<tr>
<td style="text-align:left">%ce</td>
<td style="text-align:left">提交者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left">%cd</td>
<td style="text-align:left">提交日期</td>
</tr>
<tr>
<td style="text-align:left">%cr</td>
<td style="text-align:left">提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">提交说明</td>
</tr>
</tbody>
</table>
<h2 id="其它常用选项"><a href="#其它常用选项" class="headerlink" title="其它常用选项"></a>其它常用选项</h2><p>下表列出了 <code>git log</code> 命令支持的选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">按补丁格式显示每个更新之间的差异</td>
</tr>
<tr>
<td style="text-align:left">–stat</td>
<td style="text-align:left">显示每次更新的文件修改统计信息</td>
</tr>
<tr>
<td style="text-align:left">–shortstat</td>
<td style="text-align:left">只显示 –stat 中最后的行数修改添加移除统计</td>
</tr>
<tr>
<td style="text-align:left">–name-only</td>
<td style="text-align:left">仅在提交信息后显示已修改的文件清单</td>
</tr>
<tr>
<td style="text-align:left">–name-status</td>
<td style="text-align:left">显示新增、修改、删除的文件清单</td>
</tr>
<tr>
<td style="text-align:left">–abbrev-commit</td>
<td style="text-align:left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符</td>
</tr>
<tr>
<td style="text-align:left">–relative-date</td>
<td style="text-align:left">使用较短的相对时间显示（比如，“2 weeks ago”）</td>
</tr>
<tr>
<td style="text-align:left">–graph</td>
<td style="text-align:left">显示 ASCII 图形表示的分支合并历史</td>
</tr>
<tr>
<td style="text-align:left">–pretty</td>
<td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）</td>
</tr>
</tbody>
</table>
<h2 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h2><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。<br>例如，我们要搜索出2016.12.01以来的提交历史信息，可进行如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=&quot;%h - %s&quot; --since=&quot;2016-12-01&quot;</span><br><span class="line">f886a57 - 解决用户名重复注册问题</span><br><span class="line">875e76e - 添加正则表达式检验用户输入注册信息</span><br><span class="line">254d361 - 更新用户注册处理，自动添加默认角色信息</span><br><span class="line">3581b5e - 解决数据写入数据库乱码问题</span><br><span class="line">2e59b4e - 更新表格，从数据库读取数据并显示</span><br></pre></td></tr></table></figure></p>
<p>还有一些其他限制<code>git log</code> 输出的选项，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-(n)</td>
<td style="text-align:left">仅显示最近的 n 条提交</td>
</tr>
<tr>
<td style="text-align:left">–since, –after</td>
<td style="text-align:left">仅显示指定时间之后的提交</td>
</tr>
<tr>
<td style="text-align:left">–until, –before</td>
<td style="text-align:left">仅显示指定时间之前的提交</td>
</tr>
<tr>
<td style="text-align:left">–author</td>
<td style="text-align:left">仅显示指定作者相关的提交</td>
</tr>
<tr>
<td style="text-align:left">–committer</td>
<td style="text-align:left">仅显示指定提交者相关的提交</td>
</tr>
<tr>
<td style="text-align:left">–grep</td>
<td style="text-align:left">仅显示含指定关键字的提交</td>
</tr>
<tr>
<td style="text-align:left">-S</td>
<td style="text-align:left">仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh" target="_blank" rel="external">https://git-scm.com/book/zh</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git基础（1）]]></title>
      <url>http://gongchuangsu.com/2016/12/06/Git/01-git-basics(1)/</url>
      <content type="html"><![CDATA[<h1 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h1><p>有两种取得Git项目仓库的方法：</p>
<ol>
<li>在现有的目录中初始化仓库</li>
<li>克隆现有的仓库</li>
</ol>
<h2 id="在现有的目录中初始化仓库"><a href="#在现有的目录中初始化仓库" class="headerlink" title="在现有的目录中初始化仓库"></a>在现有的目录中初始化仓库</h2><p>进入该目录并执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<a id="more"></a>
<h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>克隆仓库的命令格式为<code>git clone [url]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/GongchuangSu/HelloWeb</span><br></pre></td></tr></table></figure></p>
<p>这会在当前目录下创建一个名为 “HelloWeb” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<blockquote>
<p>注：初次克隆某个仓库的时候，工作目录中的所有文件都属于<strong>已跟踪文件</strong>，并处于未修改状态。</p>
</blockquote>
<h1 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h1><p>工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于<strong>未修改</strong>，<strong>已修改</strong>或<strong>已放入暂存区</strong>。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p>
<p><img src="http://i.imgur.com/zMse8ig.png" alt=""></p>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：如果当前工作目录有处于未跟踪的文件，上述命令会将其列出来。</p>
</blockquote>
<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>使用命令 <code>git add</code> 开始跟踪一个文件。 例如，要跟踪 <code>README</code> 文件，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p>
<p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README.md</span><br></pre></td></tr></table></figure></p>
<p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是<strong>已暂存状态</strong>。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>
<h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为<code>README.md</code>的已被跟踪的文件，然后运行<code>git status</code>命令，将会看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure></p>
<p>文件<code>README.md</code>出现在<code>Changes not staged for commit</code>这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。<br>如果没有暂存这次更新，而是直接准备好提交，值得注意的是，<code>README.md</code>文件同时出现在暂存区和非暂存区。那么提交的到底是哪个版本呢？实际上，Git只不过暂存了你运行<code>git add</code> 命令时的版本，如果你现在提交，<code>README.md</code>的版本是你最后一次运行<code>git add</code> 命令时的那个版本，而不是你运行<code>git commit</code>时，在工作目录中的当前版本。</p>
<blockquote>
<p>注：<code>git add</code> 命令是一个多功能命令。一、可以用来跟踪新文件；二、把已跟踪的文件放到暂存区；三、用于合并时把有冲突的文件标记为已解决状态</p>
</blockquote>
<p>现在我们运行 <code>git add</code> 将<code>README.md</code>放到暂存区，然后再看看 <code>git status</code> 的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README.md</span><br></pre></td></tr></table></figure></p>
<p>在 <code>Changes to be committed</code> 这行下面的，说明该文件是<strong>已暂存状态</strong>。</p>
<h2 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h2><p>你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。 运行 <code>git status -s</code> ，状态报告输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li><code>A</code>：表示该文件是新添加到暂存区中的文件</li>
<li><code>??</code>：表示该文件是新添加的未跟踪文件</li>
<li><code>M</code>：分两种情况：靠左边的<code>M</code>和靠右边的<code>M</code><ul>
<li>靠左边的<code>M</code>：表示该文件被修改了并放入了暂存区</li>
<li>靠右边的<code>M</code>：表示该文件被修改了但还没有放入暂存区</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：如果出现两个<code>M</code>，那表示该文件在工作区被修改并提交到暂存区后又在工作区被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
</blockquote>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure></p>
<h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><p>要查看未暂存文件的修改，可直接不加参数的输入<code>git diff</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure></p>
<p>要查看已暂存文件的修改，可用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br></pre></td></tr></table></figure></p>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure></p>
<p>另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;First commit&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h2><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，<strong>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交</strong>，从而跳过 git add 步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &apos;added new benchmarks&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。<br>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<h1 id="三种状态和三个工作区域"><a href="#三种状态和三个工作区域" class="headerlink" title="三种状态和三个工作区域"></a>三种状态和三个工作区域</h1><p>Git有三种状态，文件可能处于其中之一：</p>
<ol>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中</li>
</ol>
<p>Git项目有三个工作区域：</p>
<ol>
<li>Git仓库：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
<li>工作目录：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区域：它是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。<br><img src="http://i.imgur.com/hdYR0t1.png" alt=""></li>
</ol>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改文件</li>
<li>暂存文件，将文件的快照放入暂存区域</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://git-scm.com/book/zh" target="_blank" rel="external">https://git-scm.com/book/zh</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程系列之线程状态图]]></title>
      <url>http://gongchuangsu.com/2016/07/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>线程状态图<br><img src="http://i.imgur.com/FNUXrMu.jpg" alt=""></p>
<a id="more"></a>
<p>说明：<br>线程包括以下五种状态</p>
<ol>
<li>新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul>
<li>(01)等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>(02) 同步阻塞 – 线程在获取synchronized同步锁失败(即同步锁被其它线程所占用)，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>(03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
<li>死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<p>参考资料：</p>
<ol>
<li><a href="http://wangkuiwu.github.io/2012/08/01/threads-basic/" target="_blank" rel="external">Java多线程系列–“基础篇”01之 基本概念</a></li>
<li><a href="http://my.oschina.net/mingdongcheng/blog/139263" target="_blank" rel="external">一张图让你看懂JAVA线程间的状态转换</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之反射(Reflection)]]></title>
      <url>http://gongchuangsu.com/2016/07/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%8D%E5%B0%84(Reflection)/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/UdqywSj.png" alt=""></p>
<a id="more"></a>
<h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>能够分析类能力的程序称为反射(reflection)</p>
<h1 id="反射可以用来干什么"><a href="#反射可以用来干什么" class="headerlink" title="反射可以用来干什么"></a>反射可以用来干什么</h1><p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。</p>
<ul>
<li>在运行中分析类的能力</li>
<li>在运行中查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象</li>
</ul>
<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着这个对象所属的类。可以通过专门的Java类访问这些信息，保存这些信息的类被称为<strong>Class类</strong>。<br>获取Class对象的三种方法：</p>
<ol>
<li><p>通过调用Object类中的getClass()方法返回一个Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object myObject = <span class="keyword">new</span> Object();</span><br><span class="line">Class myObjectClass = myObject.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用静态方法forName获得类名对应的Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"java.util.Date"</span>;</span><br><span class="line">Class cl = Class.forName(className);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：在使用<code>Class.forName()</code>方法时，必须提供一个类的全名，这个全名包括类所在的包的名字。</p>
<ol>
<li>如果在调用该方法时，没有找到该路径的类，将会抛出ClassNotFoundException。<br>获得Class对象的第三种方法非常简单，如果<code>T</code>是任意的Java类型，<code>T.class</code>将代表匹配的类对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 = Date.class;</span><br><span class="line">Class cl2 = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>补充：可通过下面方式访问类的父类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object myObject = <span class="keyword">new</span> Object();</span><br><span class="line">Class myObjectClass = myObject.getSuperclass();</span><br></pre></td></tr></table></figure></p>
<h1 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h1><p>通过Class对象可以获取两个版本的类名：</p>
<ol>
<li><p>通过getName()方法返回类的全限定类名(包含包名)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">String className = aClass.getName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过getSimpleName()方法返回类名(不包含包名)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">String className = aClass.getSimpleName();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="获取修饰符"><a href="#获取修饰符" class="headerlink" title="获取修饰符"></a>获取修饰符</h1><p>可以通过Class对象的<code>getModifiers()</code>方法来访问一个类的修饰符，该方法通过返回一个整型数值，用不同的位开关描述public/private/static等修饰符的使用状况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line"><span class="keyword">int</span> modifiers = aClass.getModifiers();</span><br></pre></td></tr></table></figure></p>
<p>还可以使用Modifier类中的isPublic、isPrivate或isFinal判断方法或构造器是否是public、private或final。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Modifier.isAbstract(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isFinal(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isInterface(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isNative(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isPrivate(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isProtected(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isPublic(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isStatic(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isStrict(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isSynchronized(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isTransient(<span class="keyword">int</span> modifiers);</span><br><span class="line">Modifier.isVolatile(<span class="keyword">int</span> modifiers);</span><br></pre></td></tr></table></figure></p>
<h1 id="获取包信息"><a href="#获取包信息" class="headerlink" title="获取包信息"></a>获取包信息</h1><p>可通过以下方式获取包信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">Class cl = object.getClass();</span><br><span class="line">System.out.println(cl.getPackage());</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*output</span><br><span class="line">package java.lang, Java Platform API Specification, version 1.7</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h1 id="获取实现的接口集合"><a href="#获取实现的接口集合" class="headerlink" title="获取实现的接口集合"></a>获取实现的接口集合</h1><p>可通过调用Class对象的<code>getInterfaces()</code>方法获取一个类实现的接口集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Class[] interfaces = aClass.getInterfaces();</span><br></pre></td></tr></table></figure></p>
<p>注意：getInterfaces()方法仅仅只返回当前类所实现的接口，不包括当前类的父类所实现的接口。</p>
<h1 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h1><p>可通过调用Class对象的<code>getConstructors()</code>方法获取一个类的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Constructor[] constructors = aClass.getConstructors();</span><br></pre></td></tr></table></figure></p>
<p>返回的Constructor数组包含每一个声明为<code>public</code>的构造方法。</p>
<hr>
<p>还可以通过给定的构造方法的参数类型获取指定的构造方法，如下：返回的构造方法的方法参数为String类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Constructor constructor = aClass.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意：如果没有指定的构造方法能匹配给定的方法参数，则会抛出<code>NoSuchMethodException</code>异常。</p>
<hr>
<p>还可以获取指定构造方法的方法参数信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = ... <span class="comment">//获取Constructor对象</span></span><br><span class="line">Class[] parameterTypes = constructor.getParameterTypes();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>利用Constructor对象实例化一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = ... <span class="comment">//获取Constructor对象</span></span><br><span class="line">Class[] parameterTypes = constructor.getParameterTypes();</span><br></pre></td></tr></table></figure></p>
<h1 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h1><p>可通过调用Class对象的<code>getMethods()</code>方法获取一个类的所有方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ...<span class="comment">//获取Class对象</span></span><br><span class="line">Method[] methods = aClass.getMethods();</span><br></pre></td></tr></table></figure></p>
<p>返回的Method对象数组包含了指定类中声明为public的所有变量集合。</p>
<hr>
<p>还可以通过具体的参数类型来获取指定的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = ...<span class="comment">//获取Class对象</span></span><br><span class="line">Method method = aClass.getMethod(<span class="string">"doSomething"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意：如果根据给定的方法名称以及参数类型无法匹配到相应的方法，则会抛出NoSuchMethodException</p>
<hr>
<p>获取指定方法的方法参数以及返回类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">Class returnType = method.getReturnType();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>通过Method对象调用方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个方法名为doSomesthing，参数类型为String的方法</span></span><br><span class="line">Method method = MyObject.class.getMethod(<span class="string">"doSomething"</span>, String.class);</span><br><span class="line">Object returnValue = method.invoke(<span class="keyword">null</span>, <span class="string">"parameter-value1"</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h1><p>可通过调用Class对象的<code>getFields()</code>方法获取一个类的成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Field[] method = aClass.getFields();</span><br></pre></td></tr></table></figure></p>
<p>返回的Field对象数组包含了指定类中声明为<code>public</code>的所有变量集合</p>
<hr>
<p>还可以通过具体的变量名称获取指定的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Field[] method = aClass.getFields(<span class="string">"someField"</span>);</span><br></pre></td></tr></table></figure></p>
<p>注意：在调用<code>getField()</code>方法时，如果根据给定的方法参数没有找到对应的变量，那么就会抛出<code>NoSuchFieldException</code></p>
<hr>
<p>通过调用<code>Field</code>对象的<code>getName()</code>方法获取它的变量名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... <span class="comment">//获取Field对象</span></span><br><span class="line">String fieldName = field.getName();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>通过调用<code>Field</code>对象<code>getType()</code>方法来获取一个变量的类型（如String, int等等）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... <span class="comment">//获取Class对象</span></span><br><span class="line">Field field = aClass.getField(<span class="string">"someField"</span>);</span><br><span class="line">Object fieldType = field.getType();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>通过调用<code>Field.get()</code>或<code>Field.set()</code>方法获取或设置(get/set)变量值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = MyObject.class</span><br><span class="line">Field field = aClass.getField(<span class="string">"someField"</span>);</span><br><span class="line"></span><br><span class="line">MyObject objectInstance = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line">Object value = field.get(objectInstance);</span><br><span class="line"></span><br><span class="line">field.set(objetInstance, value);</span><br></pre></td></tr></table></figure></p>
<h1 id="获取指定类的getters和setters"><a href="#获取指定类的getters和setters" class="headerlink" title="获取指定类的getters和setters"></a>获取指定类的getters和setters</h1><ul>
<li>Getter：Getter方法的名字以get开头，没有方法参数，返回一个值</li>
<li>Setter：Setter方法的名字以set开头，有一个方法参数</li>
</ul>
<p>一个获取getter方法和setter方法的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGettersSetters</span><span class="params">(Class aClass)</span></span>&#123;</span><br><span class="line">  Method[] methods = aClass.getMethods();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isGetter(method)) System.out.println(<span class="string">"getter: "</span> + method);</span><br><span class="line">    <span class="keyword">if</span>(isSetter(method)) System.out.println(<span class="string">"setter: "</span> + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"get"</span>))      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">void</span>.class.equals(method.getReturnType()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"set"</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="获取私有变量"><a href="#获取私有变量" class="headerlink" title="获取私有变量"></a>获取私有变量</h1><p>可以通过调用<code>Class.getDeclaredField(String name)</code>方法或者<code>Class.getDeclaredFields()</code>方法获取私有变量和受保护变量，不包括超类的成员；<code>Class.getField(String name)</code>和<code>Class.getFields()</code>只会返回公有变量，其中包括超类的公有变量，而无法获取私有变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String privateString = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrivateObject</span><span class="params">(String privateString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.privateString = privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line">PrivateObject privateObject = <span class="keyword">new</span> PrivateObject(<span class="string">"The Private Value"</span>);</span><br><span class="line"></span><br><span class="line">Field privateStringField = PrivateObject.class.</span><br><span class="line">            getDeclaredField(<span class="string">"privateString"</span>);</span><br><span class="line"></span><br><span class="line">privateStringField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">String fieldValue = (String) privateStringField.get(privateObject);</span><br><span class="line">System.out.println(<span class="string">"fieldValue = "</span> + fieldValue);</span><br></pre></td></tr></table></figure></p>
<p>这个例子会输出”fieldValue = The Private Value”，<code>The Private Value</code>是<code>PrivateObject</code>实例的<code>privateString</code>私有变量的值，注意调用<code>PrivateObject.class.getDeclaredField(&quot;privateString&quot;)</code>方法会返回一个私有变量，这个方法返回的变量是定义在<code>PrivateObject</code>类中的而不是在它的父类中定义的变量。<br>注意：<code>privateStringField.setAccessible(true)</code>这行代码，通过调用<code>setAccessible()</code>方法会关闭指定类Field实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p>
<h1 id="获取私有方法"><a href="#获取私有方法" class="headerlink" title="获取私有方法"></a>获取私有方法</h1><p>可以通过调用<code>Class.getDeclaredMethod(String name, Class[] parameterTypes)</code>或者<code>Class.getDeclaredMethods()</code>方法获取私有方法，不包括超类的成员；<code>Class.getMethod(String name, Class[] parameterTypes)</code>和<code>Class.getMethods()</code>方法，只会返回公有的方法，其中包括超类的公有方法，而无法获取私有方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String privateString = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrivateObject</span><span class="params">(String privateString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.privateString = privateString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getPrivateString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br><span class="line">PrivateObject privateObject = <span class="keyword">new</span> PrivateObject(<span class="string">"The Private Value"</span>);</span><br><span class="line"></span><br><span class="line">Method privateStringMethod = PrivateObject.class.</span><br><span class="line">        getDeclaredMethod(<span class="string">"getPrivateString"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">privateStringMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">String returnValue = (String)</span><br><span class="line">        privateStringMethod.invoke(privateObject, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"returnValue = "</span> + returnValue);</span><br></pre></td></tr></table></figure></p>
<p>这个例子会输出<code>&quot;returnValue = The Private Value&quot;</code>，<code>The Private Value</code>是<code>PrivateObject</code>实例的<code>getPrivateString()</code>方法的返回值。<code>PrivateObject.class.getDeclaredMethod(&quot;privateString&quot;)</code>方法会返回一个私有方法，这个方法是定义在<code>PrivateObject</code>类中的而不是在它的父类中定义的。<br>注意：Method.setAcessible(true)这行代码，通过调用setAccessible()方法会关闭指定类的Method实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p>
<h1 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h1><p><strong>什么是注解？</strong><br>注解是Java 5的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用Java反射机制进行处理。<br>下面是一个类注解的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在TheClass类定义的上面有一个@MyAnnotation的注解。注解的定义与接口的定义相似，下面是MyAnnotation注解的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在interface前面的@符号表名这是一个注解，一旦你定义了一个注解之后你就可以将其应用到你的代码中。</p>
<blockquote>
<p>说明：在注解定义中的两个指示@Retention(RetentionPolicy.RUNTIME)和@Target(ElementType.TYPE)，说明了这个注解该如何使用。</p>
<ol>
<li>@Retention(RetentionPolicy.RUNTIME)表示这个注解可以在运行期通过反射访问。如果你没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。</li>
<li>@Target(ElementType.TYPE) 表示这个注解只能用在类型上面（比如类跟接口）。你同样可以把Type改为Field或者Method，或者你可以不用这个指示，这样的话你的注解在类，方法和变量上就都可以使用了。</li>
</ol>
</blockquote>
<hr>
<p><strong>类注解</strong><br>下是一个访问类注解的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你还可以像下面这样指定访问一个类的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation annotation = aClass.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>方法注解</strong><br>下面是一个方法注解的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line">  <span class="meta">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像这样访问方法注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">//获取方法对象</span></span><br><span class="line">Annotation[] annotations = method.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像这样访问指定的方法注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">// 获取方法对象</span></span><br><span class="line">Annotation annotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>参数注解</strong><br>方法参数也可以添加注解，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">(</span><br><span class="line">        @MyAnnotation(name=<span class="string">"aName"</span>, value=<span class="string">"aValue"</span>)</span> String parameter)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以通过Method对象来访问方法参数注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">//获取方法对象</span></span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Annotation[] annotations : parameterAnnotations)&#123;</span><br><span class="line">  Class parameterType = parameterTypes[i++];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"param: "</span> + parameterType.getName());</span><br><span class="line">        System.out.println(<span class="string">"name : "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是Method.getParameterAnnotations()方法返回一个注解类型的二维数组，每一个方法的参数包含一个注解数组。</p>
<hr>
<p><strong>变量注解</strong><br>下面是一个变量注解的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="keyword">public</span> String myField = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像这样来访问变量的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... <span class="comment">//获取方法对象&lt;/pre&gt;</span></span><br><span class="line">&lt;pre&gt;Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line"> <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line"> MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line"> System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line"> System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像这样访问指定的变量注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field field = ...<span class="comment">//获取方法对象&lt;/pre&gt;</span></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">Annotation annotation = field.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line"> MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line"> System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line"> System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Java核心技术（卷Ⅰ）</li>
<li><a href="http://ifeve.com/java-reflection/" target="_blank" rel="external">Java Reflection教程</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UML类图的几种关系]]></title>
      <url>http://gongchuangsu.com/2016/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>在UML类图中，关系可以分为4种: 泛化, 实现, 关联 和 依赖。</p>
<table>
<thead>
<tr>
<th style="text-align:left">关系名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">箭头及指向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">泛化(Generalization)</td>
<td style="text-align:left">表示”类与类之间的继承关系”</td>
<td style="text-align:left">带三角箭头的实线，箭头指向父类</td>
</tr>
<tr>
<td style="text-align:left">实现(Realization)</td>
<td style="text-align:left">表示”类与接口之间的实现”</td>
<td style="text-align:left">带三角箭头的虚线，箭头指向接口</td>
</tr>
<tr>
<td style="text-align:left">关联(Association)</td>
<td style="text-align:left">表示”类与类之间的拥有关系”。即，一个类是另一个类的成员。关联又包括：自关联, 单向关联, 双向关联, 多重性关联, 组合, 聚合</td>
<td style="text-align:left">具体分情况</td>
</tr>
<tr>
<td style="text-align:left">依赖(Dependency)</td>
<td style="text-align:left">表示”类与类之间的使用关系”。即，一个类是另一类的局部变量, 形式参数, 或者调用了静态方法/成员等</td>
<td style="text-align:left">带普通箭头的虚线，指向被使用者</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h1><p>示例：Fruit是”水果”；Apple是”苹果”，它继承了Fruit，是水果中的一种。<br>UML示例图：<br><img src="http://i.imgur.com/KjAIPU0.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现(Realization)"></a>实现(Realization)</h1><p>示例：Runnable接口表示”一个任务”，TimeTask是”计时任务”，它实现了Runnable接口。<br>UML示例图：<br><img src="http://i.imgur.com/WJPkgKK.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h1><h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><p>关系说明: 一个类包含自己。<br>箭头及指向：带普通箭头的实心线，指向自己。<br>示例: Node是单向链表中的节点，它包含下一个节点的指针。<br>UML示例图：<br><img src="http://i.imgur.com/dgXD0PP.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h2><p>关系说明：”类A”中有”类B”成员变量，”类B”中没有”类A”成员变量.<br>箭头及指向：带普通单向箭头的实心线，指向被拥有者。<br>示例：Person表示”人”，IdCard表示”身份证信息”，身份证包括id和身份证编号num。一个人拥有唯一的身份证信息。<br>UML示例图：<br><img src="http://i.imgur.com/1gBuxQw.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IdCard idcard;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h2><p>关系说明：”类A”中有”类B”成员变量，”类B”也有”类A”成员变量。<br>箭头及指向：带普通双向箭头的实心线或者不带箭头的实心线。<br>示例：Teacher表示”老师”，Student表示”学生”。老师可以有多个学生，学生也可以有多个老师。<br>UML示例图：<br><img src="http://i.imgur.com/0Au7Om5.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多重性关联"><a href="#多重性关联" class="headerlink" title="多重性关联"></a>多重性关联</h2><p>多重性关联是两个类之间在关联对象上的数量关系。</p>
<table>
<thead>
<tr>
<th style="text-align:left">表示方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1..1</td>
<td style="text-align:left">表示另一个类的一个对象只与该类的一个对象有关系</td>
</tr>
<tr>
<td style="text-align:left">0..*</td>
<td style="text-align:left">表示另一个类的一个对象与该类的零个或多个对象有关系</td>
</tr>
<tr>
<td style="text-align:left">1..*</td>
<td style="text-align:left">表示另一个类的一个对象与该类的一个或多个对象有关系</td>
</tr>
<tr>
<td style="text-align:left">0..1</td>
<td style="text-align:left">表示另一个类的一个对象没有或只与该类的一个对象有关系</td>
</tr>
<tr>
<td style="text-align:left">m..n</td>
<td style="text-align:left">表示另一个类的一个对象与该类最少m，最多n个对象有关系(m≤n)</td>
</tr>
</tbody>
</table>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>关系说明：聚合是整体与部分的关系。聚合关系是类与类之间关系比较密切的关联关系；要区分聚合和其它的关联关系，必须考察具体的逻辑关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。如车和轮胎是整体和部分的关系。<br>箭头及指向：带空心菱形的实心线，菱形指向整体。<br>示例：Car表示”汽车”，Tire表示”轮胎”，Engine表示”引擎”。”轮胎”和”引擎”本身是个独立个体。<br>UML示例图：<br><img src="http://i.imgur.com/zZQp2JQ.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Tire tire;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tire</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>关系说明：组合是整体与部分的关系。组合关系是比聚合关系还要强的关联关系。但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。例如，身体和鼻子，身体包括鼻子，鼻子不能脱离身体而独立存在。<br>箭头及指向：带实心菱形的实线，菱形指向整体。<br>示例：Body表示”身体”，Nose表示”鼻子”。身体包含鼻子，鼻子离不开身体。<br>UML示例图：<br><img src="http://i.imgur.com/ttMBuSf.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Nose nose;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Nose</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h1><p>关系说明：依赖是一种使用的关系。在需要表示一个事物使用另一个事物时使用依赖关系，尽量不使用双向的互相依赖。<br>箭头及指向：带箭头的虚线，指向被使用者。<br>示例：人过河。人是”Person”类，它包括过河函数acrossRiver()，acrossRiver()的参数是过河工具，返回值是过河时间。此处的过河工具是船，船对应的类是Boat。<br>UML示例图：<br><img src="http://i.imgur.com/e7Q9N1G.png" alt=""><br>对应的Java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">acrossRiver</span><span class="params">(Boat boat)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://wangkuiwu.github.io/2012/10/03/uml/" target="_blank" rel="external">UML系列03之 UML类图(二)</a></li>
<li><a href="http://blog.csdn.net/tianhai110/article/details/6339565" target="_blank" rel="external">UML类图几种关系的总结</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>http://gongchuangsu.com/2016/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/gwwC2wp.jpg" alt=""></p>
<a id="more"></a>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<hr>
<p><strong>实现单例模式的思路</strong></p>
<ul>
<li>一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）</li>
<li>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类持有的引用为空就创建该类的实例并将实例的引用赋予该类持有的引用</li>
<li>同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例</li>
</ul>
<hr>
<p><strong>单例模式的应用场景</strong></p>
<ul>
<li>要求生产唯一序列号</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件</li>
</ul>
<hr>
<p><strong>通常单例模式在Java语言中，有两种构建方式</strong></p>
<ul>
<li>懒汉方式：指全局的单例实例在第一次被使用时构建</li>
<li>饿汉方式：指全局的单例实例在类装载时构建<br>注意：这两种方式构建的单例类中，构造函数都是私有的，故此类不能被继承！</li>
</ul>
<h1 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h1><p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">	        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。因为没有加锁 <code>synchronized</code>，所以严格意义上它并不算单例模式。</p>
<h1 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h1><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">	        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式能够在多线程中很好的工作，但是其必须加锁synchronized才能保证单例，由于加锁会影响效率，而且99%情况下不需要同步，所以其效率很低。</p>
<h1 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h1><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">		        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">			        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">			            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">			        &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会有两次检查<code>instance == null</code>，一次是在同步块外，一次是在同步块内。</p>
<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>这种方法非常简单，因为单例的实例被声明成 static 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的，但容易产生垃圾对象，浪费内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程。这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="external">单例模式</a></li>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">如何正确地写出单例模式</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JDBC数据类型与Java数据类型对应关系]]></title>
      <url>http://gongchuangsu.com/2016/07/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JDBC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8EJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">SQL</th>
<th style="text-align:left">JDBC/JAVA</th>
<th style="text-align:left">setter</th>
<th style="text-align:left">getter</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">setString</td>
<td style="text-align:left">getString</td>
</tr>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">setString</td>
<td style="text-align:left">getString</td>
</tr>
<tr>
<td style="text-align:left">LONGVARCHAR</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">setString</td>
<td style="text-align:left">getString</td>
</tr>
<tr>
<td style="text-align:left">BIT</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">setBoolean</td>
<td style="text-align:left">getBoolean</td>
</tr>
<tr>
<td style="text-align:left">NUMERIC</td>
<td style="text-align:left">BigDecimal</td>
<td style="text-align:left">setBigDecimal</td>
<td style="text-align:left">getBigDecimal</td>
</tr>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">byte</td>
<td style="text-align:left">setByte</td>
<td style="text-align:left">getByte</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">short</td>
<td style="text-align:left">setShort</td>
<td style="text-align:left">getShort</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:left">int</td>
<td style="text-align:left">setInt</td>
<td style="text-align:left">getInt</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">long</td>
<td style="text-align:left">setLong</td>
<td style="text-align:left">getLong</td>
</tr>
<tr>
<td style="text-align:left">REAL</td>
<td style="text-align:left">float</td>
<td style="text-align:left">setFloat</td>
<td style="text-align:left">getFloat</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">float</td>
<td style="text-align:left">setFloat</td>
<td style="text-align:left">getFloat</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">double</td>
<td style="text-align:left">setDouble</td>
<td style="text-align:left">getDouble</td>
</tr>
<tr>
<td style="text-align:left">VARBINARY</td>
<td style="text-align:left">byte[]</td>
<td style="text-align:left">setBytes</td>
<td style="text-align:left">getBytes</td>
</tr>
<tr>
<td style="text-align:left">BINARY</td>
<td style="text-align:left">byte[]</td>
<td style="text-align:left">setBytes</td>
<td style="text-align:left">getBytes</td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left">setDate</td>
<td style="text-align:left">getDate</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">java.sql.Time</td>
<td style="text-align:left">setTime</td>
<td style="text-align:left">getTime</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">java.sql.Timestamp</td>
<td style="text-align:left">setTimestamp</td>
<td style="text-align:left">getTimestamp</td>
</tr>
<tr>
<td style="text-align:left">CLOB</td>
<td style="text-align:left">java.sql.Clob</td>
<td style="text-align:left">setClob</td>
<td style="text-align:left">getClob</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">java.sql.Blob</td>
<td style="text-align:left">setBlob</td>
<td style="text-align:left">getBlob</td>
</tr>
<tr>
<td style="text-align:left">ARRAY</td>
<td style="text-align:left">java.sql.Array</td>
<td style="text-align:left">setARRAY</td>
<td style="text-align:left">getARRAY</td>
</tr>
<tr>
<td style="text-align:left">REF</td>
<td style="text-align:left">java.sql.Ref</td>
<td style="text-align:left">SetRef</td>
<td style="text-align:left">getRef</td>
</tr>
<tr>
<td style="text-align:left">STRUCT</td>
<td style="text-align:left">java.sql.Struct</td>
<td style="text-align:left">SetStruct</td>
<td style="text-align:left">getStruct</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书笔记之《程序员必读的职业规划书》]]></title>
      <url>http://gongchuangsu.com/2016/07/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E4%B9%A6%E3%80%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/wqs5aLg.png" alt=""></p>
<a id="more"></a>
<h1 id="准备篇"><a href="#准备篇" class="headerlink" title="准备篇"></a>准备篇</h1><hr>
<p><strong>构建个人品牌</strong></p>
<ul>
<li>公司品牌不是个人品牌</li>
<li>个人品牌是自己可以带走的东西</li>
<li>如何构建个人品牌<ul>
<li>Github账号</li>
<li>技术博客：可以托管至Gtihub或CSDN</li>
<li>微博，最好能加V，用于业内交流</li>
<li>技术社区账号，如stackoverflow</li>
</ul>
</li>
</ul>
<hr>
<p><strong>学会分享</strong></p>
<ul>
<li>学会分享，既能传播自己的知识，又能得到有益的反馈</li>
<li>分享渠道<ul>
<li>发布到自己的技术博客</li>
<li>同步至微博</li>
<li>微信公众号推送</li>
<li>提交至CSDN头条</li>
</ul>
</li>
</ul>
<hr>
<p><strong>学会沟通和写作</strong></p>
<ul>
<li>条理性：多级列表的形式，把内容细分化</li>
<li>逻辑性：条理清晰、逻辑顺畅</li>
</ul>
<hr>
<p><strong>做好开源项目</strong></p>
<ul>
<li>来自于真实的需求</li>
<li>持续更新的毅力</li>
</ul>
<hr>
<p><strong>提升架构能力</strong></p>
<ul>
<li>Don’t Repeat Yourself，不做重复事</li>
<li>解耦，功能之间尽可能互不干扰</li>
</ul>
<hr>
<p><strong>根据需求调整自己的定位</strong></p>
<ul>
<li>学会观察技术趋势</li>
<li>投资新兴市场和细分市场</li>
</ul>
<hr>
<p><strong>职业画布</strong><br><img src="http://i.imgur.com/SMQqbQ2.png" alt=""></p>
<h1 id="操作篇"><a href="#操作篇" class="headerlink" title="操作篇"></a>操作篇</h1><hr>
<p><strong>简历</strong></p>
<ul>
<li>FAB<ul>
<li>Feature:自己有哪些特点</li>
<li>Advantage:与竞争对手相比，有哪些优势</li>
<li>Benefit:能给公司带来什么收益</li>
</ul>
</li>
<li>实事求是，突出能力，显现潜力</li>
</ul>
<hr>
<p><strong>求职渠道</strong></p>
<ul>
<li>人脉推荐是最好的求职渠道</li>
<li>内推网、拉勾网</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016暑期规划]]></title>
      <url>http://gongchuangsu.com/2016/07/01/%E5%85%B6%E5%AE%83/2016%E6%9A%91%E6%9C%9F%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/4Jrksf0.jpg" alt=""></p>
<a id="more"></a>
<blockquote>
<p>不积跬步，无以至千里；不积小流，无以成江海。 —— 荀子《劝学篇》 </p>
</blockquote>
<hr>
<p><strong>刷笔试题</strong></p>
<ul>
<li>以牛客网为主，完成笔试练习，包括智力题(417道)、Java编程语言(433道)、数据结构以及算法。</li>
</ul>
<hr>
<p><strong>刷编程题</strong></p>
<ul>
<li>以牛客网为主，完成66道剑指Offer编程题，108道华为机试题，部分leetcode编程题。</li>
</ul>
<hr>
<p><strong>看书</strong></p>
<ol>
<li>看完《剑指Offer》，并整理相关笔记</li>
<li>看完《深入理解Java虚拟机》，并整理相关笔记</li>
<li>第二遍《大话数据结构》，做到各种排序算法烂熟于心</li>
<li>第二遍《Java编程思想》，深入理解基础知识，整理相关笔记</li>
</ol>
<hr>
<p><strong>学习Spring框架</strong></p>
<ul>
<li>熟悉Spring开发框架，熟悉JSP和Servlet技术</li>
</ul>
<hr>
<p><strong>进阶目标</strong></p>
<ul>
<li>学习构建工具Maven</li>
<li>学习Java集合源码</li>
<li>学习Java多线程</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解接口和抽象类]]></title>
      <url>http://gongchuangsu.com/2016/06/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/djv2vD3.jpg" alt=""></p>
<a id="more"></a>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul>
<li>如果一个类包含一个或多个抽象方法，该类必须被声明为抽象类</li>
<li>抽象类可以包含具体的方法，也可以不包含任何抽象方法</li>
<li>如果一个类继承自抽象类，那么该类必须实现抽象类中所有的抽象方法(即提供方法体{})，否则该类必须声明为抽象类</li>
<li>不能为抽象类创建任何对象，即使该抽象类不包含任何抽象方法</li>
<li>abstract不能与final并列修饰同一个类</li>
<li>abstract不能与private、static、final或native并列修饰同一个方法</li>
</ul>
<blockquote>
<p>抽象方法：仅有声明而没有方法体的方法。如<code>abstract void f();</code></p>
</blockquote>
<p>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"This is a man."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"This is a women."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	  	  </span><br><span class="line">    	People man = <span class="keyword">new</span> Man();</span><br><span class="line">    	People women = <span class="keyword">new</span> Women();</span><br><span class="line">    	man.f();</span><br><span class="line">    	women.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is a man.</span><br><span class="line">This is a women.</span><br></pre></td></tr></table></figure></p>
<p>抽象类中的抽象方法可以由其子类进行不同的实现，而且抽象类中的抽象方法子类必须实现，否则会出现编译错误。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>接口可以包含域，这些域隐式地是static和final的，而且只能是static和final的，即常量，非普通成员变量，<strong>其必须在声明时显式的初始化</strong></li>
<li>在实现一个接口时，接口中被定义的方法必须被定义为<code>public</code>的，否则会出现编译错误</li>
<li>接口中的方法都默认为<code>public</code>的和<code>abstract</code>的，而且只能是<code>public</code>的和<code>abstract</code>的</li>
<li>当实现某个接口时，并不需要实现嵌套在其内部的任何接口</li>
<li>在实现多接口时，一定要避免方法名的重复</li>
</ul>
<blockquote>
<p>注意：在最新的Java 8中，接口可以拥有非抽象的普通方法。</p>
</blockquote>
<hr>
<p><strong>Java中的多重继承</strong></p>
<ul>
<li>一个类可以继承多个接口类，但只能继承一个非接口类(具体类/抽象类)</li>
<li>implements必须在extends之后，否则编译器会报错</li>
<li>当想要创建对象时，所有方法(包括各个接口中的方法以及具体类/抽象类中的方法)的定义首先必须都存在</li>
</ul>
<p>下面的例子展示了一个具体类组合数个接口之后产生的一个新类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Canfly</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ActionCharacter.fight()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">Canfly</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CanSwim.swim()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Canfly.fly()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123;x.fight();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123;x.swim();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(Canfly x)</span> </span>&#123;x.fly();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123;x.fight();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	  	  </span><br><span class="line">    	Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">    	t(hero);</span><br><span class="line">    	u(hero);</span><br><span class="line">    	v(hero);</span><br><span class="line">    	w(hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActionCharacter.fight()</span><br><span class="line">CanSwim.swim()</span><br><span class="line">Canfly.fly()</span><br><span class="line">ActionCharacter.fight()</span><br></pre></td></tr></table></figure></p>
<p>特别注意，在类Hero中并没有提供fight()方法的定义，但为什么编译没有出错呢？细心的同学会发现，CanFight接口与ActionCharacter类中的fight()方法的特征签名是一样的。即使类Hero中没有显式地提供fight()方法的定义，其定义也因ActionCharacter类而随之而来。<br>同时，上述例子也向我们展示了多重继承可以实现一个类能够向上转型为多个基类型，及由此带来的灵活性。</p>
<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><hr>
<p><strong>从语法定义层面上看抽象类和接口</strong></p>
<ul>
<li>使用抽象类的方式定义Demo类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用接口的方式定义Demo类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在抽象类方式中，Demo类可以有任意范围的成员变量，也可以有非abstract的成员方法；而在接口方式中，Demo类只能拥有静态的且不可修改的成员变量(即static final型)，而且所有的成员方法都是abstract的。从某种意义上说，接口是一种特殊形式的抽象类，它比抽象类更加抽象。<br>抽象类在Java语言中表示一种继承关系，一个类只能使用一次继承关系；但是一个类却可以实现多个接口。<br>在抽象类的定义中，可以实现某些方法，赋予其默认行为；而在接口中，所有的方法都是抽象的，即不能拥有默认行为</p>
<hr>
<p><strong>从设计理念层面上看抽象类和接口</strong><br>前面已经提到过，abstract class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a”关系，即父类和派生类在概念本质上应该是相同的。对于interface来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。为了使论述便于理解，下面将通过一个简单的实例进行说明。<br>例2：假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close，此时我们可以通过abstract class或者interface来定义一个表示该抽象概念的类型，定义方式分别如下所示：</p>
<ul>
<li><p>使用抽象类的方式定义Door类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>；  </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用接口的方式定义Door类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其他具体的Door类型可以extends使用抽象类方式定义的Door或者implements使用接口方式定义的Door。看起来好像使用抽象类和接口没有大的区别。<br>如果现在要求Door还要具有报警的功能。我们该如何设计针对该例子的类结构呢？</p>
<hr>
<p><strong>解决方案一：</strong><br>简单的在Door的定义中增加一个alarm方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么具有报警功能的AlarmDoor的定义方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">implements</span> <span class="title">Door</span>｛</span><br><span class="line">	<span class="title">void</span> <span class="title">open</span>()</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<p>这种方法违反了面向对象设计中的一个核心原则<code>ISP (Interface Segregation Principle)</code>，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变（比如：修改alarm方法的参数）而改变，反之亦然。</p>
<hr>
<p><strong>解决方案二：</strong></p>
<ul>
<li><p>如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报警的功能。那么可以这样进行设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们对于问题领域的理解是：AlarmDoor在概念本质上是报警器，同时它有具有Door的功能。那么可以这样进行设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Alarm</span> <span class="keyword">implements</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述两种不同的实现方式反映了我们对问题领域的不同理解，正确的揭示我们的设计意图。</p>
<blockquote>
<p>抽象类表示的是“is-a”关系，接口表示的是“has-a”关系。</p>
</blockquote>
<h1 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h1><p>1.<strong>关于构造函数</strong><br>抽象类和接口都是不可实例化的，但为什么抽象类可以有构造函数而接口却不能拥有？<br>这是因为抽象类需要被其他类继承，其子类是可以实例化的，在实例化时需要调用子类的构造函数，而默认情况下，在调用子类构造函数前都会调用父类的构造函数。<br>而接口没有这种继承关系，故不需要。</p>
<hr>
<p>2.<strong>抽象类只能被继承？</strong><br>这种说法是不正确的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Test() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.say();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span><br><span class="line">hello!</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>通过上面代码可知，抽象类不仅仅可以用来继承，还可以单纯地只输出。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Java编程思想</li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3811437.html#top" target="_blank" rel="external">深入理解Java的接口和抽象类</a></li>
<li><a href="http://blog.csdn.net/chenssy/article/details/12858267" target="_blank" rel="external">java提高篇（四）—–抽象类与接口</a></li>
<li><a href="http://dev.yesky.com/436/7581936.shtml#top" target="_blank" rel="external">详细解析Java中抽象类和接口的区别</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用SpEL表达式装配Bean]]></title>
      <url>http://gongchuangsu.com/2016/06/22/Spring/%E4%BD%BF%E7%94%A8SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A3%85%E9%85%8DBean/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/5OykS70.jpg" alt=""></p>
<a id="more"></a>
<p><strong>字面值：</strong><br>在<code>&lt;property&gt;</code>元素的<code>value</code>属性中使用<code>#{}</code>界定符把这个值装配到Bean的属性中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span> <span class="attr">value</span>=<span class="string">"#&#123;5&#125;"</span>/&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--浮点型数字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"frequence"</span> <span class="attr">value</span>=<span class="string">"#&#123;89.7&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--科学计数法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"capacity"</span> <span class="attr">value</span>=<span class="string">"#&#123;1e4&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--布尔型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enable"</span> <span class="attr">value</span>=<span class="string">"#&#123;false&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>#{}</code>标记会提示Spring这个标记里的内容是SpEL表达式，它们还可以与非SpEL表达式的值混用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span> <span class="attr">value</span>=<span class="string">"The value is #&#123;5&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>String类型的字面值可以使用单引号或双引号作为字符串的界定符：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'Chuck'&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">'#&#123;"Chuck"&#125;'</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>引用Bean、Properties和方法</strong><br>在SpEL表达式中使用Bean ID将一个Bean装配到另一个Bean的属性中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">value</span>=<span class="string">"#&#123;saxophone&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">ref</span>=<span class="string">"saxophone"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在SpEL表达式中使用Bean的引用来获取Bean的属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carl"</span></span><br><span class="line">      <span class="attr">class</span>=<span class="string">"com.springinaction.springidol.Instrumentalist"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">vaule</span>=<span class="string">"#&#123;kenny.song&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其等价于以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instrumentalist carl = <span class="keyword">new</span> Instrumentalist();</span><br><span class="line">carl.setSong(kenny.getSong());</span><br></pre></td></tr></table></figure></p>
<p>在SpEL表达式中使用Bean的引用来调用Bean的方法，假设这里有一个songSelector Bean，该Bean有一个selectSong()方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;songSelector.selectSong()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在SpEL表达式中使用null-safe存取器避免抛出空指针异常(NullPointerException)：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--没有使用null-safe存取器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;songSelector.selectSong().toUpperCase()&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用null-safe存取器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;songSelector.selectSong()?.toUpperCase()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有使用null-safe存取器，则selectSong()返回null值会导致空指针异常，而使用null-safe存取器，即使用<code>?.</code>运算符代替点<code>.</code>来访问toUpperCase()方法，在访问右方法之前，该运算符会确保左边项的值不会为null。如果为null，则SpEL不再尝试调用toUpperCase()方法。</p>
<hr>
<p><strong>操作类：</strong><br>在SpEL中，使用T()运算符会调用类作用域的方法和常量。<br>在SpEL表达式中使用T()运算符将指定类的静态常量装配到Bean的一个属性中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--只需简单引用Math类的PI常量即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"multiplier"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).PI&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用T()运算符调用静态方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将一个随机数（在0到1之间）装配到Bean的一个属性中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"randomNumber"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math)random()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpEL运算符]]></title>
      <url>http://gongchuangsu.com/2016/06/22/Spring/SpEL%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/UlRR8cf.jpg" alt=""></p>
<a id="more"></a>
<p>SpEL提供了几种运算符，这些运算符可以用在SpEL表达式中的值上。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符类型</th>
<th style="text-align:left">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">算术运算</td>
<td style="text-align:left">+、-、*、/、%、^</td>
</tr>
<tr>
<td style="text-align:left">关系运算</td>
<td style="text-align:left">&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge</td>
</tr>
<tr>
<td style="text-align:left">逻辑运算</td>
<td style="text-align:left">and、or、not、&#124;</td>
</tr>
<tr>
<td style="text-align:left">条件运算</td>
<td style="text-align:left">?:(ternary)、?:(Elvis)</td>
</tr>
<tr>
<td style="text-align:left">正则表达式</td>
<td style="text-align:left">matches</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>数值运算</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- +运算符：两个数字相加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adjustedAmount"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total + 42&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- +运算符：用于连接字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fullName"</span> <span class="attr">value</span>=<span class="string">"#&#123;performer.firstName + ' ' + performer.lastName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- -运算符：两个数字相减 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adjustedAmount"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total - 20&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- *运算符：乘法运算 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"circumference"</span> <span class="attr">value</span>=<span class="string">"#&#123;2 * T(java.lang.Math).PI * circle.radius&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /运算符：除法运算 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"average"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total / counter.count&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- %运算符：求余运算 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"remainder"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total % counter.count&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ^运算符：乘方运算 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"area"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).PI * circle.radius ^ 2&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：+运算符可以执行字符串连接。</p>
</blockquote>
<hr>
<p><strong>比较值</strong><br>比较两个值是否相等，可以使用”==”运算符：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假设equal属性为布尔属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total == 100&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>类似的，其他的关系运算符可以用于比较不同的值。<br>特别注意：由于小于等于和大于等于这两个符号在XML中有特殊意义，所以在Spring的XML配置文件中使用这两个符号时，会报错。当在XML中使用SpEL时，最好对这些运算符使用SpEL的文本替代方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">文本类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等于</td>
<td style="text-align:center">==</td>
<td style="text-align:center">eq</td>
</tr>
<tr>
<td style="text-align:center">小于</td>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">lt</td>
</tr>
<tr>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">le</td>
</tr>
<tr>
<td style="text-align:center">大于</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">gt</td>
</tr>
<tr>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">ge</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>逻辑表达式</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- and 运算符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"largeCircle"</span> <span class="attr">value</span>=<span class="string">"#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ! 运算符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outOfStock"</span> <span class="attr">value</span>=<span class="string">"#&#123;!product.availiable&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- not 运算符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outOfStock"</span> <span class="attr">value</span>=<span class="string">"#&#123;not product.availiable&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:left">逻辑AND运算操作，只有运算符两边都是true，表达式才能是true</td>
</tr>
<tr>
<td style="text-align:center">or</td>
<td style="text-align:left">逻辑OR运算操作，只要运算符的任意一边是true，表达式就会是true</td>
</tr>
<tr>
<td style="text-align:center">not或!</td>
<td style="text-align:left">逻辑NOT运算操作，对运算结果求反</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>条件表达式</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ?:三元运算符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song != null ? kenny.song : 'Greensleeves'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果kenny.song值为空，则赋值kenny.song ，否则赋值’Greensleeves’。这里’Greensleeves’的引用重复两次，可简化表达式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ?:三元运算符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song != null ? 'Greensleeves'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当以这种方式使用时，“?:”通常被称为elvis运算符，而第一种方式则称为ternary运算符。</p>
<hr>
<p><strong>SpEL的正则表达式</strong><br>SpEL通过matches运算符来支持表达式中的模式匹配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 判断一个字符串是否是有效的邮件地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validEmail"</span> <span class="attr">value</span>=<span class="string">"#&#123;admin.email matches '[a-zA-Z0-9.-%+-]+@[a-zA-Z0-9.-]+\\.com'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Servlet 3.0新增注释]]></title>
      <url>http://gongchuangsu.com/2016/06/21/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Servlet%203.0%E6%96%B0%E5%A2%9E%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>新增注释是Servlet 3.0中的重大革新之一。通过使用注释就无需在web.xml文件中对Servlet或者过滤器进行配置。</p>
<blockquote>
<p>新增的注释支持：Servlet 3.0的部署描述文件web.xml的顶层标签 <web-app> 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。<br>如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解<br>如果不配置该属性，或者将其设置为 false，则表示启用注解支持</web-app></p>
</blockquote>
<p>Servlet 3.0新增的注释有<code>@WebServlet</code>、<code>@WebFilter</code>、<code>@WebListener</code>和<code>@WebInitParam</code>等。</p>
<a id="more"></a>
<h1 id="WebServlet"><a href="#WebServlet" class="headerlink" title="@WebServlet"></a>@WebServlet</h1><p>@WebServlet注释定义在Servlet的类声明之前，用于定义Servlet组件。使用该注释，就无需在web.xml文件中对Servlet进行配置。@WebServlet主要属性如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">String</td>
<td style="text-align:left">指定 Servlet 的 name 属性，等价于 <servlet-name>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名</servlet-name></td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">该属性等价于 urlPatterns 属性。两个属性不能同时使用</td>
</tr>
<tr>
<td style="text-align:left">urlPatterns</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">指定一组 Servlet 的 URL 匹配模式。等价于 <url-pattern> 标签</url-pattern></td>
</tr>
<tr>
<td style="text-align:left">loadOnStartup</td>
<td style="text-align:left">int</td>
<td style="text-align:left">指定 Servlet 的加载顺序，等价于 <load-on-startup> 标签</load-on-startup></td>
</tr>
<tr>
<td style="text-align:left">initParams</td>
<td style="text-align:left">WebInitParam[]</td>
<td style="text-align:left">指定一组 Servlet 初始化参数，等价于 <init-param> 标签</init-param></td>
</tr>
<tr>
<td style="text-align:left">asyncSupported</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">声明 Servlet 是否支持异步操作模式，等价于 <async-supported> 标签</async-supported></td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">String</td>
<td style="text-align:left">该 Servlet 的描述信息，等价于 <description> 标签</description></td>
</tr>
<tr>
<td style="text-align:left">displayName</td>
<td style="text-align:left">String</td>
<td style="text-align:left">该 Servlet 的显示名，通常配合工具使用，等价于 <display-name> 标签</display-name></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：以上所有属性均为可选属性，但<code>value</code>和<code>urlPatterns</code>其中一个必存在，若两个同时存在，一般忽略<code>value</code>取值。</p>
</blockquote>
<p>例：<br><strong>SimpleServlet.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = &#123;<span class="string">"/simple"</span>&#125;, asyncSupported = <span class="keyword">true</span>, </span><br><span class="line">loadOnStartup = -<span class="number">1</span>, name = <span class="string">"SimpleServlet"</span>, displayName = <span class="string">"ss"</span>, </span><br><span class="line">initParams = &#123;<span class="meta">@WebInitParam</span>(name = <span class="string">"username"</span>, value = <span class="string">"tom"</span>)&#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123; … &#125;</span><br></pre></td></tr></table></figure></p>
<p>其等价于以下的<strong>web.xml</strong>文件配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>footmark.servlet.SimpleServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/simple<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="WebFilter"><a href="#WebFilter" class="headerlink" title="@WebFilter"></a>@WebFilter</h1><p>@WebFilter注释器用于声明过滤器，该注释将会在部署时被容器处理，容器根据具体的属性配置将相应的类部署为过滤器。</p>
<p>@WebFilter主要属性如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">filterName</td>
<td style="text-align:left">String</td>
<td style="text-align:left">指定过滤器的 name 属性，等价于 <filter-name></filter-name></td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">该属性等价于 urlPatterns 属性。但是两者不应该同时使用</td>
</tr>
<tr>
<td style="text-align:left">urlPatterns</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">指定一组过滤器的 URL 匹配模式。等价于 <url-pattern> 标签</url-pattern></td>
</tr>
<tr>
<td style="text-align:left">servletNames</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 <servlet-name> 的取值</servlet-name></td>
</tr>
<tr>
<td style="text-align:left">dispatcherTypes</td>
<td style="text-align:left">DispatcherType</td>
<td style="text-align:left">指定过滤器的转发模式。具体取值包括：ASYNC、ERROR 、FORWARD、INCLUDE、REQUEST</td>
</tr>
<tr>
<td style="text-align:left">initParams</td>
<td style="text-align:left">WebInitParam[]</td>
<td style="text-align:left">指定一组过滤器初始化参数，等价于 <init-param> 标签</init-param></td>
</tr>
<tr>
<td style="text-align:left">asyncSupported</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">声明过滤器是否支持异步操作模式，等价于 <async-supported> 标签</async-supported></td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">String</td>
<td style="text-align:left">该过滤器的描述信息，等价于 <description> 标签</description></td>
</tr>
<tr>
<td style="text-align:left">displayName</td>
<td style="text-align:left">String</td>
<td style="text-align:left">该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签</display-name></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：以上所有属性均为可选属性，但<code>value</code>、<code>urlPatterns</code>和<code>servletNames</code>三者必须至少包含一个，若<code>value</code>和<code>urlPatterns</code>两个同时存在，一般忽略<code>value</code>取值。</p>
</blockquote>
<p>例：<br><strong>LessThanSixFilter.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(servletNames = &#123;<span class="string">"SimpleServlet"</span>&#125;,filterName=<span class="string">"SimpleFilter"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LessThanSixFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>其等价于以下的<strong>web.xml</strong>文件配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SimpleFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>LessThanSixFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SimpleFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="WebListener"><a href="#WebListener" class="headerlink" title="@WebListener"></a>@WebListener</h1><p>@WebListener注释器用于声明监听器，还可以用于充当给定Web应用上下文中各种Web应用事件的监听器的类。被@WebListener标注的类必须实现以下至少一个接口：</p>
<ul>
<li>ServletContextListener</li>
<li>ServletContextAttributeListener</li>
<li>ServletRequestListener</li>
<li>ServletRequestAttributeListener</li>
<li>HttpSessionListener</li>
<li>HttpSessionAttributeListener</li>
</ul>
<p>@WebListener的常用属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">是否可选</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String</td>
<td style="text-align:left">是</td>
<td style="text-align:left">该监听器的描述信息</td>
</tr>
</tbody>
</table>
<p>例：<br><strong>SimpleListener.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span>(<span class="string">"This is only a demo listener"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>其等价于以下的<strong>web.xml</strong>文件配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>footmark.servlet.SimpleListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="WebInitParam"><a href="#WebInitParam" class="headerlink" title="@WebInitParam"></a>@WebInitParam</h1><p>@WebInitParam注释等价于web.xml文件中的<servlet>和<filter>的<init-parm>子标签，该注释通常不单独使用，而是配合@WebServlet和@WebFilter使用。其作用是为Servlet或者过滤器指定初始化参数。<br>@WebInitParam主要属性如下表所示：</init-parm></filter></servlet></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">是否可选</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">String</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定参数的名字，等价于 <param-name></param-name></td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定参数的值，等价于 <param-value></param-value></td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">String</td>
<td style="text-align:left">是</td>
<td style="text-align:left">关于参数的描述，等价于 <description></description></td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://item.jd.com/11078111.html" target="_blank" rel="external">Java Web从入门到精通</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/" target="_blank" rel="external">Servlet 3.0 新特性详解</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSP中的九大隐含对象]]></title>
      <url>http://gongchuangsu.com/2016/06/21/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JSP%E4%B8%AD%E7%9A%84%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JSP隐含对象（又称内置对象），是指可以不加声明和创建就可以在JSP页面脚本（Java程序片和Java表达式）中使用的成员变量。</p>
</blockquote>
<p>在JSP中一共预先定义了九个隐含对象，分别为request, response, pageContext, session, application, out, config, page和exception。<br>JSP隐含对象的类型如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">隐含对象</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">javax.servlet.http.HttpServletRequest</td>
<td style="text-align:left">request</td>
</tr>
<tr>
<td style="text-align:left">response</td>
<td style="text-align:left">javax.servlet.http.HttpServletResponse</td>
<td style="text-align:left">page</td>
</tr>
<tr>
<td style="text-align:left">pageContext</td>
<td style="text-align:left">javax.servlet.jsp.PageContext</td>
<td style="text-align:left">page</td>
</tr>
<tr>
<td style="text-align:left">session</td>
<td style="text-align:left">javax.servlet.http.HttpSession</td>
<td style="text-align:left">session</td>
</tr>
<tr>
<td style="text-align:left">application</td>
<td style="text-align:left">javax.servlet.ServletContext</td>
<td style="text-align:left">application</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">javax.servlet.jsp.JspWriter</td>
<td style="text-align:left">page</td>
</tr>
<tr>
<td style="text-align:left">config</td>
<td style="text-align:left">javax.servlet.ServletConfig</td>
<td style="text-align:left">page</td>
</tr>
<tr>
<td style="text-align:left">page</td>
<td style="text-align:left">java.lang.Object</td>
<td style="text-align:left">page</td>
</tr>
<tr>
<td style="text-align:left">exception</td>
<td style="text-align:left">java.lang.Throwable</td>
<td style="text-align:left">page</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="request"><a href="#request" class="headerlink" title="request"></a>request</h1><p>request对象代表的是javax.servlet.http.HttpServletRequest类的对象，它封装了由客户端生成的HTTP请求的所有细节，主要包括HTTP头信息、系统信息、请求方式和请求参数等。通过request对象提供的相应方法可以处理客户端浏览器提交的HTTP请求中的各项参数。<br>request获取客户端信息的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getHeader(String name)</td>
<td style="text-align:left">获得HTTP协议定义的文件头信息</td>
</tr>
<tr>
<td style="text-align:left">getHeaders(String name)</td>
<td style="text-align:left">返回指定名字的request Header的所有值，其结果是一个枚举型的实例</td>
</tr>
<tr>
<td style="text-align:left">getHeadersNames()</td>
<td style="text-align:left">返回所有request Header的名字，其结果是一个枚举型的实例</td>
</tr>
<tr>
<td style="text-align:left">getMethod()</td>
<td style="text-align:left">获得客户端向服务器端传送数据的方法，如get、post、header、trace等</td>
</tr>
<tr>
<td style="text-align:left">getProtocol()</td>
<td style="text-align:left">获得客户端向服务器端传送数据所依据的协议名称</td>
</tr>
<tr>
<td style="text-align:left">getRequestURI()</td>
<td style="text-align:left">获得发出请求字符串的客户端地址，不包括请求的参数</td>
</tr>
<tr>
<td style="text-align:left">getRequestURL()</td>
<td style="text-align:left">获得发出请求字符串的客户端地址</td>
</tr>
<tr>
<td style="text-align:left">getRealPath()</td>
<td style="text-align:left">返回当前请求文件的绝对路径</td>
</tr>
<tr>
<td style="text-align:left">getRemoteAddr()</td>
<td style="text-align:left">获取客户端的IP地址</td>
</tr>
<tr>
<td style="text-align:left">getRemoteHost()</td>
<td style="text-align:left">获取客户端的主机名</td>
</tr>
<tr>
<td style="text-align:left">getServerName()</td>
<td style="text-align:left">获取服务器的名字</td>
</tr>
<tr>
<td style="text-align:left">getServerPath()</td>
<td style="text-align:left">获取客户端所请求的脚本文件的文件路径</td>
</tr>
<tr>
<td style="text-align:left">getServerPort()</td>
<td style="text-align:left">获取服务器的端口号</td>
</tr>
<tr>
<td style="text-align:left">getParameter()</td>
<td style="text-align:left">获取客户端通过表单提交过来的参数值</td>
</tr>
<tr>
<td style="text-align:left">getScheme()</td>
<td style="text-align:left">获取请求使用的模式（协议）名字</td>
</tr>
</tbody>
</table>
<p>例：<br><strong>request.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span> request内置对象的实例 <span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">aciton</span>=<span class="string">"request.jsp"</span>&gt;</span></span><br><span class="line">Get request results:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"myname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"get value"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">获取客户提交信息的方式:<span class="tag">&lt;<span class="name">%=request.getMethod()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取请求信息中的协议名名字和版本号:<span class="tag">&lt;<span class="name">%=request.getProtocol()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取发出请求字符串的客户端地址:<span class="tag">&lt;<span class="name">%=request.getRequestURI()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取发出请求字符串的客户端地址:<span class="tag">&lt;<span class="name">%=request.getRequestURL()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取提交请求的客户端的IP地址:<span class="tag">&lt;<span class="name">%=request.getRemoteAddr()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取服务器的端口号:<span class="tag">&lt;<span class="name">%=request.getServerPort()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取接受请求的服务器名称:<span class="tag">&lt;<span class="name">%=request.getServerName()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取客户端所请求的脚本文件的文件路径:<span class="tag">&lt;<span class="name">%=request.getServletPath()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取Http协议定义的文件头信息Host的值:<span class="tag">&lt;<span class="name">%=request.getHeader("host")%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取Http协议定义的文件头信息User-Agent的值:<span class="tag">&lt;<span class="name">%=request.getHeader("user-agent")%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取Http协议定义的文件头信息accept-language的值:<span class="tag">&lt;<span class="name">%=request.getHeader("accept-language")%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取请求文件的绝对路径:<span class="tag">&lt;<span class="name">%=request.getRealPath("request.jsp")%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">获取客户端通过表单提交过来的参数值:<span class="tag">&lt;<span class="name">%=request.getParameter("myname")%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取客户端的主机名:<span class="tag">&lt;<span class="name">%=request.getRemoteHost()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">获取请求中使用的模式（协议）名字:<span class="tag">&lt;<span class="name">%=request.getScheme()%</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">获取客户提交信息的方式:GET </span><br><span class="line">获取请求信息中的协议名名字和版本号:HTTP/1.1 </span><br><span class="line">获取发出请求字符串的客户端地址:/request.jsp </span><br><span class="line">获取发出请求字符串的客户端地址:http://localhost:8080/request.jsp </span><br><span class="line">获取提交请求的客户端的IP地址:127.0.0.1 </span><br><span class="line">获取服务器的端口号:8080 </span><br><span class="line">获取接受请求的服务器名称:localhost </span><br><span class="line">获取客户端所请求的脚本文件的文件路径:/request.jsp </span><br><span class="line">获取Http协议定义的文件头信息Host的值:localhost:8080 </span><br><span class="line">获取Http协议定义的文件头信息User-Agent的值:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 </span><br><span class="line">获取Http协议定义的文件头信息accept-language的值:zh-CN,zh;q=0.8,en;q=0.6 </span><br><span class="line">获取请求文件的绝对路径:D:\***\我的文档\Tomcat\apache-tomcat-8.0.35\webapps\ROOT\request.jsp </span><br><span class="line">获取客户端通过表单提交过来的参数值:request </span><br><span class="line">获取客户端的主机名:127.0.0.1 </span><br><span class="line">获取请求中使用的模式（协议）名字:http</span><br></pre></td></tr></table></figure></p>
<h1 id="response"><a href="#response" class="headerlink" title="response"></a>response</h1><p>response对象用于响应客户请求，向客户端输出信息。它封装了JSP产生的响应，并发送到客户端以响应客户端的请求。<br>response对象提供了多个方法用来处理HTTP响应，比较常用的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">setContentLength(int len)</td>
<td style="text-align:left">设置响应头的长度</td>
</tr>
<tr>
<td style="text-align:left">setContentType(String type)</td>
<td style="text-align:left">设置HTTP响应的contentType中的MIME类型</td>
</tr>
<tr>
<td style="text-align:left">getOutputStream()</td>
<td style="text-align:left">返回一个Servlet的输出流</td>
</tr>
<tr>
<td style="text-align:left">getWriter()</td>
<td style="text-align:left">返回一个PrintWriter对象</td>
</tr>
<tr>
<td style="text-align:left">getCharacterEncoding()</td>
<td style="text-align:left">获得此时响应所采用的字符编码类型</td>
</tr>
<tr>
<td style="text-align:left">sendRedirect(String location)</td>
<td style="text-align:left">将请求重新定位到一个不同的URL（页面）上</td>
</tr>
<tr>
<td style="text-align:left">setHeader(String headername, String value)</td>
<td style="text-align:left">使用指定的头名字以及相应的值来设置头信息</td>
</tr>
<tr>
<td style="text-align:left">addheader(String headername, String value)</td>
<td style="text-align:left">把指定的头名字以及相应值添加到头信息当中去</td>
</tr>
</tbody>
</table>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session在网络中被称为会话，它是javax.servlet.http.HttpSession.session类的对象。由于HTTP协议是一种无状态协议，也就是当一个客户端向服务器发出请求，服务器接收请求，并返回响应后，该连接就结束了，而服务器是不保存相关的信息。为了弥补这一缺点，HTTP协议提供了session。通过session可以在应用程序的Web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到关闭浏览器。</p>
<blockquote>
<p>如果在一个会话中，客户端长时间不向服务器发出请求，session对象就会自动消失。这取决于服务器，Tomcat服务器默认为30分钟。</p>
</blockquote>
<p>session对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getId()</td>
<td style="text-align:left">返回唯一的标识，这些标识为每个session而产生</td>
</tr>
<tr>
<td style="text-align:left">getCreationTime()</td>
<td style="text-align:left">返回session被创建的时间，最小单位为千分之一秒</td>
</tr>
<tr>
<td style="text-align:left">getLastAccessedTime()</td>
<td style="text-align:left">返回客户端最后一次与会话相关联的请求时间</td>
</tr>
<tr>
<td style="text-align:left">getMaxInactiveInterval()</td>
<td style="text-align:left">以秒为单位返回会话内两个请求最大时间间隔</td>
</tr>
<tr>
<td style="text-align:left">setMaxInactiveInterval()</td>
<td style="text-align:left">以秒为单位设置session的有效时间</td>
</tr>
<tr>
<td style="text-align:left">getAttribute(String key)</td>
<td style="text-align:left">通过给定的关键字获取一个存储在session中相对应的信息</td>
</tr>
<tr>
<td style="text-align:left">setAttribute(String key, Object obj)</td>
<td style="text-align:left">提供一个关键词和一个对象值，然后存在session当中</td>
</tr>
<tr>
<td style="text-align:left">removeAttribute(String name)</td>
<td style="text-align:left">从session会话中移除指定的绑定对象</td>
</tr>
<tr>
<td style="text-align:left">invalidate()</td>
<td style="text-align:left">销毁session</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：session中保存和查找的信息不能是基本数据类型，如int、double等，而必须是java对象，如Integer、Double等。</p>
</blockquote>
<p>具体例子可参考<a href="http://gongchuangsu.com/2016/06/21/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JSP%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%8C%83%E5%9B%B4%E5%B1%9E%E6%80%A7/">JSP中的四种范围属性</a>。</p>
<h1 id="application"><a href="#application" class="headerlink" title="application"></a>application</h1><p>application是javax.servlet.ServletContext类的对象。该对象用于保存所有应用程序中的公有数据。它在服务器启动时自动创建，在服务器停止时销毁。当application对象没有被销毁时，所有用户都可以共享该application对象。</p>
<p>application对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getInitParameter(String name)</td>
<td style="text-align:left">返回已命名的应用程序初始化参数值</td>
</tr>
<tr>
<td style="text-align:left">getAttributeNames()</td>
<td style="text-align:left">返回所有已定义的应用程序初始化参数名的枚举</td>
</tr>
<tr>
<td style="text-align:left">getAttribute(String name)</td>
<td style="text-align:left">从application对象中获取指定对象名</td>
</tr>
<tr>
<td style="text-align:left">setAttribute(String name, Object obj)</td>
<td style="text-align:left">保存一个对象信息，并指定给一个名称</td>
</tr>
<tr>
<td style="text-align:left">removeAttribute(String name)</td>
<td style="text-align:left">从application对象中去掉指定名称的属性</td>
</tr>
<tr>
<td style="text-align:left">getServletInfo()</td>
<td style="text-align:left">返回JSP引擎的相关信息</td>
</tr>
<tr>
<td style="text-align:left">getRealPath(String path)</td>
<td style="text-align:left">返回虚拟路径的真实路径</td>
</tr>
<tr>
<td style="text-align:left">getContext(String URLPath)</td>
<td style="text-align:left">返回执行Web应用的application对象</td>
</tr>
<tr>
<td style="text-align:left">getMajorVersion()</td>
<td style="text-align:left">返回服务器所支持的Servlet API最大版本号</td>
</tr>
<tr>
<td style="text-align:left">getMinorVersion()</td>
<td style="text-align:left">返回服务器所支持的Servlet API最小版本号</td>
</tr>
<tr>
<td style="text-align:left">getMineType(String file)</td>
<td style="text-align:left">返回指定文件的MIME类型</td>
</tr>
<tr>
<td style="text-align:left">getResource(String path)</td>
<td style="text-align:left">返回指定资源的URL路径</td>
</tr>
<tr>
<td style="text-align:left">getResourceAsStream(String path)</td>
<td style="text-align:left">返回指定资源的输入流</td>
</tr>
<tr>
<td style="text-align:left">getRequestDispatcher(String URLPath)</td>
<td style="text-align:left">返回指定资源的RequestDispatcher对象</td>
</tr>
<tr>
<td style="text-align:left">getServlet(String name)</td>
<td style="text-align:left">返回指定名称的Servlet</td>
</tr>
<tr>
<td style="text-align:left">getServlets()</td>
<td style="text-align:left">返回所有的Servlet，返回类型为枚举型</td>
</tr>
<tr>
<td style="text-align:left">getServletNames()</td>
<td style="text-align:left">返回所有的Servlet名称，返回类型为枚举型</td>
</tr>
<tr>
<td style="text-align:left">log(String msg)</td>
<td style="text-align:left">把指定信息写入到Servlet的日志文件中</td>
</tr>
<tr>
<td style="text-align:left">log(String msg, Throwable throwable)</td>
<td style="text-align:left">把栈轨迹以及给出的Throwable异常的说明信息写入Servlet的日志文件</td>
</tr>
</tbody>
</table>
<p>具体例子可参考<a href="http://gongchuangsu.com/2016/06/21/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JSP%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%8C%83%E5%9B%B4%E5%B1%9E%E6%80%A7/">JSP中的四种范围属性</a>。</p>
<h1 id="out"><a href="#out" class="headerlink" title="out"></a>out</h1><p>out对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。out对象可以输出各种数据类型的数据，在输出非字符串类型的数据时，会自动转换为字符串进行输出。</p>
<p>out对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">print()</td>
<td style="text-align:left">在页面中打印出字符串信息，不换行</td>
</tr>
<tr>
<td style="text-align:left">println()</td>
<td style="text-align:left">在页面中打印出字符串信息，并且换行</td>
</tr>
<tr>
<td style="text-align:left">clear()</td>
<td style="text-align:left">清除缓冲区中的内容</td>
</tr>
<tr>
<td style="text-align:left">clearBuffer()</td>
<td style="text-align:left">清除当前缓冲区中的内容</td>
</tr>
<tr>
<td style="text-align:left">flush()</td>
<td style="text-align:left">刷新流</td>
</tr>
<tr>
<td style="text-align:left">getBufferSize()</td>
<td style="text-align:left">获取缓冲区大小</td>
</tr>
<tr>
<td style="text-align:left">isAutoFlush()</td>
<td style="text-align:left">检测当前缓冲区已满时是自动清空还是抛出异常</td>
</tr>
<tr>
<td style="text-align:left">close()</td>
<td style="text-align:left">关闭输出流</td>
</tr>
</tbody>
</table>
<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>config对象主要用于取得服务器的配置信息。当一个Servlet初始化时，容器把某些信息通过config对象传递给这个Servlet。</p>
<p>config对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getServletContext()</td>
<td style="text-align:left">获取Servlet上下文</td>
</tr>
<tr>
<td style="text-align:left">getInitParameter(String name)</td>
<td style="text-align:left">返回初始化参数的值</td>
</tr>
<tr>
<td style="text-align:left">getInitParameterNames()</td>
<td style="text-align:left">返回包含了Servlet初始化所需要的所有参数，返回类型是枚举型</td>
</tr>
<tr>
<td style="text-align:left">getServletName()</td>
<td style="text-align:left">获取Servlet服务器名</td>
</tr>
</tbody>
</table>
<h1 id="page"><a href="#page" class="headerlink" title="page"></a>page</h1><p>page对象代表JSP本身，只有在JSP页面内才是合法的。page对象本质上是包含当前Servlet接口引用的变量，可以看作是this关键字的别名。</p>
<p>page对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getClass()</td>
<td style="text-align:left">返回当前Object的类</td>
</tr>
<tr>
<td style="text-align:left">hashCode()</td>
<td style="text-align:left">返回此Object的哈希代码</td>
</tr>
<tr>
<td style="text-align:left">toString()</td>
<td style="text-align:left">把当前Object类转换成字符串</td>
</tr>
<tr>
<td style="text-align:left">equals(Object o)</td>
<td style="text-align:left">比较该对象和指定对象是否相等</td>
</tr>
<tr>
<td style="text-align:left">copy(Object o)</td>
<td style="text-align:left">把该对象复制到指定的对象当中去</td>
</tr>
<tr>
<td style="text-align:left">clone()</td>
<td style="text-align:left">对该对象进行克隆</td>
</tr>
</tbody>
</table>
<h1 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h1><p>exception对象用来处理JSP文件执行时发生的所有错误和异常，只有在page指令中设置为isErrorPage属性值为true的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。</p>
<p>exception对象的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getMessage()</td>
<td style="text-align:left">返回exception对象的异常信息字符串</td>
</tr>
<tr>
<td style="text-align:left">getLocalizedMessage()</td>
<td style="text-align:left">返回本地化的异常错误信息</td>
</tr>
<tr>
<td style="text-align:left">toString()</td>
<td style="text-align:left">返回关于异常错误的简单信息描述</td>
</tr>
<tr>
<td style="text-align:left">fillInStackTrace()</td>
<td style="text-align:left">重写异常错误的栈执行轨迹</td>
</tr>
</tbody>
</table>
<h1 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h1><p>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象，例如request、response以及application等。<br>pageContext对象常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getRequest()</td>
<td style="text-align:left">获取当前页面中的request对象</td>
</tr>
<tr>
<td style="text-align:left">getResponse()</td>
<td style="text-align:left">获取当前页面中的response对象</td>
</tr>
<tr>
<td style="text-align:left">getPage()</td>
<td style="text-align:left">获取当前页面中的page对象</td>
</tr>
<tr>
<td style="text-align:left">getSession()</td>
<td style="text-align:left">获取当前页面中的session对象</td>
</tr>
<tr>
<td style="text-align:left">getOut()</td>
<td style="text-align:left">获取当前页面中的out对象</td>
</tr>
<tr>
<td style="text-align:left">getException()</td>
<td style="text-align:left">获取当前页面中的exception对象</td>
</tr>
<tr>
<td style="text-align:left">getServletConfig()</td>
<td style="text-align:left">获取当前页面中的config对象</td>
</tr>
<tr>
<td style="text-align:left">getServletContext()</td>
<td style="text-align:left">获取当前页面中的application对象</td>
</tr>
<tr>
<td style="text-align:left">setAttribute(String name)</td>
<td style="text-align:left">给指定的属性名设置属性值</td>
</tr>
<tr>
<td style="text-align:left">getAttribute(String name)</td>
<td style="text-align:left">根据属性名找到相应的属性值</td>
</tr>
<tr>
<td style="text-align:left">setAttribute(String name, Object obj, int scope)</td>
<td style="text-align:left">在给定的范围内设置相应的属性值</td>
</tr>
<tr>
<td style="text-align:left">getAttribute(String name, int scope)</td>
<td style="text-align:left">在指定的范围内获取到相应的属性值</td>
</tr>
<tr>
<td style="text-align:left">findAttribute(String name)</td>
<td style="text-align:left">寻找一个属性并返回，如果没有找到则返回一个null</td>
</tr>
<tr>
<td style="text-align:left">removeAttribute(String name)</td>
<td style="text-align:left">通过属性名删除掉某个属性</td>
</tr>
<tr>
<td style="text-align:left">removeAttribute(String name, int scope)</td>
<td style="text-align:left">在指定的某个范围内删除某个属性</td>
</tr>
<tr>
<td style="text-align:left">getAttributeScope(String scope)</td>
<td style="text-align:left">返回某属性的作用域</td>
</tr>
<tr>
<td style="text-align:left">getAttributeNamesInScope(int scope)</td>
<td style="text-align:left">返回指定范围内的所有属性名的枚举</td>
</tr>
<tr>
<td style="text-align:left">release()</td>
<td style="text-align:left">释放掉pageContext()所占的所有资源</td>
</tr>
<tr>
<td style="text-align:left">forward(String relativeURLpath)</td>
<td style="text-align:left">使用当前页面重导到另一个页面</td>
</tr>
<tr>
<td style="text-align:left">include(String relativeURLpath)</td>
<td style="text-align:left">使用当前位置包含的另一个页面</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pageContext对象在实际JSP开发中一般很少使用，因为request和response等对象均为内置对象，如果通过pageContext来调用这些对象比较麻烦，都可以直接调用相关方法实现具体的功能。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://item.jd.com/11078111.html" target="_blank" rel="external">Java Web从入门到精通</a></li>
<li><a href="http://item.jd.com/10066883.html" target="_blank" rel="external">《Servlet JSP深入详解 基于Tomcat的Web开发》</a></li>
<li><a href="http://www.importnew.com/19128.html" target="_blank" rel="external">JSP九大内置对象</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSP中的四种范围属性]]></title>
      <url>http://gongchuangsu.com/2016/06/21/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JSP%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%8C%83%E5%9B%B4%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>JSP中的对象，包括用户创建的对象(如JavaBean对象)和JSP的隐含对象，都有一个范围属性。范围属性规定了这些对象的作用域，定义了在什么时间内，在哪一个JSP页面中可以被访问。在JSP中，有四种范围属性：</p>
<ul>
<li>page：在一个jsp页面内有效，跳转后无效</li>
<li>request：在一次服务请求范围内有效，可以跨越forward前后两页</li>
<li>session：在一次会话范围内有效，即从浏览器打开到浏览器关闭这个过程有效</li>
<li>application：在整个Web应用程序运行期间有效</li>
</ul>
<p>下面进行详细介绍。</p>
<a id="more"></a>
<h1 id="page范围"><a href="#page范围" class="headerlink" title="page范围"></a>page范围</h1><p>具有page范围的对象被绑定到javax.servlet.jsp.PageContext对象中。在这个范围内的对象，只能在创建对象的页面中访问。</p>
<ul>
<li>可以调用pageContext对象的getAttribute()方法来访问具有这种范围类型的对象(或通过EL表达式<code>${pageScope.XXX}</code>来访问)</li>
<li>可以调用pageContext对象的setAttribute()方法将对象保存到page范围中</li>
</ul>
<p>page范围内的对象，在客户端每次请求jsp页面时被创建，在页面向客户端发送响应或请求被转发(forward)到其他资源后被删除。<br>例1：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">pageContext.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">page</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line">Scope：$&#123;pageScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：page</span><br></pre></td></tr></table></figure></p>
<p>例2：<br><strong>main.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">pageContext.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">page</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:forward</span> <span class="attr">page</span>=<span class="string">"test.jsp"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;pageScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：</span><br></pre></td></tr></table></figure></p>
<p>对比例1和例2可以发现，page范围内的对象只能在其创建的页面内访问，其它页面内无效。</p>
<h1 id="request范围"><a href="#request范围" class="headerlink" title="request范围"></a>request范围</h1><p>具有request范围的对象被绑定到javax.servlet.http.HttpServletRequest对象中，其在一次服务请求范围内有效，可以跨越forward前后两页。</p>
<ul>
<li>可以调用request对象的getAttribute()方法来访问具有这种范围类型的对象(或通过EL表达式<code>${requestScope.XXX}</code>来访问)</li>
<li>可以调用request对象的setAttribute()方法将对象保存到request范围中 </li>
<li>在调用forward()方法转向的页面或调用include()方法包含的页面中，都可以访问这个范围内的对象</li>
<li>通过跳转进入的页面不能访问这个范围内的对象</li>
</ul>
<p>例1：<br><strong>main.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">request.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">request</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:forward</span> <span class="attr">page</span>=<span class="string">"test.jsp"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;requestScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：request</span><br></pre></td></tr></table></figure></p>
<p>例2：<br><strong>main.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">request.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">request</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test.jsp"</span>&gt;</span>获取request内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;requestScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：</span><br></pre></td></tr></table></figure></p>
<p>由例2可知，通过跳转进入的页面，不能访问原页面中request范围内的对象。</p>
<h1 id="session范围"><a href="#session范围" class="headerlink" title="session范围"></a>session范围</h1><p>具有session范围的对象被绑定到javax.servlet.http.HttpSession对象中，不管跳转至哪个页面，都可以取得该对象。</p>
<ul>
<li>可以调用session对象的getAttribute()方法来访问具有这种范围类型的对象(或通过EL表达式<code>${sessionScope.XXX}</code>来访问)</li>
<li>可以调用session对象的setAttribute()方法将对象保存到session范围中 </li>
<li>JSP容器为每一次会话创建一个HttpSession对象，在会话期间，可以访问session范围内的对象</li>
</ul>
<p>例：<br><strong>main.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">session.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">session</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test.jsp"</span>&gt;</span>跳转至test1：获取session内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test1.jsp"</span>&gt;</span>跳转至test2：获取session内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;sessionScope.scope&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test1.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;sessionScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：不管点击<a href="http://localhost:8080/test.jsp" target="_blank" rel="external">跳转至test1：获取session内容</a> 还是点击<a href="http://localhost:8080/test1.jsp" target="_blank" rel="external">跳转至test2：获取session内容</a>，都会得到同一个结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：session</span><br></pre></td></tr></table></figure></p>
<p>说明这两个jsp页面都可以取得main.jsp页面的session对象，而且取得的值是一样的。</p>
<blockquote>
<p>会话(session)：所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。只要用户不关闭浏览器，放在会话中的变量就可以被当前会话中的所有请求使用。</p>
</blockquote>
<h1 id="application范围"><a href="#application范围" class="headerlink" title="application范围"></a>application范围</h1><p>具有application范围的对象被绑定在javax.servlet.ServletContext中，在Web应用程序运行期间，所有的页面都可以访问在这个范围内的对象。</p>
<ul>
<li>可以调用application对象的getAttribute()方法来访问具有这种范围类型的对象(或通过EL表达式<code>${applicationScope.XXX}</code>来访问)</li>
<li>可以调用application对象的setAttribute()方法将对象保存到application范围中 </li>
<li>要释放application资源，只能重新启动服务器</li>
</ul>
<p>例：<br><strong>main.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line"><span class="attr">application.setAttribute</span>("<span class="attr">scope</span>", "<span class="attr">application</span>");    </span><br><span class="line">%&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test.jsp"</span>&gt;</span>跳转至test1：获取application内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test1.jsp"</span>&gt;</span>跳转至test2：获取application内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;applicationScope.scope&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>test1.jsp</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>中转页<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">Scope：$&#123;applicationScope.scope&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：运行main.jsp后，不管浏览器是否关闭过，其他所有页面都可以再次访问application范围内的对象，因为这些值是保存在服务器上的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope：session</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://item.jd.com/10066883.html" target="_blank" rel="external">《Servlet JSP深入详解 基于Tomcat的Web开发》</a></li>
<li><a href="http://blog.csdn.net/evankaka/article/details/46877371" target="_blank" rel="external">JSP九大内置对象和四种属性范围解读</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[servlet的注册和映射]]></title>
      <url>http://gongchuangsu.com/2016/06/14/Java%20Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/servlet%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Servlet程序需要在web.xml中注册和映射，才可以被Servlet引擎(容器)加载和被外界访问。</p>
</blockquote>
<h1 id="Servlet注册"><a href="#Servlet注册" class="headerlink" title="Servlet注册"></a>Servlet注册</h1><p><strong>xml代码:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在 web.xml 文件中，servlet 元素及其子元素用来注册 Servlet。</p>
<table>
<thead>
<tr>
<th style="text-align:left">元素</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">servlet-name</td>
<td style="text-align:left">指定Servlet的名称，在同一个Web应用程序中，其名称必须是唯一的</td>
<td style="text-align:left">必须包含</td>
</tr>
<tr>
<td style="text-align:left">servlet-class</td>
<td style="text-align:left">指定Servlet类的完整限定名(包含包名)</td>
<td style="text-align:left">必须包含(servlet-class或jsp-file)</td>
</tr>
<tr>
<td style="text-align:left">jsp-file</td>
<td style="text-align:left">指定在Web应用程序中的JSP文件的完整路径，该路径以斜杠(/)开始。</td>
<td style="text-align:left">必须包含(servlet-class或jsp-file)</td>
</tr>
<tr>
<td style="text-align:left">init-param</td>
<td style="text-align:left">定义Servlet的初始化参数。如果使用了init-param元素，则必须包含param-name和param-value元素，可以包含零个或多个description元素</td>
<td style="text-align:left">可以有零个或多个</td>
</tr>
<tr>
<td style="text-align:left">load-on-startup</td>
<td style="text-align:left">指定当Web应用程序启动时，Servlet被加载的次序，先加载数值小的Servlet，再加载数值大的Servlet</td>
<td style="text-align:left">可以有零个或一个</td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">为Servlet指定一个文本描述</td>
<td style="text-align:left">可以有零个或多个</td>
</tr>
</tbody>
</table>
<h1 id="Servlet映射"><a href="#Servlet映射" class="headerlink" title="Servlet映射"></a>Servlet映射</h1><p><strong>xml代码:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 web.xml 文件中，servlet-mapping 元素用来在Servlet和URL样式之间定义一个映射。它包含两个元素servlet-name和url-pattern。</p>
<ul>
<li>servlet-name：Servlet名称，其必须是在servlet元素中声明过的Servlet名称</li>
<li>url-pattern：指定对应于Servlet的URL路径</li>
</ul>
<blockquote>
<p>注意：在Servlet2.5规范中，允许servlet-mapping元素中的url-pattern子元素出现多次，之前的规范只允许一个servlet-mapping元素包含一个url-pattern子元素。</p>
</blockquote>
<h2 id="如何映射请求到Servlet？"><a href="#如何映射请求到Servlet？" class="headerlink" title="如何映射请求到Servlet？"></a>如何映射请求到Servlet？</h2><p>在配置了Servlet与URL样式之间的映射之后，当Servlet容器接收到一个请求时，它首先确定该请求应该由哪一个Web应用程序来响应。这是通过比较请求URL的开始部分与Web应用程序的上下文路径来确定的。映射到Servlet的路径是请求URL路径减去上下文路径。下面的URL路径映射规则按顺序使用找到第一个匹配后，将不会进一步尝试匹配。</p>
<ul>
<li>容器尝试对请求的路径(减去上下文路径后的路径)和Servlet映射的路径(url-pattern参数所指定的路径样式)进行精确匹配，如果匹配成功，则调用这个Servlet来处理请求</li>
<li>容器试着匹配最长的路径前缀，以斜杠(/)为路径分隔符，按照路径树逐级递减匹配，选择最长匹配的Servlet来处理请求</li>
<li>如果请求的URL路径最后有扩展名，如.jsp，Servlet容器将会试着匹配处理这个扩展名的Servlet</li>
<li>如果按照前面三条规则没有找到匹配的Servlet，容器将会调用Web应用程序默认的Servlet来对请求进行处理；如果没有定义默认的Servlet，容器将会向客户端发送HTTP 404错误信息（请求资源不存在）</li>
</ul>
<h2 id="映射规范"><a href="#映射规范" class="headerlink" title="映射规范"></a>映射规范</h2><p>在web应用部署中描述符中，以下语法用于定义映射：</p>
<ul>
<li>以‘/’字符开始，以‘/*’后缀结尾的字符串用于路径匹配</li>
<li>以‘*.’开始的字符串用于扩展名映射</li>
<li>单独的‘/’字符，用于默认的Servlet</li>
<li>所有其他的字符被用于<strong>精确匹配</strong>，如‘/login’</li>
</ul>
<p>下面列出了几个请求映射的例子：<br><strong>Servlet映射</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">URL形式</th>
<th style="text-align:left">对应的Servlet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/foo/bar/*</td>
<td style="text-align:left">servlet1</td>
</tr>
<tr>
<td style="text-align:left">/baz/*</td>
<td style="text-align:left">servlet2</td>
</tr>
<tr>
<td style="text-align:left">/catalog</td>
<td style="text-align:left">servlet3</td>
</tr>
<tr>
<td style="text-align:left">*.bop</td>
<td style="text-align:left">servlet4</td>
</tr>
</tbody>
</table>
<p><strong>实际请求映射的结果</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">去掉上下文路径后的剩余路径</th>
<th style="text-align:left">对应的Servlet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/foo/bar/index.html</td>
<td style="text-align:left">servlet1</td>
</tr>
<tr>
<td style="text-align:left">/foo/bar/index.bop</td>
<td style="text-align:left">servlet1</td>
</tr>
<tr>
<td style="text-align:left">/baz</td>
<td style="text-align:left">servlet2</td>
</tr>
<tr>
<td style="text-align:left">/baz/index.html</td>
<td style="text-align:left">servlet2</td>
</tr>
<tr>
<td style="text-align:left">/catalog</td>
<td style="text-align:left">servlet3</td>
</tr>
<tr>
<td style="text-align:left">/catalog/index.html</td>
<td style="text-align:left">默认的servlet</td>
</tr>
<tr>
<td style="text-align:left">/catalog/racecar.bop</td>
<td style="text-align:left">servlet4</td>
</tr>
<tr>
<td style="text-align:left">/index.bop</td>
<td style="text-align:left">servlet4</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：在/catalog/index.html和/catalog/racecar.bop的情况下，由于不是精确匹配，不使用映射到“/catalog”的servlet。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1465962194_b465e14b8f728b101b62101288a7e652" target="_blank" rel="external">Java Servlet Specification(Version 3.0)</a></li>
<li><a href="http://item.jd.com/10066883.html" target="_blank" rel="external">Servlet JSP深入详解：基于Tomcat的Web开发</a></li>
<li><a href="http://item.jd.com/10480831.html" target="_blank" rel="external">O’Reilly：Head First Servlets and JSP（第2版）</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之进程和线程]]></title>
      <url>http://gongchuangsu.com/2016/06/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/E5QmOkV.jpg" alt=""></p>
<a id="more"></a>
<blockquote>
<p>进程(process)是计算机中的程序关于某数据集合上的一次运行活动，<strong>是系统进行资源分配和调度的基本单位</strong>，是操作系统结构的基础。</p>
<p>线程(thread)<strong>是操作系统能够进行运算调度的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。</p>
</blockquote>
<ol>
<li>同一进程中的多条线程将共享该进程中的全部系统资源，同时它们有各自的调用栈、寄存器环境和线程本地存储，但是没有单独的地址空间。</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程执行开销小，但不利于资源的管理和保护，而进程正好相反。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之垃圾回收(GC)]]></title>
      <url>http://gongchuangsu.com/2016/05/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(GC)/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/O9BBB0h.png" alt=""></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Java语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源管理，而在C++语言中，开发人员需要通过<code>malloc/free</code> 和<code>new/delete</code>等函数来显式的分配和释放内存，这对开发人员提出了比较高的要求，容易造成内存访问错误和内存泄露等问题。当然，java也有可能出现内存泄漏现象，但是发生的概率很小。<br>Java垃圾回收器负责完成三件任务：</p>
<ul>
<li>分配内存</li>
<li>确保被引用的对象的内存不被错误回收</li>
<li>回收不再被引用的对象的内存空间</li>
</ul>
<p>很显然，Java垃圾回收与Java内存有很大的关联，在讲解垃圾回收之前有必要介绍Java虚拟机(JVM)体系结构。</p>
<h2 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h2><p>JVM是一个抽象的计算机结构。JVM针对特定于操作系统并且可以将Java指令翻译成底层系统的指令并执行。同时，JVM确保了Java的平台无关性。<br>在JVM体系结构中，与垃圾回收相关的两个主要组件有堆内存和垃圾回收器。<br>堆内存是内存数据区，用来保存运行时的对象实例。垃圾回收器也是在这里操作的。<br>值得注意的是，每种JVM可能采用不同的方法实现垃圾回收机制。这里主要介绍<code>HotSpot JVM</code>的垃圾回收原则。JVM体系结构图如下所示：</p>
<p><img src="http://i.imgur.com/PF8gVQx.jpg" alt=""></p>
<h1 id="Java垃圾回收过程"><a href="#Java垃圾回收过程" class="headerlink" title="Java垃圾回收过程"></a>Java垃圾回收过程</h1><p>在运行时，Java的实例对象被存放在堆内存区域。当一个对象不再被引用时，满足回收的条件，就会被移出堆内存且内存空间会被回收。<br>Java堆内存(Heap Memory)结构图如下所示：</p>
<p><img src="http://i.imgur.com/GqtcK9C.png" alt=""></p>
<p>堆内存主要分为以下两个部分：</p>
<ul>
<li>新生代(Young Generation)<ul>
<li>Eden空间</li>
<li>Survivor S0空间 </li>
<li>Survivor S1空间</li>
</ul>
</li>
<li>老年代(Old Generation)</li>
</ul>
<blockquote>
<p>注意：在Java SE8特性中，永久代(Permanent Generation)被划分为非堆内存区(Non Heap Memory)。</p>
</blockquote>
<p>说明：</p>
<ol>
<li>Eden空间是内存分配的地方，它是一块连续的空间内存区域。由于不需要进行可用内存块的查找，故其内存分配速度非常快。任何实例对象都是通过Eden空间进入运行时内存区域的。</li>
<li>为什么会有两个Survivor空间？这两个Survivor空间是新生代与老年代的缓冲区域。当第一次触发<code>Minor GC</code>后，Eden中存活的对象将被移动到S0中，此时Eden为空。当第二次触发<code>Minor GC</code>后，S0和Eden中存活的对象被移动到S1，此时S0和Eden被清空。若再次触发<code>Minor GC</code>后，S1和Eden中存活的对象被移动到S0，此时S1和Eden被清空。总之，轮流移动，S0和S1在移动时至少有一个是空闲的。</li>
<li>何时新生代中存活的对象会移至老年代？每次触发<code>Minor GC</code>，计数器会统计触发的次数。默认情况下，如果触发的次数超过16次，就将新生代中存活的对象移至老年代中。</li>
<li>就Java垃圾回收过程，老年代是实例生命周期的最后阶段。<code>Major GC</code>扫描老年代的垃圾回收过程，如果实例不在引用，那么就会被标记回收，否则会继续留在老年代。</li>
<li>除了堆内存区域用来存放存活(living)的数据，JVM 还需要尤其是类描述、元数据等更多信息。所以这些信息统一被存放在命名为Permanent generation(永久/常驻代)的区域。</li>
</ol>
<blockquote>
<p>内存碎片：一旦实例对象从堆中被删除，其位置就会空余出来用于未来实例的分配。而这些空出的空间将会使整个内存区域碎片化。为了实例的快速分配，需要进行碎片整理。基于垃圾回收器的不同选择，回收的内存区域要么被不停地被整理，要么在一个单独的GC进程中完成。</p>
</blockquote>
<p>待续…</p>
<blockquote>
<p>参考资料：<br>1.<a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/" target="_blank" rel="external">JVM 垃圾回收器工作原理及使用实例介绍</a><br>2.<a href="http://javarevisited.blogspot.jp/2011/04/garbage-collection-in-java.html#more" target="_blank" rel="external">How Garbage Collection works in Java</a><br>3.<a href="http://www.infoq.com/cn/articles/cf-java-garbage-references" target="_blank" rel="external">Java深度历险（四）——Java垃圾回收机制与引用类型</a><br>4.<a href="http://www.importnew.com/13504.html" target="_blank" rel="external">Java GC系列</a><br>5.<a href="http://blog.csdn.net/ol_beta/article/details/6791229" target="_blank" rel="external">JVM 垃圾回收算法</a><br>6.<a href="http://286.iteye.com/blog/1931174" target="_blank" rel="external">Java 堆内存(Heap)</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之对象和对象引用]]></title>
      <url>http://gongchuangsu.com/2016/05/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/OZolVEN.jpg" alt=""></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>对象：</p>
<blockquote>
<p>《Java编程思想》：按照通俗的说法，每个对象都是某个类（class）的一个实例（instance）。</p>
</blockquote>
<p>引用：</p>
<blockquote>
<p>《Java编程思想》： 每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。</p>
</blockquote>
<p>上面两段是摘自《Java编程思想》中的两段话，下面我们通过例子进行进一步说明。<br>先定义一个简单类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这个类，我们可以创建对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People tom = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure></p>
<p>通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作。</p>
<ol>
<li>右边的“new People”，是以People类为模板，在堆空间里创建一个People类对象（也简称为People对象）</li>
<li>末尾的()意味着，在对象创建后，立即调用People类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数</li>
<li>左边的“People tom”创建了一个People类引用变量。所谓People类引用，就是以后可以用来指向People对象的对象引用，存储于堆栈中</li>
<li>“=”操作符使对象引用指向刚创建的那个People对象</li>
</ol>
<p>我们可以把这条语句拆成两部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People tom;</span><br><span class="line">tom = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure></p>
<p>这样就很清楚的看出，有两个实体：一是对象引用变量，二是对象本身。<br>在堆中创建的实体，与在数据段及栈空间里创建的实体不同，尽管它们是实实在在存在的实体，但是我们看不见摸不着。因为其没有具体的名字，一般都是通过对象引用指向某个对象，从而进行操作。<br>为了形象的说明对象与对象引用之间的关系，我们可以将对象比作一只气球，而把对象引用比作是一根绳子；一根绳子可以不系气球，也可以系一个气球；一个气球也可以有多个绳子系住<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People tony;</span><br></pre></td></tr></table></figure></p>
<p>上句定义了一个对象引用，但没有指向任何对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tony = tom;</span><br></pre></td></tr></table></figure></p>
<p>上句进行了一次对象引用的复制，而不是对象的复制，结果使得<code>tony</code>和<code>tom</code>指向同一对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tony = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure></p>
<p>上句代码使得<code>tony</code>这个对象引用重新指向另外一个新的对象。<br>也就是说，<br>（1）一个对象引用可以指向0个或1个对象；<br>（2）一个对象可以有N个引用指向它<br>当然还有一种特殊情况，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure></p>
<p>该对象没有任何对象引用指向它，这样的对象已成为垃圾回收器处理的对象，至于什么时候被回收，具体就要看垃圾回收器了。</p>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>把对象和对象引用搞清楚之后，我们再继续下一个比较有意思的话题。前面讲了那么多基础知识，都是为了这个话题准备的 —— 参数传值。</p>
<blockquote>
<p>《thinking in Java》：When you’re passing primitives into a method，you get a distinct copy of the primitive. When you’re passing a reference into a method, you get a copy of the reference.</p>
</blockquote>
<p>搞懂这段话，有关参数传递的疑惑将不是问题。<br>在讨论这个话题之前，我们先摆出以下几个事实：</p>
<ul>
<li>在 Java 中永远不会传递对象，而只传递对象引用</li>
<li>Java 有且仅有一种参数传递机制，即按值传递</li>
</ul>
<p><strong>什么是按值传递？</strong></p>
<blockquote>
<p>当将一个参数传递给一个函数时，函数接收的是原始值的一个副本。如果函数修改了该参数，仅改变副本，而原始值保持不变。如果函数修改了该参数，调用代码中的原始值也随之改变。</p>
</blockquote>
<p><strong>什么是按引用传递？</strong></p>
<blockquote>
<p>当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本</p>
</blockquote>
<p><strong>C++和Java中的参数传递有什么异同？</strong></p>
<blockquote>
<p>在 C++ 和 Java 中，当传递给函数的参数不是引用时，传递的都是该值的一个副本（按值传递）。区别在于引用：在 C++ 中当传递给函数的参数是引用时，您传递的就是这个引用，或者内存地址（按引用传递）。在 Java 应用程序中，当对象引用是传递给方法的一个参数时，您传递的是该引用的一个副本（按值传递），而不是引用本身。请注意，调用方法的对象引用和副本都指向同一个对象。这是一个重要区别。Java 应用程序在传递不同类型的参数时，其作法与 C++ 并无不同。Java 应用程序按值传递所有参数，这样就制作所有参数的副本，而不管它们的类型。</p>
</blockquote>
<p>我们通过以下实例进行讲解(源自<a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external">对象和引用</a>)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">value</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		dataType type = <span class="keyword">new</span> dataType();</span><br><span class="line">		type.first();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		value v = <span class="keyword">new</span> value();</span><br><span class="line">		v.i = <span class="number">25</span>;</span><br><span class="line">		second(v, i);</span><br><span class="line">		System.out.println(v.i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(value v, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		v.i = <span class="number">20</span>;</span><br><span class="line">		value val = <span class="keyword">new</span> value();</span><br><span class="line">		v = val;</span><br><span class="line">		System.out.println(v.i + <span class="string">" "</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（1）在first内，首先程序在栈内存中开辟了一块地址编号为AD9500内存空间，用于存放<code>v</code>的引用地址，里边放的值是堆内存中的一个地址，示例中的值为BE2500<br><img src="http://i.imgur.com/hdaNIZG.png" alt=""><br>（2）调用函数second，程序在栈内开辟地址为AD9600内存空间存放v的副本，v的副本同样指向堆地址为BE2500的空间，然后将v的副本传入second，并且在second内，将v的副本所指对象<code>i=25</code>改为<code>i=20</code><br><img src="http://i.imgur.com/r32SH9P.png" alt=""><br>（3）在second内，程序新建一个对象放在地址为BE2600的堆内，并用新的引用val（栈中地址为AD9700）指向它，所以second中输出结果为：<code>15 0</code><br><img src="http://i.imgur.com/r85YLx7.png" alt=""><br>（4）但原<code>v</code>并未改变，改变的只是它传入second的副本，所以在first中仍然输出<code>i=20</code></p>
<h1 id="String类型和包装器类型的参数传递问题"><a href="#String类型和包装器类型的参数传递问题" class="headerlink" title="String类型和包装器类型的参数传递问题"></a>String类型和包装器类型的参数传递问题</h1><blockquote>
<p>String对象是不可变的。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值，因此，也就不会对其他的引用有什么影响。</p>
</blockquote>
<p>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringAsParamOfMethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">		StringAsParamOfMethodDemo demo = <span class="keyword">new</span> StringAsParamOfMethodDemo();</span><br><span class="line">		demo.test();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String originStr = <span class="string">"origin"</span>;</span><br><span class="line">		System.out.println(<span class="string">"Before change:"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Outter String:"</span> + originStr);</span><br><span class="line">		changeString(originStr);</span><br><span class="line">		System.out.println(<span class="string">"After change:"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Outter String:"</span> + originStr);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeString</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		str = str + <span class="string">"is changed"</span>;</span><br><span class="line">		System.out.println(<span class="string">"Inner String:"</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before change:</span><br><span class="line">Outter String:origin</span><br><span class="line">Inner String:originis changed</span><br><span class="line">After change:</span><br><span class="line">Outter String:origin</span><br></pre></td></tr></table></figure></p>
<p>从运行结果上看，String对象引用作为参数传递时，虽然复制了其引用并赋值给新引用，但对新引用的更改并没有影响到原引用，这表现出了String类型的“非对象特性”。归根到底，对String的存储实际上是通过char[]来实现的，即String相当于是char[]的包装类。<strong>包装类的特质之一就是对其值进行操作时会体现出其对应的基本类型的性质。</strong>下面再举一个包装器类的例子进行解释。</p>
<blockquote>
<p>《Java编程思想》:基本类型具有的包装器类，使得可以在堆中创建一个<strong>非基本对象</strong>，用来表示对应的基本类型。</p>
</blockquote>
<p><img src="http://i.imgur.com/iirF5Nl.png" alt=""></p>
<p>包装器类型对象跟传统java对象有着细微的差别，导致其作为参数传递时跟一般对象会不一样。<br>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAsParamOfMethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">		IntegerAsParamOfMethodDemo demo = <span class="keyword">new</span> IntegerAsParamOfMethodDemo();</span><br><span class="line">		demo.test();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Integer a = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before change:"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Outter Integer:"</span> + a);</span><br><span class="line">		changeInteger(a);</span><br><span class="line">		System.out.println(<span class="string">"After change:"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Outter Integer:"</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeInteger</span><span class="params">(Integer a)</span></span>&#123;</span><br><span class="line">		a = <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">"Inner Integer:"</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before change:</span><br><span class="line">Outter Integer:<span class="number">1</span></span><br><span class="line">Inner Integer:<span class="number">2</span></span><br><span class="line">After change:</span><br><span class="line">Outter Integer:<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>从运行结果上来看，包装类对象引用在作为函数参数传递时表现出对应的基本类型的性质。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.163.com/luyufen_luise/blog/static/5777392520086230367627" target="_blank" rel="external">对象引用与对象的区别</a> </li>
<li><a href="https://www.ibm.com/developerworks/cn/java/passbyval/" target="_blank" rel="external">Java 应用程序中的按值传递语义</a></li>
<li><a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external">对象和引用</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/04/01/2992484.html" target="_blank" rel="external">Java基础11 对象引用</a></li>
<li><a href="http://freej.blog.51cto.com/235241/168676" target="_blank" rel="external">String类型的参数传递问题</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之自动装箱与拆箱]]></title>
      <url>http://gongchuangsu.com/2016/05/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/YNdUwnT.png" alt=""></p>
<a id="more"></a>
<h1 id="什么是自动装箱与拆箱"><a href="#什么是自动装箱与拆箱" class="headerlink" title="什么是自动装箱与拆箱"></a>什么是自动装箱与拆箱</h1><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。<br>自动装箱时<strong>编译器</strong>调用<code>valueOf()</code>将原始类型值转换成对象；自动拆箱时，编译器通过调用类似<code>xxxValue()</code>这类方法(如<code>intValue()</code>,<code>doubleValue()</code>)将对象转换成原始类型值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">原始类型(Primitive Types)</th>
<th style="text-align:left">引用型(包装类)(Reference Types(Wrapper Class))</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">Short</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">Character</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">Long</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">Double</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Boolean</td>
</tr>
</tbody>
</table>
<h1 id="什么情况下会发生自动装箱和拆箱"><a href="#什么情况下会发生自动装箱和拆箱" class="headerlink" title="什么情况下会发生自动装箱和拆箱"></a>什么情况下会发生自动装箱和拆箱</h1><h2 id="赋值时"><a href="#赋值时" class="headerlink" title="赋值时"></a>赋值时</h2><p>在Java1.5之前，需要手动地进行类型转换，而现在所有的转换都是有编译器来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line">Integer iObject = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject.intValue()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line">Integer iObject = <span class="number">3</span>;      <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure></p>
<h2 id="方法调用时"><a href="#方法调用时" class="headerlink" title="方法调用时"></a>方法调用时</h2><p>当在进行方法调用时，可以传入原始数据值或对象，编译器同样会自动进行转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">show</span><span class="params">(Integer iParam)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"autoboxing example - method invocation i: "</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="keyword">int</span> result = show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure></p>
<h1 id="自动装箱引起的性能问题"><a href="#自动装箱引起的性能问题" class="headerlink" title="自动装箱引起的性能问题"></a>自动装箱引起的性能问题</h1><p>如果有人告诉你：“只要修改一个字符，下面这段代码的运行速度就能提高5倍。”，你觉得可能么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">Long sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"total:"</span> + sum);</span><br><span class="line">System.out.println(<span class="string">"processing time: "</span> + (System.currentTimeMillis() - t) + <span class="string">" ms"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total:<span class="number">2305843005992468481</span></span><br><span class="line">processing time: <span class="number">63556</span> ms</span><br></pre></td></tr></table></figure></p>
<p>将<code>Long</code>修改为<code>long</code>，再来看一下运行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"total:"</span> + sum);</span><br><span class="line">System.out.println(<span class="string">"processing time: "</span> + (System.currentTimeMillis() - t) + <span class="string">" ms"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total:<span class="number">2305843005992468481</span></span><br><span class="line">processing time: <span class="number">12229</span> ms</span><br></pre></td></tr></table></figure></p>
<p>事实证明，仅仅修改了一个字符，性能提高了不止一倍两倍。那，就究竟是什么原因导致的呢？<br>因为，<code>+</code>这个操作符不适用<code>Integer</code>对象，在进行数值相加操作之前会发生自动拆箱操作，转换成<code>int</code>，相加之后还会发生自动拆箱操作，装换成<code>Integer</code>对象。其内部变化如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = sum.longValue() + i;</span><br><span class="line">Long sum = <span class="keyword">new</span> Long(sum);</span><br></pre></td></tr></table></figure></p>
<p>很明显，在上面的循环中会创建2147483647个”Long“类型实例，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。</p>
<blockquote>
<p>说明：包含在包装器中的内容不会改变。即<code>Long</code>对象是不可变的。</p>
</blockquote>
<h1 id="重载与自动装箱"><a href="#重载与自动装箱" class="headerlink" title="重载与自动装箱"></a>重载与自动装箱</h1><p>在java 5之前，<code>value(int)</code>和<code>value(Integer)</code>是完全不相同的方法，开发者不会因为传入是<code>int</code>还是<code>Integer</code>调用哪个方法困惑，但是由于自动装箱和拆箱的引入，处理重载方法时会不会有什么变化呢？可通过下面一个例子进行探讨：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"method with primitive argument"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Integer num)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"method with wrapper argument"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//calling overloaded method</span></span><br><span class="line">AutoboxingTest autoTest = <span class="keyword">new</span> AutoboxingTest();</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">autoTest.test(value);  <span class="comment">//no autoboxing </span></span><br><span class="line">Integer iValue = value;</span><br><span class="line">autoTest.test(iValue); <span class="comment">//no autoboxing</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Output:</span><br><span class="line">method with primitive argument</span><br><span class="line">method with wrapper argument</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从输出结果可以看出，在重载的情况下，不会发生自动装箱操作。(有关重载和重写的基础知识可参考<a href="http://gongchuangsu.com/2016/05/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%87%8D%E5%86%99%28Overriding%29%E4%B8%8E%E9%87%8D%E8%BD%BD%28Overloading%29/">Java学习笔记之重写(Overriding)与重载(Overloading)</a>)</p>
<h1 id="在Java中使用自动装箱与拆箱应当注意的问题"><a href="#在Java中使用自动装箱与拆箱应当注意的问题" class="headerlink" title="在Java中使用自动装箱与拆箱应当注意的问题"></a>在Java中使用自动装箱与拆箱应当注意的问题</h1><p>自动装箱与拆箱在编程过程中给我们带来了极大的方便，但也存在一些容易让人出错的问题。</p>
<h2 id="对象相等比较"><a href="#对象相等比较" class="headerlink" title="对象相等比较"></a>对象相等比较</h2><p><code>&quot;==&quot;</code>既可用于原始值的比较，也可用于对象间的比较。当进行对象间的比较时，实质上比较的是对象的引用是否相等，而不是比较对象代表的值。如果要比较对象的值，应当使用对象对应的<code>equals</code>方法。可通过以下例子进行探讨：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example 1: == comparison pure primitive – no autoboxing</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"i1==i2 : "</span> + (i1 == i2)); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Example 2: equality operator mixing object and primitive</span></span><br><span class="line">        Integer num1 = <span class="number">1</span>; <span class="comment">// autoboxing</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"num1 == num2 : "</span> + (num1 == num2)); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Example 3: special case - arises due to autoboxing in Java</span></span><br><span class="line">        Integer obj1 = <span class="number">1</span>; <span class="comment">// autoboxing will call Integer.valueOf()</span></span><br><span class="line">        Integer obj2 = <span class="number">1</span>; <span class="comment">// same call to Integer.valueOf() will return same cached Object</span></span><br><span class="line">        System.out.println(<span class="string">"obj1 == obj2 : "</span> + (obj1 == obj2)); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Example 4: equality operator - pure object comparison</span></span><br><span class="line">        Integer one = <span class="keyword">new</span> Integer(<span class="number">1</span>); <span class="comment">// no autoboxing</span></span><br><span class="line">        Integer anotherOne = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"one == anotherOne : "</span> + (one == anotherOne)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Output:</span><br><span class="line">i1==i2 : true</span><br><span class="line">num1 == num2 : true</span><br><span class="line">obj1 == obj2 : true</span><br><span class="line">one == anotherOne : false</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，在<code>Example 2</code>中，比较是一个对象和一个原始值，出现这种情况比较的应该是对象的值。<br>让人感到困惑的<code>Example 3</code>，在一开始我们说过，<code>&quot;==&quot;</code>用于对象间的比较时，比较的是它们的引用，那么为什么<code>obj1 == obj2</code>返回的结果却是<code>true</code>？<strong>这是一种极端情况，处于节省内存的考虑，<code>JVM</code>会缓存<code>-128</code>到<code>127</code>的<code>Integer</code>对象。</strong>也就是说，在创建<code>obj1</code>对象时，会进行自动装箱操作，并且将其对象保存至缓存中，在创建<code>obj2</code>对象时，同样会进行自动装箱操作，然后在缓存中查找是否有相同值的对象，如果有，那么<code>obj2</code>对象就会指向<code>obj1</code>对象。<code>obj1</code>和<code>obj2</code>实际上是同一个对象。所以使用<code>&quot;==&quot;</code>比较返回<code>true</code>。<br>而<code>Example 4</code>，是通过使用构造器来创建对象的，而没有发生自动装箱操作，不会执行缓存策略，故<code>one</code>和<code>anotherOne</code>是指向不同的引用的。</p>
<blockquote>
<p>说明：这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。</p>
</blockquote>
<h2 id="容易混乱的对象和原始数据值"><a href="#容易混乱的对象和原始数据值" class="headerlink" title="容易混乱的对象和原始数据值"></a>容易混乱的对象和原始数据值</h2><p>一个很容易犯错的问题，就是忽略对象与原始数据值之间的差异，在进行比较操作时，对象如果没有初始化或者为<code>null</code>，在自动拆箱过程中<code>obj.xxxValue</code>，则会抛出<code>NullPointerException</code>，可通过以下例子进行探讨：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer count;</span><br><span class="line"><span class="comment">//NullPointerException on unboxing</span></span><br><span class="line"><span class="keyword">if</span>( count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"Count is not started yet"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生成无用对象增加GC压力"><a href="#生成无用对象增加GC压力" class="headerlink" title="生成无用对象增加GC压力"></a>生成无用对象增加GC压力</h2><p>因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。</p>
<p><strong>参考资料</strong>：<br>1.<a href="http://javarevisited.blogspot.com/2012/07/auto-boxing-and-unboxing-in-java-be.html" target="_blank" rel="external">What is Autoboxing and Unboxing in Java</a><br>2.<a href="http://javapapers.com/java/java-integer-cache/" target="_blank" rel="external">Java Integer Cache</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解关键字null]]></title>
      <url>http://gongchuangsu.com/2016/05/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E5%AD%97null/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/WeynCnL.jpg" alt=""></p>
<a id="more"></a>
<h1 id="关键字null"><a href="#关键字null" class="headerlink" title="关键字null"></a>关键字null</h1><p><code>跟public</code>、<code>static</code>、<code>final</code>一样，<code>null</code>也是java的关键字(更多关键字可以参考<a href="http://gongchuangsu.com/2016/03/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Java学习笔记之基本语法</a>)。不能将<code>null</code>写成<code>Null</code>或<code>NULL</code>，编译器将会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = NULL;  <span class="comment">// Not Ok</span></span><br><span class="line">Object obj1 = Null; <span class="comment">// Not Ok</span></span><br><span class="line">Object obj2 = <span class="keyword">null</span>;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure></p>
<h1 id="null作为默认值"><a href="#null作为默认值" class="headerlink" title="null作为默认值"></a>null作为默认值</h1><p><code>null</code>是任何引用类型的默认值，但不能作为基本类型变量的默认值。如<code>int</code>的默认值为<code>0</code>,<code>boolean</code>的默认值为<code>false</code>(更多信息可参考<a href="http://gongchuangsu.com/2016/03/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Java学习笔记之基本数据类型</a>)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i;     <span class="comment">// 基本类型变量int，默认值为0</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">boolean</span> j; <span class="comment">// 基本类型变量boolean，默认值为false</span></span><br><span class="line">	<span class="keyword">static</span> Object o;  <span class="comment">// 引用类型变量，默认值为null</span></span><br><span class="line">	<span class="keyword">static</span> Test test; <span class="comment">// 引用类型变量，默认值为null</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	  System.out.println(i);</span><br><span class="line">	  System.out.println(j);</span><br><span class="line">	  System.out.println(o);</span><br><span class="line">	  System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** output</span><br><span class="line">0</span><br><span class="line">false</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h1 id="null能转换成任何类型"><a href="#null能转换成任何类型" class="headerlink" title="null能转换成任何类型"></a>null能转换成任何类型</h1><p>null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;  <span class="comment">// null can be assigned to String</span></span><br><span class="line">Integer itr = <span class="keyword">null</span>; <span class="comment">// you can assign null to Integer also</span></span><br><span class="line">Double dbl = <span class="keyword">null</span>;  <span class="comment">// null can also be assigned to Double</span></span><br><span class="line"> </span><br><span class="line">String myStr = (String) <span class="keyword">null</span>;   <span class="comment">// null can be type cast to String</span></span><br><span class="line">Integer myItr = (Integer) <span class="keyword">null</span>; <span class="comment">// it can also be type casted to Integer</span></span><br><span class="line">Double myDbl = (Double) <span class="keyword">null</span>;   <span class="comment">// yes it's possible, no error</span></span><br></pre></td></tr></table></figure></p>
<h1 id="空指针异常-NPE"><a href="#空指针异常-NPE" class="headerlink" title="空指针异常(NPE)"></a>空指针异常(NPE)</h1><ol>
<li><p><strong>任何含有<code>null</code>值的包装类在Java拆箱生成基本数据类型时候都会抛出一个空指针异常</strong><br><code>null</code>是不能直接赋值给基本类型的，如果这样做，则会出现编译错误；而如果将<code>null</code>赋值给包装类<code>object</code>，然后将<code>object</code>赋给各自的基本类型，编译器不会报，但将会在运行时期遇到空指针异常。<br>这是由于java中的自动拆箱导致的，因为自动拆箱不会将<code>null</code>转换成各自基本类型的默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">null</span>;       <span class="comment">// type mismatch : cannot convert from null to int</span></span><br><span class="line">Integer itr = <span class="keyword">null</span>; <span class="comment">// this is ok</span></span><br><span class="line"><span class="keyword">int</span> j = itr;        <span class="comment">// this is also ok, but NullPointerException at runtime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从已知的String对象中调用equals()和equalsIgnoreCase()方法，而非未知对象</strong><br>由于<code>equals()</code>方法是对称的，调用<code>a.equals(b)</code>和调用<code>b.equals(a)</code>是完全相同的，导致一些程序员忽略了a,b为空时的情况。如果调用者是空指针，这种调用可能导致一个空指针异常</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object unknownObject = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//错误方式 – 可能导致 NullPointerException</span></span><br><span class="line"><span class="keyword">if</span>(unknownObject.equals(<span class="string">"knownObject"</span>))&#123;</span><br><span class="line">   System.err.println(<span class="string">"This may result in NullPointerException if unknownObject is null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//正确方式 - 即便 unknownObject是null也能避免NullPointerException</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"knownObject"</span>.equals(unknownObject))&#123;</span><br><span class="line">    System.err.println(<span class="string">"better coding avoided NullPointerException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当valueOf()和toString()返回相同的结果时，宁愿使用前者</strong><br>由于调用<code>null</code>对象的<code>toString()</code>会抛出空指针异常，而传递一个<code>null</code>给<code>valueOf()</code>将会返回<code>“null”</code>，尤其是在那些包装类，像<code>Integer</code>、<code>Float</code>、<code>Double</code>和<code>BigDecimal</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Integer it;</span><br><span class="line">System.out.println(String.valueOf(it)); <span class="comment">//不会抛出空指针异常</span></span><br><span class="line">System.out.println(it.toString()); <span class="comment">//抛出 "Exception in thread "main" java.lang.NullPointerException"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="比较null值"><a href="#比较null值" class="headerlink" title="比较null值"></a>比较null值</h1><p>除了可以使用<code>==</code>或者<code>！=</code>操作来比较<code>null</code>值，不能使用其他的算法或逻辑进行比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">       String abc = <span class="keyword">null</span>;</span><br><span class="line">       String cde = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(abc == cde)&#123;</span><br><span class="line">           System.out.println(<span class="string">"null == null is true in Java"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">null</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">"null != null is false in Java"</span>); </span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// classical null check</span></span><br><span class="line">       <span class="keyword">if</span>(abc == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// not ok, compile time error</span></span><br><span class="line">       <span class="keyword">if</span>(abc &gt; <span class="keyword">null</span>)&#123;</span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**output</span><br><span class="line">null == null is true in Java</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h1 id="空串与null串"><a href="#空串与null串" class="headerlink" title="空串与null串"></a>空串与null串</h1><p>空串””是长度为0的字符串。<br>可以调用以下代码进行检查一个字符串是否为空：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">""</span>))</span><br></pre></td></tr></table></figure></p>
<p>空串是一个java对象，有自己的串长度(0)和内容(空)。<br>null串表示一个特殊的String变量，它表示目前没有任何对象与该变量关联。<br>可以调用以下代码进行检查一个字符串是否为null：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果将一个方法应用于一个值为null的对象上，就会产生运行错误，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer ite = <span class="keyword">null</span>;</span><br><span class="line">String str = ite.toString(); <span class="comment">// 空指针异常</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解关键字super]]></title>
      <url>http://gongchuangsu.com/2016/05/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E5%AD%97super/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/U8GmwAN.png" alt=""></p>
<h1 id="为什么需要super"><a href="#为什么需要super" class="headerlink" title="为什么需要super"></a>为什么需要super</h1><p>考虑这样一个情景，当一个类继承自另一个类，并重写了父类的一个方法，并且想在这个方法中调用父类的这个方法，该如何做呢？当然，我们不能直接调用该方法，因为它会产生递归。这时，我们就需要通过<code>super.方法名</code>来访问父类的该方法。<br>当然，super的存在不仅仅如此。我们知道，当创建一个导出类(即通过继承而来)的对象时，该对象会包含一个基类的子对象。这就需要我们正确的对基类子对象进行初始化。如何正确的基类子对象进行初始化呢？这时，super就派上用场了。当基类构造器不带有参数，Java会自动在导出类的构造器中插入对基类构造器的调用(即隐式的使用了super()),而不需手动编写。但如果基类构造器是带有参数的，那就必须得手动编写，显式的插入带有相应参数的<code>super(参数列表)</code>方法，而且，值得注意的是，必须将该方法放在导出类构造器的第一行。<br>super还有另外一个用处，就是可以通过它来访问基类中被隐藏的成员变量(即被子类覆盖的成员变量，非private成员变量)，引用格式：<code>super.成员变量名</code></p>
<h1 id="如何使用super"><a href="#如何使用super" class="headerlink" title="如何使用super"></a>如何使用super</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gongchuangsu.reusing;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String s1 = <span class="string">"str_1 in Animal"</span>;</span><br><span class="line">	<span class="keyword">public</span> String s2 = <span class="string">"str_2 in Animal"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Animal"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"Animal say..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String s1 = <span class="string">"str_1 in Dog"</span>;</span><br><span class="line">	<span class="keyword">public</span> String s2 = <span class="string">"str_2 in Dog"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(i);</span><br><span class="line">		System.out.println(<span class="string">"Dog"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"Dog say..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teddy</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String s1 = <span class="string">"str_1 in Teddy"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teddy</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(i);  <span class="comment">// 调用父类带参构造函数完成父类初始化，其必须放在第一行</span></span><br><span class="line">		System.out.println(<span class="string">"Teddy"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line">		System.out.println(s1);             <span class="comment">// 访问所在类的成员变量</span></span><br><span class="line">		System.out.println(s2);             <span class="comment">// 访问父类的成员变量</span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.s1);       <span class="comment">// 访问父类被隐藏的成员变量，即被子类覆盖的成员变量</span></span><br><span class="line">		System.out.println(<span class="string">"Teddy say..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Teddy teddy = <span class="keyword">new</span> Teddy(<span class="number">0</span>);</span><br><span class="line">		teddy.f();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span><br><span class="line">Animal</span><br><span class="line">Dog</span><br><span class="line">Teddy</span><br><span class="line">str_1 in Teddy</span><br><span class="line">str_2 in Dog</span><br><span class="line">str_1 in Dog</span><br><span class="line">Teddy say...</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Java编程思想</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解关键字final]]></title>
      <url>http://gongchuangsu.com/2016/05/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E5%AD%97final/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/JltG2Nn.png" alt=""></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>final是Java中是一个保留的关键字，可以声明变量(包括成员变量[实例变量和静态变量]和局部变量)、方法和类。它通常指“这是无法改变的”。将变量、方法和类声明为final，JVM能够对其进行优化，进而提升性能。<br>其关键知识点如下：</p>
<ul>
<li>final方法是在编译器绑定的，即静态绑定(可参考<a href="http://gongchuangsu.com/2016/05/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/">Java学习笔记之深入理解动态绑定和静态绑定</a>)</li>
<li>final<strong>成员变量</strong>必须在声明的时候初始化或者在构造器中初始化</li>
<li>final<strong>局部变量</strong>必须在使用前进行初始化赋值</li>
<li>当final变量是<strong>基本数据类型</strong>时，其数值恒定不变，且不能被更改；当final变量是<strong>引用类型</strong>时，其引用恒定不变，即不能再指向其它对象，但其引用指向的对象本身却是可以被修改的</li>
<li>final方法不能被重写</li>
<li>final类不能被继承</li>
<li>类中所有的private方法都隐式地指定为final</li>
</ul>
<h1 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h1><p>无论是成员变量(包括实例变量和静态变量)还是局部变量，只要声明为final，就必须在使用前进行初始化，否则在编译期时出现错误。值得注意的是，成员变量如果没有声明为final，那么在使用前是可以不用进行初始化的，因为它们有默认值。(可参考<a href="http://gongchuangsu.com/2016/03/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">Java学习笔记之变量类型</a>)<br>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalVarDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var;                <span class="comment">// It's OK！默认值为0</span></span><br><span class="line">    <span class="comment">//final int var_final;  // It's not OK! 必须在声明的时候初始化或者在构造器中初始化     </span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> var_instance  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="comment">//final int var_local;                   // It's not OK!局部变量在使用前必须进行初始化赋值</span></span><br><span class="line">    	<span class="keyword">final</span> <span class="keyword">int</span> var_local = <span class="number">1</span>; </span><br><span class="line">    	<span class="comment">//var_local = 2;                         // It's not OK!final局部变量值不能更改</span></span><br><span class="line">    	<span class="comment">//var_instance = 1;                 // It's not OK!final实例变量值不能被更改</span></span><br><span class="line">    	<span class="comment">//arrayList = new ArrayList&lt;&gt;(); // It's not OK!不能将final引用类型变量指向新的对象</span></span><br><span class="line">    	arrayList.add(<span class="string">"hello"</span>);          <span class="comment">// It's OK!可以改变对象本身</span></span><br><span class="line">    	arrayList.add(<span class="string">"world"</span>);</span><br><span class="line">    	</span><br><span class="line">	    System.out.println(<span class="string">"var = "</span>+var);</span><br><span class="line">	    System.out.println(<span class="string">"var_instance = "</span>+var_instance);</span><br><span class="line">		System.out.println(<span class="string">"var_local = "</span>+var_local);</span><br><span class="line">		System.out.println(<span class="string">"arrayList = "</span>+arrayList);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">		FinalVarDemo finalVarDemo = <span class="keyword">new</span> FinalVarDemo();</span><br><span class="line">		finalVarDemo.test();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">0</span></span><br><span class="line">var_instance = <span class="number">0</span></span><br><span class="line">var_local = <span class="number">1</span></span><br><span class="line">arrayList = [hello, world]</span><br></pre></td></tr></table></figure></p>
<h1 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h1><p>Java允许在参数列表中以声明的方法将参数指明为final。<br>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArg</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">withFinal</span><span class="params">(<span class="keyword">final</span> Dog dog)</span></span>&#123;</span><br><span class="line">		<span class="comment">//dog = new Dog(); // Illegal! --dog is final</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">withoutFinal</span><span class="params">(Dog dog)</span></span>&#123;</span><br><span class="line">		dog = <span class="keyword">new</span> Dog(); <span class="comment">// OK! --dog is not final</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="comment">//i++; // Illegal! --i is final,can't change</span></span><br><span class="line">		<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		i++;   <span class="comment">// OK! --i is not final</span></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>分析：将方法中的参数指定为final，意味着无法在方法中更改参数引用所指向的对象，如果是基本数据类型参数，不能改变其值，只能读取。这一特性，一般用来向匿名内部类传递数据。</p>
</blockquote>
<h1 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h1><p>方法前面加上final关键字，代表这个方法不可以被子类的方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。<br>例3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Animal.f()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Animal.g()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Dog.f()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Dog.g()"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teddy</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="comment">// It's not OK!final方法不能被覆盖</span></span><br><span class="line"><span class="comment">//	public final void f()&#123;</span></span><br><span class="line"><span class="comment">//		System.out.println("Teddy.f()");</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Teddy.g()"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalMethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Teddy teddy = <span class="keyword">new</span> Teddy();</span><br><span class="line">		teddy.f();</span><br><span class="line">		teddy.g();</span><br><span class="line">		Dog teddy1 = <span class="keyword">new</span> Teddy();</span><br><span class="line">		teddy1.f();</span><br><span class="line">		teddy1.g();</span><br><span class="line">		Animal teddy2 = <span class="keyword">new</span> Teddy();</span><br><span class="line"><span class="comment">//		teddy2.f(); // It's not OK!final方法不能被覆盖</span></span><br><span class="line"><span class="comment">//		teddy2.g();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog.f()</span><br><span class="line">Teddy.g()</span><br><span class="line">Dog.f()</span><br><span class="line">Teddy.g()</span><br></pre></td></tr></table></figure></p>
<p>结果分析：需要指明的是类中所有的private方法都隐式的指定为final。而final方法是不能被覆盖的。但从例3中的代码可以看出，覆盖一个private方法(隐含是final的)似乎是奏效的。类<code>Dog</code>继承于类<code>Animal</code>，并且覆盖了两个private方法，而且编译也没有出错。那么问题来了，谁说final方法是不能被覆盖的？一般来讲，重写方法使用的是动态绑定，如果类<code>Dog</code>真的是重写了类<code>Animal</code>中的两个private方法,那么输出应该是<code>Animal.f()</code>而不是<code>Dog.f()</code>，所以可以肯定的是，类<code>Dog</code>中的这两个方法并不是继承自类<code>Animal</code>，它只不过是具有相同的名称，仅此而已！当然，这说的是private方法，对于public final方法，如果你想要覆盖该方法，编译会出现错误提示，该方法不能被覆盖，正如例3中的代码写的一样。</p>
<h1 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h1><p>当将某个类定义为final时，表示该类不能被继承。final类通常功能是完整的。Java中有许多这样的类，如String,Interger以及其他包装类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compilation error: cannot inherit from final class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final, finally, finalize的区别"></a>final, finally, finalize的区别</h1><ul>
<li>final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承</li>
<li>finally 是异常处理语句结构的一部分，表示总是执行</li>
<li>finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用</li>
</ul>
<h1 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h1><p>1.当try和catch中有return时，finally将会怎样执行？其执行顺序是怎样的？<br>先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(beforeFinally());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beforeFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			a = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			a = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**output:</span><br><span class="line">1</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从结果上看，貌似<code>finally</code>里的语句是在<code>return</code>之后执行的，其实不然，实际上<code>finally</code>里的语句是在在<code>return</code>之前执行的。那么问题来了，既然是在之前执行，那为什么<code>a</code>的值没有被覆盖了？<br>实际过程是这样的：当程序执行到try{}语句中的return方法时，它会干这么一件事，将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的程序，<strong>在执行<code>a = 2</code>时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值</strong>。执行完之后，就会通知主程序“finally的程序执行完毕，可以请求返回了”，这时，就会将临时栈中的值取出来返回。这下应该清楚了，要返回的值是保存至临时栈中的。<br>再来看一个例子,稍微改下上面的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(beforeFinally());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beforeFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			a = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			a = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**output:</span><br><span class="line">2</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>在这里，finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，就会通知主程序请求返回了，即将临时栈中的值取出来返回。故返回值是2.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Java编程思想</li>
<li><a href="http://www.importnew.com/7553.html" target="_blank" rel="external">深入理解Java中的final关键字</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解关键字static]]></title>
      <url>http://gongchuangsu.com/2016/05/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E5%AD%97static/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/a2ylj3D.jpg" alt=""></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量这个概念。<br>在Java中，用static修饰的方法称为静态方法(类方法)，用static修饰的变量称为静态变量(类变量)。<br>为什么需要static关键字？可以通过以下两种情形进行思考</p>
<ul>
<li>情形一：只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。</li>
<li>情形二：希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也可以调用这个方法。</li>
</ul>
<p>一般情况下，执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。要想解决以上两种情形，通过new肯定是不行的，而通过static关键字就可以满足这两方面的需要。<br>static有以下几个特点：</p>
<ul>
<li>被static修饰的成员变量和成员方法独立于该类的任何对象。即不依赖于类特定的实例，被类的所有实例共享</li>
<li>static变量和方法可以直接通过类来访问，而无需创建任何对象</li>
<li>static方法是没有this的方法，即它不属于对象，而是属于类</li>
<li>在static方法内部不能访问非静态成员变量和非静态成员方法，因为非静态成员变量/方法是依赖于具体的对象，必须创建对象后才能使用(非绝对)</li>
<li>类的构造器实际上也是静态方法，只不过没有显示地声明</li>
</ul>
<h1 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h1><p>类成员变量可分为两类：静态变量和实例变量。静态变量不属于某个实例对象，而是属于类；而实例变量属于某个对象的属性。可通过以下代码进行理解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	  Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">	  System.out.println(a);</span><br><span class="line">	  <span class="comment">//System.out.println(b);       //It's not OK!   </span></span><br><span class="line">	  System.out.println(test1.b);   <span class="comment">//It's OK!</span></span><br><span class="line">	  </span><br><span class="line">	  Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">	  a = <span class="number">1</span>;</span><br><span class="line">	  test2.b = <span class="number">1</span>;</span><br><span class="line">	  System.out.println(a); </span><br><span class="line">	  System.out.println(test1.b);</span><br><span class="line">	  System.out.println(test2.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>具体区别可参考<a href="http://gongchuangsu.com/2016/03/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">Java学习笔记之变量类型</a>。</p>
<h1 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h1><p>静态方法可以直接通过类名调用，任何的实例也都可以调用。但在static方法内部不能访问非静态成员变量和非静态成员方法，因为非静态成员变量/方法是依赖于具体的对象，必须创建对象后才能使用。这种说法不是完全绝对的，因为：如果传递一个对象的引用到静态方法里，然后通过这个引用就可以调用非静态方法和访问非静态数据成员了。但通常要达到这样的效果，我们只需写一个非静态方法即可，而无需传递引用。可通过以下代码进行理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"staticDemo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//print(); // It's not OK!</span></span><br><span class="line">        staticDemo demo = <span class="keyword">new</span> staticDemo();</span><br><span class="line">        demo.print(); <span class="comment">// 在静态方法中调用非静态方法必须先创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNoStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：static方法不能被重写(Overriding)。因为重写是基于运行时动态绑定的，而static方法是基于编译期静态绑定的。虽然不能被重写，但可以在子类中再次被声明为static，且属于该子类。</p>
</blockquote>
<h1 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h1><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。<br>静态代码块可以用来优化程序性能，可通过以下程序进行理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date startDate = Date.valueOf(<span class="string">"1946"</span>);</span><br><span class="line">        Date endDate = Date.valueOf(<span class="string">"1964"</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">"1946"</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">"1964"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态代码块的执行顺序可根据以下代码进行理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>   </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">"A"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span><br><span class="line">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello World !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>   </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">"B"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span><br><span class="line">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> StaticCode().show();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">"C"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">Hello World !</span><br></pre></td></tr></table></figure></p>
<h1 id="static和final一起使用"><a href="#static和final一起使用" class="headerlink" title="static和final一起使用"></a>static和final一起使用</h1><ul>
<li>对于static final修饰的变量，表示一旦赋值就不可修改，并且可通过类名直接访问</li>
<li>对于static final修饰的方法，表示该方法不可覆盖，并且可通过类名直接调用</li>
</ul>
<blockquote>
<p>对于static final修饰的引用类型对象，特别是容器类型(如ArrayList、HashMap)，不可以改变容器对象本身(即不能改变将其引用指向其他对象)，但可以修改容器中存放的对象。</p>
</blockquote>
<p>可通过以下程序进行理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_STATIC_FINAL = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strStatic = <span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String strFinal = <span class="string">"c"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList &lt; String &gt; ARRAY_LIST = <span class="keyword">new</span> ArrayList &lt; String &gt; ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------值处理前----------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"STR_STATIC_FINAL = "</span> + STR_STATIC_FINAL);</span><br><span class="line">        System.out.println(<span class="string">"strStatic = "</span> + strStatic);</span><br><span class="line">        System.out.println(<span class="string">"strFinal = "</span> + strFinal);</span><br><span class="line">        System.out.println(<span class="string">"ARRAY_LIST = "</span> + ARRAY_LIST);</span><br><span class="line">        <span class="comment">// STR_STATIC_FINAL = "aa"; // It's not OK! final表示终态,不可以改变变量本身</span></span><br><span class="line">        strStatic = <span class="string">"bb"</span>; <span class="comment">// 可进行更改</span></span><br><span class="line">        <span class="comment">// strFinal = "cc"; // It's not OK! final表示终态,不可以改变变量本身</span></span><br><span class="line">        <span class="comment">// ARRAY_LIST = new ArrayList&lt;String&gt;(); // It's not OK! final表示终态,不可以将ARRAY_LIST引用指向其他对象</span></span><br><span class="line">        ARRAY_LIST.add(<span class="string">"d"</span>); <span class="comment">// 可以修改容器中存放的对象</span></span><br><span class="line">        System.out.println(<span class="string">"-------------值处理后----------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"STR_STATIC_FINAL = "</span> + STR_STATIC_FINAL);</span><br><span class="line">        System.out.println(<span class="string">"strStatic = "</span> + strStatic);</span><br><span class="line">        System.out.println(<span class="string">"strFinal = "</span> + strFinal);</span><br><span class="line">        System.out.println(<span class="string">"ARRAY_LIST = "</span> + ARRAY_LIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StaticFinalDemo().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------值处理前----------</span><br><span class="line">STR_STATIC_FINAL = a</span><br><span class="line">strStatic = b</span><br><span class="line">strFinal = c</span><br><span class="line">ARRAY_LIST = []</span><br><span class="line">-------------值处理后----------</span><br><span class="line">STR_STATIC_FINAL = a</span><br><span class="line">strStatic = bb</span><br><span class="line">strFinal = c</span><br><span class="line">ARRAY_LIST = [d]</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Java编程思想</li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="external">Java中的static关键字解析</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之深入理解动态绑定和静态绑定]]></title>
      <url>http://gongchuangsu.com/2016/05/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<center><br><img src="http://i.imgur.com/J4psG0d.jpg" alt=""><br></center>

<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>动态绑定和静态绑定是Java中两个重要的概念。首先思考这么一个问题，当一个类中存在方法名相同但参数不同(重载)的函数或同一类层次结构下同一名称的方法(重写)，程序在执行的时候该如何辨别区分呢？这里就需要用到Java中的动态绑定和静态绑定来解决。那么什么是动态绑定和静态绑定呢？</p>
<ul>
<li>绑定：指一个方法的调用与方法所在的类关联起来</li>
<li>静态绑定：方法在程序编译期进行绑定</li>
<li>动态绑定：方法在程序运行时根据具体对象的类型进行绑定</li>
</ul>
<hr>
<h1 id="静态绑定-VS-动态绑定"><a href="#静态绑定-VS-动态绑定" class="headerlink" title="静态绑定 VS 动态绑定"></a>静态绑定 VS 动态绑定</h1><ul>
<li>静态绑定发生在编译期(Compile time)，而动态绑定发生在运行时(Runtime)</li>
<li><code>private</code>, <code>final</code> and <code>static</code>方法和变量使用静态绑定，而虚函数(virtual methods)则会根据运行时的具体对象进行绑定</li>
<li>静态绑定使用的是类信息，而动态绑定使用的是对象信息</li>
<li>重载方法(overloaded methods)使用的是静态绑定，而重写方法(overridden methods)使用的是动态绑定</li>
</ul>
<blockquote>
<p>虚函数：在Java语言中, 所有的方法默认都是”虚函数”。只有以关键字 final 标记的方法才是非虚函数。虚函数是面向对象编程实现多态的基本手段。</p>
</blockquote>
<hr>
<h2 id="静态绑定示例"><a href="#静态绑定示例" class="headerlink" title="静态绑定示例"></a>静态绑定示例</h2><p>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a String instance in A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Object str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a Object instance in A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        Object obj = <span class="string">""</span>;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.hello(str);</span><br><span class="line">        a.hello(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a String instance in A</span><br><span class="line">a Object instance in A</span><br></pre></td></tr></table></figure></p>
<p style="background-color:NavajoWhite;padding:10">分析：可以看出，在A中有两个同名但参数不同的方法(重载)，在调用方法a.hello()时，程序会自动根据输入的参数类型来选择具体调用哪个方法，其后的原理就是静态绑定，即在编译期根据参数类型进行静态绑定。</p>

<hr>
<h2 id="动态绑定实例"><a href="#动态绑定实例" class="headerlink" title="动态绑定实例"></a>动态绑定实例</h2><p>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello in A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBindingDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello in B</span><br></pre></td></tr></table></figure></p>
<p style="background-color:NavajoWhite;padding:10">分析：B继承于A，并重写了A中的方法hello()，从结果可知，a.hello()调用的不是A中的hello()，而是B中的hello()，这正是因为程序在运行时发生了动态绑定。同时也说明了重写方法使用的是动态绑定。</p>

<h1 id="相关问题探讨"><a href="#相关问题探讨" class="headerlink" title="相关问题探讨"></a>相关问题探讨</h1><p><a href="http://stackoverflow.com/questions/12589274/slight-confusion-regarding-overriding-where-variables-are-concerned" target="_blank" rel="external">Stack Overflow</a>上探讨了这么一个问题，具体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCovariantTest</span> <span class="keyword">extends</span> <span class="title">CovariantTest</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getObject</span><span class="params">()</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"sub getobj"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantTest</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getObject</span><span class="params">()</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"ct getobj"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">       CovariantTest c1 = <span class="keyword">new</span> SubCovariantTest();</span><br><span class="line">       System.out.println(c1.getObject().x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub getobj</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>看到这样的输出结果，很多人可能会很纳闷，从第一个输出结果<code>sub getobj</code>可以看出调用的是B对象，但从x输出值上看，却是A对象，这是怎么一回事？！先不急着解决这个问题，我们先来看下下面这段程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B.doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a=<span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(a.x);</span><br><span class="line">        a.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">B.doSomething()</span><br></pre></td></tr></table></figure></p>
<p style="background-color:NavajoWhite;padding:10">分析：根据前面讲解的静态绑定和动态绑定知识，我们可以清楚的知道，在调用方法a.doSomething()时发生的是动态绑定，故输出结果是B.doSomething()，但当调用a.x时，又发生了些什么呢？！<br>这里，我们需要了解一个概念：在Java中，变量(fields)没有多态这个说法，只有方法(methods)有。即变量不存在动态绑定，它是在编译期进行绑定。<br>在编译期，变量x和方法doSomething()都是和A类进行绑定的，而在程序运行时，doSomething()方法会根据运行的对象类型进行动态绑定，即绑定B类，从而执行的是B类中的doSomething()方法。而x变量不进行动态绑定，所以执行的还是A类中的x变量。<br>再回到最开始的那个问题：在编译期，c1绑定的是类CovariantTest，则c1.getObject()返回的是类A，故c1.getObject().x指的是A.x；在运行时，c1.getObject()则会根据运行的对象进行动态绑定，即绑定类SubCovariantTest，而c1.getObject().x不会在进行动态绑定，所以x的值还是类A中的x的值。</p><br>有人可能对变量x到底是属于哪个类还是很疑惑，那么我们再通过一个例子来进行说明：虽然类A和类B都有一个变量x，但是它们并不是同一个x，既然这样，我们就可以用不同的名称表示这两个变量，将类B中的变量x改为y，具体如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCovariantTest</span> <span class="keyword">extends</span> <span class="title">CovariantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub getobj"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ct getobj"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> java.lang.Exception </span>&#123;</span><br><span class="line">        CovariantTest c1 = <span class="keyword">new</span> SubCovariantTest();</span><br><span class="line">        System.out.println(c1.getObject().y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在编译期，如果c1.getObject()返回的是类B，那么上面程序完全没问题，但实际上，会出现以下编译错误。说明，在编译期，c1.getObject()返回的是类A，c1.getObject().x指的是A.x，而且在运行期间不会发生改变。<br><img src="http://i.imgur.com/DrmiNOS.png" alt=""><br>上面的问题解决了，可能有人还会继续问，那么怎样才能达到变量被重写的效果？我们可以这样实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B.doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(a.getX());</span><br><span class="line">        a.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">B.doSomething()</span><br></pre></td></tr></table></figure><br><br><p style="background-color:NavajoWhite;padding:10">显然，正是利用方法的动态绑定达到变量被重写的效果。</p>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/index.html" target="_blank" rel="external">Java中的静态绑定和动态绑定</a></li>
<li><a href="http://www.jianshu.com/p/0677f366db08#" target="_blank" rel="external">Java中的静态绑定和动态绑定</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/03/what-is-static-and-dynamic-binding-in.html" target="_blank" rel="external">What is Static and Dynamic binding in Java with Example</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之重写(Overriding)与重载(Overloading)]]></title>
      <url>http://gongchuangsu.com/2016/05/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%87%8D%E5%86%99(Overriding)%E4%B8%8E%E9%87%8D%E8%BD%BD(Overloading)/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/ODlNsa6.jpg" alt=""></p>
<a id="more"></a>
<h1 id="重写-Overriding"><a href="#重写-Overriding" class="headerlink" title="重写(Overriding)"></a>重写(Overriding)</h1><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！<br>重写的好处在于子类可以根据需要，定义特定于自己的行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"狗可以吠叫"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line"></span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">      b.bark();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序将抛出一个编译错误，因为b的引用类型<code>Animal</code>没有<code>bark</code>方法。<br>这是由于在编译阶段，只是检查参数的引用类型。<br>然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。<br>如果将<code>Animal b = new Dog(); // Dog 对象</code>改为<code>Dog b = new Dog(); // Dog 对象</code>就不会报错。<br><strong>方法的重写规则：</strong></p>
<ul>
<li>参数列表必须完全与被重写方法的相同</li>
<li>返回类型必须完全与被重写方法的返回类型相同</li>
<li>访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>声明为static的方法不能被重写，但是能够被再次声明</li>
<li>构造方法不能被重写</li>
<li>重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。</li>
</ul>
<h1 id="重载-Overloading"><a href="#重载-Overloading" class="headerlink" title="重载(Overloading)"></a>重载(Overloading)</h1><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。参数顺序也可以不相同。<br>每个重载的方法（或者构造函数）都必须有一个<strong>独一无二的参数类型列表</strong>。<br><strong>方法的重载规则：</strong></p>
<ul>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//以下两个参数类型顺序不同</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"test3"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"returntest3"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"returntest4"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">		System.out.println(o.test());</span><br><span class="line">		o.test(<span class="number">1</span>);</span><br><span class="line">		System.out.println(o.test(<span class="number">1</span>,<span class="string">"test3"</span>));</span><br><span class="line">		System.out.println(o.test(<span class="string">"test4"</span>,<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两者之间的区别"><a href="#两者之间的区别" class="headerlink" title="两者之间的区别"></a>两者之间的区别</h1><table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须改变</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可以修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可以修改</td>
<td style="text-align:left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td style="text-align:left">访问</td>
<td style="text-align:left">可以修改</td>
<td style="text-align:left">一定不能做更严格的限制（但可以降低限制）</td>
</tr>
</tbody>
</table>
<h1 id="多态性的不同表现"><a href="#多态性的不同表现" class="headerlink" title="多态性的不同表现"></a>多态性的不同表现</h1><p>在Java中，方法的重写和重载是多态性的不同表现。</p>
<ul>
<li>重写是父类与子类之间多态性的一种表现</li>
<li>重载是一个类中多态性的一种表现</li>
</ul>
<h1 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h1><p>1.存在这么一种情况：两个方法仅返回类型不同，其它都相同，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类中的方法f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 子类中的方法f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面重写和重载的规则，上面的写法既不是重写也不是重载，那它是什么？java设计者可能是考虑到这种情况，所以上面的这种写法在编译时会报错，<code>The return type is incompatible with 父类.f()</code>，所以要么是重写要么是重载，不会存在第三种情况</p>
<hr>
<p>2.创建子类对象时，在父类构造函数中调用被子类重写或重载的方法会出现什么情况？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Base"</span>);</span><br><span class="line">		add(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Base Add"</span>);</span><br><span class="line">		i+=<span class="number">1</span>;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBase1</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubBase1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubBase1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubBase1 Add"</span>);</span><br><span class="line">		i+=v*<span class="number">2</span>;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBase2</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubBase2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubBase2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubBase2 Add"</span>);</span><br><span class="line">		System.out.println(i+c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base1 = <span class="keyword">new</span> SubBase1();</span><br><span class="line">		Base base2 = <span class="keyword">new</span> SubBase2();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span><br><span class="line">Base</span><br><span class="line">SubBase1 Add</span><br><span class="line">2</span><br><span class="line">SubBase1</span><br><span class="line">Base</span><br><span class="line">Base Add</span><br><span class="line">1</span><br><span class="line">SubBase2</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从运行结果上来看，在创建子类对象时，在父类构造函数中调用被子类重写的方法时会调用子类的方法，而在父类构造函数中调用被子类重载的方法时会调用父类的方法。<br>分析：当子类被加载到内存方法区后，会继续加载父类到内存中。 如果，子类重写了父类的方法，子类的方法引用会指向子类的方法，否则子类的方法引用会指向父类的方法引用。 如果子类重载了父类方法，则子类重载方法引用还指向子类方法。 如果子类方法没有重写也没有重载父类方法，则方法引用会指向父类方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之继承与初始化]]></title>
      <url>http://gongchuangsu.com/2016/05/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/MXeLhuu.jpg" alt=""></p>
<a id="more"></a>
<p>在探讨包括继承在内的初始化全过程前，我们先总结下代码块的相关知识。</p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>在java中，所谓的代码块，就是用大括弧<code>{}</code>将多行代码封装在一起，形成一个独立地数据体。Java中的代码块主要分为以下四种：普通代码块、静态代码块、构造代码块、同步代码块。</p>
<h2 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h2><p>平常我们用的最多的就是普通代码块，它是在方法名后面用大括弧<code>{}</code>括起来的代码块。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>静态代码块就是用<code>static</code>关键词修饰的后面用大括弧<code>{}</code>括起来的代码块。主要用于对静态属性进行初始化。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p>构造代码块，即在类中直接定义没有任何修饰符、前缀和后缀的代码块。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>使用 <code>synchronized</code> 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>静态代码块，其作用级别为类，构造代码块、构造函数，其作用级别为对象。</li>
<li>静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。</li>
<li>构造代码块，每创建一个对象时就会执行一次，它依托于构造函数，但先于构造函数执行，主要用于初始化不同对象共性的初始化内容和初始化实例环境。</li>
<li>三者执行顺序为：<code>静态代码块 &gt; 构造代码块 &gt; 构造函数</code></li>
</ol>
<h1 id="继承与初始化"><a href="#继承与初始化" class="headerlink" title="继承与初始化"></a>继承与初始化</h1><p>可通过下面一个示例进行理解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> HelloB();</span><br><span class="line">		<span class="keyword">new</span> HelloB(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 无参构造函数</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"无参构造函数 B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 有参构造函数</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"有参构造函数 B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 构造代码块</span><br><span class="line">	 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	    System.out.println(<span class="string">"构造代码块 B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 静态代码块</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">	    System.out.println(<span class="string">"静态代码块 B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloA</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 无参构造函数</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"无参构造函数 A"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 构造代码块</span><br><span class="line">	 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	    System.out.println(<span class="string">"构造代码块 A"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 静态代码块</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">	    System.out.println(<span class="string">"静态代码块 A"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span><br><span class="line">静态代码块 A</span><br><span class="line">静态代码块 B</span><br><span class="line">构造代码块 A</span><br><span class="line">无参构造函数 A</span><br><span class="line">构造代码块 B</span><br><span class="line">无参构造函数 B</span><br><span class="line">构造代码块 A</span><br><span class="line">无参构造函数 A</span><br><span class="line">构造代码块 B</span><br><span class="line">有参构造函数 B</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure></p>
<p>通过结果可以得知，当涉及到继承时，其执行顺序为：</p>
<ol>
<li>初始化父类中的静态成员变量和静态代码块 ； </li>
<li>初始化子类中的静态成员变量和静态代码块 ； </li>
<li>初始化父类的普通成员变量和代码块，再执行父类的构造方法；</li>
<li>初始化子类的普通成员变量和代码块，再执行子类的构造方法； </li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之String、StringBuffer和StringBuilder]]></title>
      <url>http://gongchuangsu.com/2016/05/16/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BString%E3%80%81StringBuffer%E5%92%8CStringBuilder/</url>
      <content type="html"><![CDATA[<p><img src="http://7xsc5j.com1.z0.glb.clouddn.com/UML%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE1.png" alt="UML类关系图"></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><code>String</code>：此类代表字符串常量，它们的值在创建之后不能更改。</li>
<li><code>StringBuffer</code>：是一个线程安全的可变字符序列，它与<code>String</code>一样，在内存中保存的都是一个有序的字符串序列（<code>char</code>类型的数组），不同点是<code>StringBuffer</code>对象的值是可变的。</li>
<li><code>StringBuilder</code>：与<code>StringBuffer</code>类基本相同，都是可变字符串系列，不同点是<code>StringBuilder</code>是线程不安全的。</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li>简单的说，<code>String</code>类型和<code>StringBuilder</code>、<code>StringBuffer</code>类型的主要性能区别在于<code>String</code>是不可变的对象。这是由于，每次对<code>String</code>类型进行改变的时候，其实都等同于生成了一个新的<code>String</code>对象，然后将指针指向新的<code>String</code>对象。所以经常改变内容的字符串最好不要用<code>String</code> ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</li>
<li>对<code>StringBuffer</code>类型进行改变时，就是对其对象本身进行改变，而不是生成新的对象，再改变对象引用。在一般情况下，推荐使用<code>StringBuffer</code>，特别是字符串对象经常改变的情况下。</li>
<li><code>StringBuffer</code>在程序中可将字符串缓冲区安全地用于多线程，而且在必要时可以对这些方法进行同步。而<code>StringBuilder</code>的使用场景是单线程，不保证同步，该类被设计用作<code>StringBuffer</code>的一个简易替换，用在字符串缓冲区被单个线程使用时。在这种情况下，它比<code>StringBuffer</code>要快。</li>
</ol>
<h1 id="equal-和"><a href="#equal-和" class="headerlink" title="equal 和 =="></a>equal 和 ==</h1><p><code>==</code>用于在比较两个对象的时候，检查两个引用是否指向了同一块内存。<br><code>equals()</code> 是<code>object</code>的方法，默认情况下，它与<code>==</code>一样，比较的地址。但是当<code>equal</code>被重载之后，根据设计，<code>equal</code> 会比较对象的<code>value</code>。而这个是<code>java</code>希望有的功能。<code>String</code> 类就重写了这个方法。<br>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String obj2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">if</span>(obj1 == obj2)</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出为<code>false</code>。</p>
<p>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String obj2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">if</span>(obj1.equals(obj2))</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出为<code>true</code>。</p>
<p>例3：<code>obj1</code>与<code>obj2</code>指向同一块内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String obj2 = obj1;</span><br><span class="line"><span class="keyword">if</span>(obj1 == obj2)</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出为<code>true</code>。</p>
<p>例4：一种特殊情况，直接赋值的字符串常量(不是通过new)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = <span class="string">"hello"</span>;</span><br><span class="line">String obj2 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj1 == obj2)</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出为<code>true</code>。这是因为程序在运行的时候会创建一个字符串缓冲池(也就是栈内存)。当使用 <code>String obj1  = &quot;hello&quot;;</code> 这样的表达是创建字符串的时候（非<code>new</code>这种方式），程序首先会在这个 <code>String</code> 缓冲池中寻找相同值的对象，如果这样的对象不存在，则会创建这个字符串对象，然后将刚创建的对象的引用放入字符串缓冲池中，并将引用返回给变量<code>obj1</code>；当执行<code>String obj2 = &quot;hello&quot;;</code>语句时，JVM同样会字符串缓冲池中查找是否有相同值的对象存在，如果有就将该对象引用返回给<code>obj2</code>，故它们指向同一个对象。</p>
<p>例5：new出来的字符串对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String obj1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String obj2 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj1 == obj2)</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出为<code>false</code>。当我们使用<code>new</code>来构造字符串对象的时候，不管字符串缓冲池有没有相同内容的对象的引用，新的字符串对象都会创建。故它们是所指向的对象是不同的。<br><strong>注意：</strong>使用<code>new</code>来构造字符串对象时，如果想将这个对象的引用加入到字符串缓冲池，可以使用<code>intern</code>方法。具体看参考<a href="http://gongchuangsu.com/2016/05/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">String常用方法总结</a></p>
<blockquote>
<p>在Java中，对象都创建在堆内存中。</p>
</blockquote>
<p>例6：字符串操作符<code>+</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	  </span><br><span class="line">	  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	  System.out.println( a + b + <span class="string">""</span>);</span><br><span class="line">	  System.out.println(<span class="string">""</span> + a + b );</span><br><span class="line">	  System.out.println( a + b + <span class="string">""</span> + a + b);</span><br><span class="line">	  System.out.println(<span class="string">""</span> + ( a + b ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** output</span><br><span class="line">3</span><br><span class="line">12</span><br><span class="line">312</span><br><span class="line">3</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>第一个输出语句：先进行整数求和运算，再将运算结果转换成String输出；<br>第二个输出语句：由于第一个变量类型为String，后面的变量都得转换成String，然后进行String组合，而不是先进行整数求和运算；<br>第三个输出语句：由于第一个变量类型不是String，所以先进行求和运算，然后遇到了String类型，运算结果要进行转换，并且后面的int也需要进行转换；<br>第四个输出语句：虽然第一个变量类型为String，但是后面的括号控制了表达式的赋值顺序，以使得int类型的变量在显示之前确实进行了求和操作。</p>
<p>例7：关于编译器优化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE = <span class="string">"taobao"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"tao"</span> + <span class="string">"bao"</span>;</span><br><span class="line">        String b = <span class="string">"tao"</span>;</span><br><span class="line">        String c = <span class="string">"bao"</span>;</span><br><span class="line">        System.out.println(a == MESSAGE);</span><br><span class="line">        System.out.println((b + c) == MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** output</span><br><span class="line">true </span><br><span class="line">false</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：</p>
<ol>
<li>直接赋值的字符串常量（String s = “Hello World”）是存放于栈内存中，而通过new而来的字符串对象（String s = new String(“Hello World”)）是存放于堆内存中的。则b,c,MESSAGE变量存放于栈内存中</li>
<li>对于字符串常量的相加，考虑到编译器优化问题，在编译时直接将字符串合并，而不是等到运行时再合并。即：<code>String a = &quot;tao&quot; + &quot;bao&quot;;</code>和<code>String a = &quot;taobao&quot;;</code>编译出的字节码是一样的，它们都存在于栈内存中。</li>
<li>对于后面的<code>(b + c)</code>，只能在运行时才会对其进行操作，而不是在编译时就进行合并。Java中的字符串相加是通过<code>StringBuffer</code>实现的。其存在于堆内存中。</li>
</ol>
</blockquote>
<h1 id="CharSequence源码分析-基于jdk1-7-79"><a href="#CharSequence源码分析-基于jdk1-7-79" class="headerlink" title="CharSequence源码分析(基于jdk1.7.79)"></a>CharSequence源码分析(基于jdk1.7.79)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *  返回字符序列的长度</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *  返回指定索引的char值</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 返回该序列的子序列</span><br><span class="line">	 * <span class="doctag">@param</span> start 开始位置的索引值(包括)</span><br><span class="line">	 * <span class="doctag">@param</span> end   结束位置的索引值(不包括)</span><br><span class="line">	 * 说明：当start=end时，返回一个空序列</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *  返回一个包含该序列中字符的字符串，该字符串与序列的顺序相同</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="StringBuilder源码分析-基于jdk1-7-79"><a href="#StringBuilder源码分析-基于jdk1-7-79" class="headerlink" title="StringBuilder源码分析(基于jdk1.7.79)"></a>StringBuilder源码分析(基于jdk1.7.79)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID for interoperability */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4383685877147921099L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个不带任何字符的字符串生成器，其初始容量为16个字符</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个不带任何字符的字符串生成器，其初始容量由capacity参数设定</span><br><span class="line">	 * 说明：其capacity参数值不能小于0，否则会抛出异常NegativeArraySizeException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">	 * 构造一个字符串生成器，并初始化指定的字符串内容。其初始容量为指定字符串的</span><br><span class="line">	 *     长度加上16</span><br><span class="line">     * 说明：其str不能为null，否则会抛出异常NullPointerException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">	 * 构造一个字符串生成器，其包含与指定的字符序列相同的字符。其初始容量为字符</span><br><span class="line">	 *     序列的长度加上16</span><br><span class="line">     * 说明：其seq不能为null，否则会抛出异常NullPointerException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">        append(seq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span><br><span class="line">	 * 追加Object参数的字符串表示形式到此序列 </span><br><span class="line">	 * 说明：如果obj为null，则追加"null"；如果obj不为null，则追加obj.toString()</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> append(String.valueOf(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** </span><br><span class="line">	 * 将指定的字符串追加到此序列 </span><br><span class="line">	 * 说明：如果str为null，则追加"null"</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定的StringBuilder参数追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">append</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sb == <span class="keyword">null</span>)                     <span class="comment">// 如果sb为null，则追加"null"</span></span><br><span class="line">            <span class="keyword">return</span> append(<span class="string">"null"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sb.length();</span><br><span class="line">        <span class="keyword">int</span> newcount = count + len;         <span class="comment">// count为之前的字符长度</span></span><br><span class="line">        <span class="keyword">if</span> (newcount &gt; value.length)        <span class="comment">// 若新的字符长度newcount大于存储容量</span></span><br><span class="line">            expandCapacity(newcount);       <span class="comment">// 则进行扩容</span></span><br><span class="line">        sb.getChars(<span class="number">0</span>, len, value, count);  <span class="comment">// 将sb复制到原字符序列的尾部</span></span><br><span class="line">        count = newcount;                   <span class="comment">// 更新字符长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定的StringBuffer追加到此序列 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(sb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定的CharSequence追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">            s = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.append((String)s);</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> StringBuffer)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.append((StringBuffer)s);</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> StringBuilder)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.append((StringBuilder)s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.append(s, <span class="number">0</span>, s.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定的CharSequence子序列追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(s, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 将char数组参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将char数组参数的子数组的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str, offset, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 将boolean参数的字符串表示形式追加到此序列</span><br><span class="line">	 * 说明：若b为true，则追加"true"；若b为false，则追加"false"</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将char字符的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将int参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 将int参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">long</span> lng)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(lng);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 将float参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将double参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(d);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将codePoint参数的字符串表示形式追加到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">appendCodePoint</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.appendCodePoint(codePoint);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span><br><span class="line">	 * 移除此序列的子字符串中的字符 </span><br><span class="line">	 * 说明：包含起始索引但不包括结束索引</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 移除此序列指定位置上的字符 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.deleteCharAt(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span><br><span class="line">	  * 使用给定的String中的字符替换此序列的子字符串中的字符</span><br><span class="line">	  * 该子字符串从指定的start处开始，一直到索引end-1处的字符</span><br><span class="line">	  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.replace(start, end, str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 将str数组参数的子数组的字符串表示形式插入到此序列中</span><br><span class="line">	 * 子数组从指定的offset(包括offset)开始，包括len个char</span><br><span class="line">	 * 子数组的字符将被插入到index所指示的位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>[] str, <span class="keyword">int</span> offset,</span><br><span class="line">                                <span class="keyword">int</span> len)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(index, str, offset, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将Object参数的字符串表示形式插入到此字符序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(offset, String.valueOf(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将字符串插入到此序列 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将char数组参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定的CharSequence插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">            s = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.insert(dstOffset, (String)s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.insert(dstOffset, s, <span class="number">0</span>, s.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将指定 CharSequence 的子序列插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> dstOffset, CharSequence s,</span><br><span class="line">                                <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(dstOffset, s, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 boolean 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(offset, b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 char 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(offset, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 int 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(offset, String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 long 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(offset, String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 float 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(offset, String.valueOf(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将 double 参数的字符串表示形式插入此序列中 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(offset, String.valueOf(d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回指定子字符串在此字符串中第一次出现处的索引 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.indexOf(value, <span class="number">0</span>, count,</span><br><span class="line">                              str.toCharArray(), <span class="number">0</span>, str.length(), fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回最右边出现的指定子字符串在此字符串中的索引 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastIndexOf(str, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 从指定位置开始，返回最右边出现的指定子字符串在此字符串中的索引 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.lastIndexOf(value, <span class="number">0</span>, count,</span><br><span class="line">                              str.toCharArray(), <span class="number">0</span>, str.length(), fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将此字符序列用其反转形式取代 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.reverse();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此序列中数据的字符串表示形式 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Save the state of the &lt;tt&gt;StringBuilder&lt;/tt&gt; instance to a stream</span><br><span class="line">     * (that is, serialize it).</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@serialData</span> the number of characters currently stored in the string</span><br><span class="line">     *             builder (&lt;tt&gt;int&lt;/tt&gt;), followed by the characters in the</span><br><span class="line">     *             string builder (&lt;tt&gt;char[]&lt;/tt&gt;).   The length of the</span><br><span class="line">     *             &lt;tt&gt;char&lt;/tt&gt; array may be greater than the number of</span><br><span class="line">     *             characters currently stored in the string builder, in which</span><br><span class="line">     *             case extra characters are ignored.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(count);</span><br><span class="line">        s.writeObject(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * readObject is called to restore the state of the StringBuffer from</span><br><span class="line">     * a stream.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        count = s.readInt();</span><br><span class="line">        value = (<span class="keyword">char</span>[]) s.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h1><p>1.运算符<code>+=</code><br>假设<code>String str = &quot;hello world&quot;;</code>那么以下语句都是合法的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="number">100</span>;    <span class="comment">// 后加int型数值</span></span><br><span class="line">str += <span class="number">1000L</span>;  <span class="comment">// 后加long型数值</span></span><br><span class="line">str += <span class="number">12.3</span>;   <span class="comment">// 后加double型数值</span></span><br><span class="line">str += <span class="number">12.3f</span>;  <span class="comment">// 后加float型数值</span></span><br><span class="line">str += <span class="string">'a'</span>;    <span class="comment">// 后加char型数值</span></span><br><span class="line">str += <span class="keyword">true</span>;   <span class="comment">// 后加boolean型数值</span></span><br></pre></td></tr></table></figure></p>
<p>但是特别注意：下面语句是不合法的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">" a"</span>;      <span class="comment">// 可行</span></span><br><span class="line"><span class="comment">//str += ' a';    // Invalid character constant，a前面不能有空字符</span></span><br><span class="line"><span class="comment">//str = 100;      // Type mismatch: cannot convert from int to String</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之LinkedList基本用法]]></title>
      <url>http://gongchuangsu.com/2016/05/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinkedList%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/BojOTfc.jpg" alt=""></p>
<a id="more"></a>
<h1 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h1><ul>
<li><code>LinkedList</code> 是一个继承于<code>AbstractSequentialList</code>的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li>
<li><code>LinkedList</code> 实现 <code>List</code> 接口，能进行队列操作。</li>
<li><code>LinkedList</code> 实现 <code>Deque</code> 接口，即能将<code>LinkedList</code>当作双端队列使用。</li>
<li><code>ArrayList</code>底层是由数组支持，而<code>LinkedList</code> 是由双向链表实现的，其中的每个对象包含数据的同时还包含指向链表中前一个与后一个元素的引用。</li>
</ul>
<h1 id="LinkedList遍历方式"><a href="#LinkedList遍历方式" class="headerlink" title="LinkedList遍历方式"></a>LinkedList遍历方式</h1><p><code>LinkedList</code>有以下几种遍历方式：</p>
<h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for循环get-遍历"><a href="#for循环get-遍历" class="headerlink" title="for循环get()遍历"></a>for循环get()遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++)&#123;</span><br><span class="line">	linkedList.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Foreach循环遍历"><a href="#Foreach循环遍历" class="headerlink" title="Foreach循环遍历"></a>Foreach循环遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : linkedList);</span><br></pre></td></tr></table></figure>
<h2 id="通过pollFirst-或pollLast-遍历"><a href="#通过pollFirst-或pollLast-遍历" class="headerlink" title="通过pollFirst()或pollLast()遍历"></a>通过pollFirst()或pollLast()遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(linkedList.size() != <span class="number">0</span>)&#123;</span><br><span class="line">	linkedList.pollFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过removeFirst-或removeLast-遍历"><a href="#通过removeFirst-或removeLast-遍历" class="headerlink" title="通过removeFirst()或removeLast()遍历"></a>通过removeFirst()或removeLast()遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(linkedList.size() != <span class="number">0</span>)&#123;</span><br><span class="line">	linkedList.removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h2><p>测试以上几种遍历方式的效率，部分代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************** 遍历操作   ************************/</span></span><br><span class="line">System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">linkedList.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">	linkedList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"Iterator："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++)&#123;</span><br><span class="line">	linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"for："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种for循环遍历</span></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(Integer i : linkedList);</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"for2："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">temp1.addAll(linkedList);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span>(temp1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">	temp1.pollFirst();</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">temp2.addAll(linkedList);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span>(temp2.size() != <span class="number">0</span>)&#123;</span><br><span class="line">	temp2.removeFirst();</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) +<span class="string">" ms"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">Iterator：<span class="number">17</span> ms</span><br><span class="line"><span class="keyword">for</span>：<span class="number">8419</span> ms</span><br><span class="line">for2：<span class="number">12</span> <span class="function">ms</span><br><span class="line"><span class="title">pollFirst</span><span class="params">()</span>或<span class="title">pollLast</span><span class="params">()</span>：12 ms</span><br><span class="line"><span class="title">removeFirst</span><span class="params">()</span>或<span class="title">removeLast</span><span class="params">()</span>：10 ms</span></span><br></pre></td></tr></table></figure></p>
<p>由测试结果可以看出，遍历<code>LinkedList</code>时，使用<code>removeFirst()</code>或<code>removeLast()</code>效率最高，而for循环get()效率最低，应避免使用这种方式进行。应当注意的是，使用<code>pollFirst()</code>或<code>pollLast()</code>或<code>removeFirst()</code>或<code>removeLast()</code>遍历时，会删除原始数据，若只单纯的读取，应当选用第一种或第三种方式。</p>
<h1 id="LinkedList示例"><a href="#LinkedList示例" class="headerlink" title="LinkedList示例"></a>LinkedList示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.05.11</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** 基本操作 ************************/</span></span><br><span class="line">		linkedList.addFirst(<span class="number">0</span>);    <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">		linkedList.add(<span class="number">1</span>);         <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">		linkedList.add(<span class="number">2</span>,<span class="number">2</span>);       <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">		linkedList.addLast(<span class="number">3</span>);     <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"LinkedList: "</span> + linkedList);</span><br><span class="line">				</span><br><span class="line">		System.out.println(<span class="string">"getFirst(): "</span> + linkedList.getFirst());       <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">		System.out.println(<span class="string">"getLast(): "</span> + linkedList.getLast());		  <span class="comment">// 返回此列表的最后一个元素		</span></span><br><span class="line">		System.out.println(<span class="string">"removeFirst(): "</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素		</span></span><br><span class="line">		System.out.println(<span class="string">"removeLast(): "</span> + linkedList.removeLast());   <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">		System.out.println(<span class="string">"After remove:"</span> + linkedList);                	</span><br><span class="line">		System.out.println(<span class="string">"contains(1) is :"</span> + linkedList.contains(<span class="number">1</span>));  <span class="comment">// 判断此列表包含指定元素，如果是，则返回true	</span></span><br><span class="line">		System.out.println(<span class="string">"size is : "</span> + linkedList.size());             <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">		linkedList.set(<span class="number">1</span>, <span class="number">3</span>);                                             <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">		System.out.println(<span class="string">"After set(1, 3):"</span> + linkedList);  </span><br><span class="line">		System.out.println(<span class="string">"get(1): "</span> + linkedList.get(<span class="number">1</span>));               <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** Search操作  ************************/</span></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">		linkedList.add(<span class="number">3</span>);</span><br><span class="line">		System.out.println(<span class="string">"indexOf(3): "</span> + linkedList.indexOf(<span class="number">3</span>));        <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">		System.out.println(<span class="string">"lastIndexOf(3): "</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** Queue操作   ************************/</span></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">		System.out.println(<span class="string">"peek(): "</span> + linkedList.peek());                <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">		System.out.println(<span class="string">"element(): "</span> + linkedList.element());          <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">		linkedList.poll();                                                 <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">		System.out.println(<span class="string">"After poll():"</span> + linkedList);</span><br><span class="line">		linkedList.remove();</span><br><span class="line">		System.out.println(<span class="string">"After remove():"</span> + linkedList);                <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">		linkedList.offer(<span class="number">4</span>);</span><br><span class="line">		System.out.println(<span class="string">"After offer(4):"</span> + linkedList);                <span class="comment">// 将指定元素添加到此列表的末尾  </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** Deque操作   ************************/</span></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">		linkedList.offerFirst(<span class="number">2</span>);                                          <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">		System.out.println(<span class="string">"After offerFirst(2):"</span> + linkedList);</span><br><span class="line">		linkedList.offerLast(<span class="number">5</span>);                                           <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">		System.out.println(<span class="string">"After offerLast(5):"</span> + linkedList);</span><br><span class="line">		System.out.println(<span class="string">"peekFirst(): "</span> + linkedList.peekFirst());      <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">		System.out.println(<span class="string">"peekLast(): "</span> + linkedList.peekLast());        <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">		linkedList.pollFirst();                                            <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">		System.out.println(<span class="string">"After pollFirst():"</span> + linkedList);</span><br><span class="line">		linkedList.pollLast();                                             <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">		System.out.println(<span class="string">"After pollLast():"</span> + linkedList);</span><br><span class="line">		linkedList.push(<span class="number">2</span>);                                                <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">		System.out.println(<span class="string">"After push(2):"</span> + linkedList);</span><br><span class="line">		linkedList.pop();                                                  <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">		System.out.println(<span class="string">"After pop():"</span> + linkedList);</span><br><span class="line">		linkedList.add(<span class="number">3</span>);</span><br><span class="line">		linkedList.removeFirstOccurrence(<span class="number">3</span>);                               <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">		System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">		linkedList.removeLastOccurrence(<span class="number">3</span>);                                <span class="comment">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">		System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/************************** 遍历操作   ************************/</span></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">		linkedList.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">			linkedList.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 迭代器遍历</span></span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			iterator.next();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"Iterator："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++)&#123;</span><br><span class="line">			linkedList.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"for："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 另一种for循环遍历</span></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span>(Integer i : linkedList);</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"for2："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//  通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">		LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		temp1.addAll(linkedList);</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>(temp1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">			temp1.pollFirst();</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">		LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		temp2.addAll(linkedList);</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>(temp2.size() != <span class="number">0</span>)&#123;</span><br><span class="line">			temp2.removeFirst();</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) +<span class="string">" ms"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Output</span><br><span class="line">LinkedList: [0, 1, 2, 3]</span><br><span class="line">getFirst(): 0</span><br><span class="line">getLast(): 3</span><br><span class="line">removeFirst(): 0</span><br><span class="line">removeLast(): 3</span><br><span class="line">After remove:[1, 2]</span><br><span class="line">contains(1) is :true</span><br><span class="line">size is : 2</span><br><span class="line">-----------------------------------------</span><br><span class="line">After set(1, 3):[1, 3]</span><br><span class="line">get(1): 3</span><br><span class="line">-----------------------------------------</span><br><span class="line">indexOf(3): 1</span><br><span class="line">lastIndexOf(3): 2</span><br><span class="line">-----------------------------------------</span><br><span class="line">peek(): 1</span><br><span class="line">element(): 1</span><br><span class="line">After poll():[3, 3]</span><br><span class="line">After remove():[3]</span><br><span class="line">After offer(4):[3, 4]</span><br><span class="line">-----------------------------------------</span><br><span class="line">After offerFirst(2):[2, 3, 4]</span><br><span class="line">After offerLast(5):[2, 3, 4, 5]</span><br><span class="line">peekFirst(): 2</span><br><span class="line">peekLast(): 5</span><br><span class="line">After pollFirst():[3, 4, 5]</span><br><span class="line">After pollLast():[3, 4]</span><br><span class="line">After push(2):[2, 3, 4]</span><br><span class="line">After pop():[3, 4]</span><br><span class="line">After removeFirstOccurrence(3):[4, 3]</span><br><span class="line">After removeFirstOccurrence(3):[4]</span><br><span class="line">-----------------------------------------</span><br><span class="line">Iterator：17 ms</span><br><span class="line">for：8419 ms</span><br><span class="line">for2：12 ms</span><br><span class="line">pollFirst()或pollLast()：12 ms</span><br><span class="line">removeFirst()或removeLast()：10 ms</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="LinkedList和ArrayList比较"><a href="#LinkedList和ArrayList比较" class="headerlink" title="LinkedList和ArrayList比较"></a>LinkedList和ArrayList比较</h1><ul>
<li><code>LinkedList</code>中插入元素很快，而<code>ArrayList</code>中插入元素很慢</li>
<li><code>LinkedList</code>中随机访问很慢，而<code>ArrayList</code>中随机访问很快</li>
</ul>
<h1 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个结点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个结点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个空列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个包含指定 Collection 中的元素的列表，</span></span><br><span class="line">	<span class="comment">// 这些元素按其 Collection 的迭代器返回的顺序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定元素插入此列表的开头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定元素添加到此列表的结尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定元素添加到此列表的结尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此列表中移除首次出现的指定元素(如果存在返回true，否则返回false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加指定 collection 中的所有元素到此列表的结尾，</span></span><br><span class="line">	<span class="comment">// 顺序是指定 collection 的迭代器返回这些元素的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定 collection 中的所有元素从指定位置开始插入此列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);<span class="comment">// 检查index的范围</span></span><br><span class="line">		</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)          <span class="comment">// 如果c为空，则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;      <span class="comment">// 插入位置为列表末尾</span></span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);   <span class="comment">// 插入位置不是列表末尾</span></span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 将元素添加到pred末尾</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 将剩余元素整合一起</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此列表中移除所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********************** 位置访问操作 **************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此列表中指定的位置插入指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)     <span class="comment">// 插入到末尾</span></span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除此列表中指定位置处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （包访问权限）返回指定位置上的结点（非空）</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">        <span class="comment">// 根据指定位置是在左半边还是在右半边，</span></span><br><span class="line">		<span class="comment">// 来决定是用正向寻找还是反向寻找</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********************** Search操作 **************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表中首次出现的指定元素的索引，</span></span><br><span class="line">	<span class="comment">// 如果此列表中不包含该元素，则返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表中最后出现的指定元素的索引，</span></span><br><span class="line">	<span class="comment">// 如果此列表中不包含该元素，则返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********************** Queue操作 **************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取但不移除此列表的头（第一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取但不移除此列表的头（第一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并移除此列表的头（第一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并移除此列表的头（第一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定元素添加到此列表的末尾（最后一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********************** Deque操作 **************************/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取但不移除此列表的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// （私有类）结点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@since</span> 1.6</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Adapter to provide descending iterators via ListItr.previous</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此 LinkedList 的浅表副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put clone into "virgin" state</span></span><br><span class="line">        clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；</span></span><br><span class="line">	<span class="comment">// 返回数组的运行时类型为指定数组的类型。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                                a.getClass().getComponentType(), size);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">    <span class="comment">// 将LinkedList的“容量，所有的元素值”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式反向读出</span></span><br><span class="line">    <span class="comment">// 先将LinkedList的“容量”读出，然后将“所有的元素值”读出</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之ArrayList基本用法]]></title>
      <url>http://gongchuangsu.com/2016/05/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BArrayList%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/OZDOyid.jpg" alt=""></p>
<a id="more"></a>
<h1 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h1><p><code>ArrayList</code>是一个其容量能够动态增长的动态数组。它继承了<code>AbstractList</code>，实现了<code>List</code>、<code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code>。<br>基本的<code>ArrayList</code>，长于随机访问元素，但是在<code>List</code>中间插入和移除元素时较慢。同时，<code>ArrayList</code>的操作不是线程安全的！一般在单线程中才使用<code>ArrayList</code>，而在多线程中一般使用<code>Vector</code>或者<code>CopyOnWriteArrayList</code>。</p>
<h1 id="ArrayList遍历方式"><a href="#ArrayList遍历方式" class="headerlink" title="ArrayList遍历方式"></a>ArrayList遍历方式</h1><p><code>ArrayList</code>有三种遍历方式</p>
<h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引值遍历"><a href="#索引值遍历" class="headerlink" title="索引值遍历"></a>索引值遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class="line">   System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer number : arrayList)&#123;</span><br><span class="line">   System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，遍历<code>ArrayList</code>时，通过索引值遍历效率最高，for循环遍历次之，迭代器遍历最低。</p>
<h1 id="toArray-的使用"><a href="#toArray-的使用" class="headerlink" title="toArray()的使用"></a>toArray()的使用</h1><p>有时候，当我们调用<code>ArrayList</code>中的 <code>toArray()</code>，可能遇到过抛出<code>java.lang.ClassCastException</code>异常的情况，这是由于<code>toArray()</code> 返回的是 <code>Object[]</code> 数组，将 <code>Object[]</code> 转换为其它类型(如，将<code>Object[]</code>转换为的<code>Integer[]</code>)则会抛出<code>java.lang.ClassCastException</code>异常，因为<code>Java</code>不支持向下转型。<br>所以一般更常用的是使用另外一种方法进行使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure></p>
<p>调用<code>toArray(T[] a)</code>返回<code>T[]</code>可通以下方式进行实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toArray用法</span></span><br><span class="line"><span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">Integer[] integer = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">Integer[] integer1 = <span class="keyword">new</span> Integer[arrayList.size()];</span><br><span class="line">arrayList.toArray(integer1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line"><span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line"><span class="comment">//integer2 = arrayList.toArray();</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ArrayList用法示例"><a href="#ArrayList用法示例" class="headerlink" title="ArrayList用法示例"></a>ArrayList用法示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.05.10</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">		 ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		 </span><br><span class="line">		 System.out.printf(<span class="string">"Before add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line">		 </span><br><span class="line">		 arrayList.add(<span class="number">1</span>);</span><br><span class="line">		 arrayList.add(<span class="number">3</span>);</span><br><span class="line">		 arrayList.add(<span class="number">5</span>);</span><br><span class="line">		 arrayList.add(<span class="number">7</span>);</span><br><span class="line">		 arrayList.add(<span class="number">9</span>);</span><br><span class="line">		 System.out.printf(<span class="string">"After add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line">		 </span><br><span class="line">		 System.out.println(<span class="string">"Printing elements of arrayList"</span>);</span><br><span class="line">		 <span class="comment">// 三种遍历方式打印元素</span></span><br><span class="line">		 <span class="comment">// 第一种：通过迭代器遍历</span></span><br><span class="line">		 System.out.print(<span class="string">"通过迭代器遍历:"</span>);</span><br><span class="line">		 Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line">		 <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			 System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 System.out.println();</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 第二种：通过索引值遍历</span></span><br><span class="line">		 System.out.print(<span class="string">"通过索引值遍历:"</span>);</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class="line">			 System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 System.out.println();</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 第三种：for循环遍历</span></span><br><span class="line">		 System.out.print(<span class="string">"for循环遍历:"</span>);</span><br><span class="line">		 <span class="keyword">for</span>(Integer number : arrayList)&#123;</span><br><span class="line">			 System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// toArray用法</span></span><br><span class="line">		 <span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">		 Integer[] integer = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">		 Integer[] integer1 = <span class="keyword">new</span> Integer[arrayList.size()];</span><br><span class="line">		 arrayList.toArray(integer1);</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line">		 <span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line">		 <span class="comment">//integer2 = arrayList.toArray();</span></span><br><span class="line">		 System.out.println();</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">		 arrayList.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">		 <span class="comment">// 删除指定位置上的元素</span></span><br><span class="line">		 arrayList.remove(<span class="number">2</span>);	 </span><br><span class="line">		 <span class="comment">// 删除指定元素</span></span><br><span class="line">		 arrayList.remove((Object)<span class="number">3</span>);</span><br><span class="line">		 <span class="comment">// 判断arrayList是否包含5</span></span><br><span class="line">		 System.out.println(<span class="string">"ArrayList contains 5 is: "</span> + arrayList.contains(<span class="number">5</span>));</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 清空ArrayList</span></span><br><span class="line">		 arrayList.clear();</span><br><span class="line">		 <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">		 System.out.println(<span class="string">"ArrayList is empty: "</span> + arrayList.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">Before add:arrayList.size() = 0</span><br><span class="line">After add:arrayList.size() = 5</span><br><span class="line">Printing elements of arrayList</span><br><span class="line">通过迭代器遍历:1 3 5 7 9 </span><br><span class="line">通过索引值遍历:1 3 5 7 9 </span><br><span class="line">for循环遍历:1 3 5 7 9 </span><br><span class="line">ArrayList contains 5 is: true</span><br><span class="line">ArrayList is empty: true</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 序列版本号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存ArrayList中数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ArrayList中所包含元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带初始容量参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数，其默认初始容量为10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带Collection参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        size = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此 ArrayList 实例的容量调整为列表的当前大小(实际元素个数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所</span></span><br><span class="line">	<span class="comment">// 指定的元素数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if real element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">            <span class="comment">// at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ArrayList中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断ArrayList是否包含Object(o)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ArrayList中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ArrayList中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此 ArrayList 实例的浅表副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">			<span class="comment">// 将当前ArrayList的全部元素拷贝到v中</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位置访问操作	</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ArrayList中指定位置上的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用指定的元素替代ArrayList中指定位置上的元素，并返回替代前的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的元素添加到ArrayList的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的元素插入ArrayList中的指定位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除ArrayList中指定位置上的元素，并返回该位置上的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除ArrayList中首次出现的指定元素（如果存在则移除并返回true，否则返回false）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，用于快速移除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除ArrayList中的所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照指定 collection 的迭代器所返回的元素顺序，</span></span><br><span class="line">	<span class="comment">// 将该 collection 中的所有元素添加到ArrayList的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定的位置开始，将指定 collection 中的所有元素插入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，用于范围检测</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，用于add和addAll</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除ArrayList中Collection所包含的所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留所有ArrayList和Collection共有的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">            <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">                <span class="comment">// clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">	<span class="comment">// 将ArrayList的“容量，所有的元素值”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></span><br><span class="line">    <span class="comment">// 先将ArrayList的“容量”读出，然后将“所有的元素值”读出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个从指定位置开始遍历的ListIterator迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个ListIterator迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Iterator迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个指定范围的子List列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之Iterator和ListIterator]]></title>
      <url>http://gongchuangsu.com/2016/05/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%E5%92%8CListIterator/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/aYNx4Ds.jpg" alt=""></p>
<a id="more"></a>
<p><code>Iterator</code>接口是对<code>collection</code>进行迭代的迭代器，<code>ListIterator</code>接口是其子接口。它们都是遍历集合的工具。<br><code>Collection</code>依赖于<code>Iterator</code>，其实现类都必须实现<code>iterator()</code>函数，返回一个<code>Iterator</code>对象；<code>ListIterator</code>是专门遍历<code>List</code>而存在的。</p>
<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p><code>Iterator</code>迭代器包含以下三种方法：</p>
<ul>
<li><code>boolean hasNext()</code>：如果仍有元素可以迭代，则返回 true</li>
<li><code>E next()</code>：返回迭代的下一个元素</li>
<li><code>void remove()</code>：从迭代器指向的 collection 中移除迭代器返回的最后一个元素，每次调用 next 只能调用一次此方法</li>
</ul>
<h1 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h1><p><code>ListIterator</code>迭代器包含以下九种方法：</p>
<ul>
<li><code>void add(E e)</code>：将指定的元素插入列表</li>
<li><code>boolean hasNext()</code> ：以正向遍历列表时，如果列表迭代器有多个元素，则返回 true</li>
<li><code>boolean hasPrevious()</code> ：如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</li>
<li><code>E next()</code>：返回列表中的下一个元素</li>
<li><code>int nextIndex()</code> ：返回对 next 的后续调用所返回元素的索引</li>
<li><code>E    previous()</code>：返回列表中的前一个元素</li>
<li><code>int previousIndex()</code> ：返回对 previous 的后续调用所返回元素的索引</li>
<li><code>void    remove()</code> ：从列表中移除由 next 或 previous 返回的最后一个元素</li>
<li><code>void    set(E e)</code>：用指定元素替换 next 或 previous 返回的最后一个元素</li>
</ul>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>相同点</strong>：都可以对集合中的元素进行遍历<br><strong>不同点</strong>：</p>
<ul>
<li>使用范围不同，<code>Iterator</code>可应用于所有的集合，而<code>ListIterator</code>只能用于<code>List</code>及其子类型，如<code>List</code>、<code>ArrayList</code>、Link<code>e</code>dList和<code>Vector</code>等</li>
<li><code>ListIterator</code>可通过<code>set()</code>方法实现对象的修改，而<code>Iterator</code>不能</li>
<li><code>ListIterator</code>可通过<code>nextIndex()</code>或<code>previousIndex()</code>得到后续调用所返回元素的索引，而<code>Iterator</code>不能</li>
<li><code>ListIterator</code>可实现双向遍历，而<code>Iterator</code>只能顺序向前遍历</li>
<li><code>ListIterator</code>可通过<code>add()</code>添加对象，而<code>Iterator</code>不能</li>
</ul>
<p><strong>要特别注意的是：长度为n的列表的迭代器有n+1种可能的指针位置，指针位置总是两个位于元素之间</strong><br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/Iterator.png" alt="enter image description here"></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.05.10</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; al = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		al.add(<span class="string">"C"</span>);</span><br><span class="line">		al.add(<span class="string">"A"</span>);</span><br><span class="line">		al.add(<span class="string">"E"</span>);</span><br><span class="line">		al.add(<span class="string">"B"</span>);</span><br><span class="line">		al.add(<span class="string">"D"</span>);</span><br><span class="line">		al.add(<span class="string">"F"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.print(<span class="string">"Original contents of al: "</span>);</span><br><span class="line">		Iterator&lt;String&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		ListIterator&lt;String&gt; lt = al.listIterator();</span><br><span class="line">		<span class="keyword">while</span>(lt.hasNext())&#123;</span><br><span class="line">			lt.set(lt.next() + <span class="string">"+"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">"Modified contents of al: "</span>);</span><br><span class="line">		lt = al.listIterator();</span><br><span class="line">		<span class="keyword">while</span>(lt.hasNext())&#123;</span><br><span class="line">			System.out.print(lt.nextIndex() + <span class="string">":"</span>);</span><br><span class="line">			System.out.print(lt.next() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	</span><br><span class="line">		System.out.print(<span class="string">"Modified list backwards: "</span>);</span><br><span class="line">		<span class="keyword">while</span>(lt.hasPrevious())&#123;</span><br><span class="line">			System.out.print(lt.previousIndex() + <span class="string">":"</span>);</span><br><span class="line">			System.out.print(lt.previous() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[String常用方法总结]]></title>
      <url>http://gongchuangsu.com/2016/05/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/M5OpRZ3.jpg" alt=""></p>
<a id="more"></a>
<h1 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span><br><span class="line"> * 将此字符串中的字符复制到目标字符数组</span><br><span class="line"> * <span class="doctag">@param</span> 字符串中要复制的第一个字符的索引</span><br><span class="line"> * <span class="doctag">@param</span> 字符串中要复制的最后一个字符之后的索引(不包括该字符)</span><br><span class="line"> * <span class="doctag">@param</span> 目标数组</span><br><span class="line"> * <span class="doctag">@param</span> 目标数组中的起始偏移量</span><br><span class="line"> * 说明：以下任一项为true将会抛出IndexOutOfBoundsException异常</span><br><span class="line"> *   1.srcBegin为负</span><br><span class="line"> *   2.srcBegin大于 srcEnd</span><br><span class="line"> *   3.srcEnd大于此字符串的长度</span><br><span class="line"> *   4.dstBegin为负</span><br><span class="line"> *   5.dstBegin+(srcEnd-srcBegin)大于 dst.length</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h1><p>该方法有以下几种形式，分别对应不同的输入类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回 Object 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line">  * 返回 boolean 参数的字符串表示形式</span><br><span class="line">  * 说明：如果参数为 true，则返回一个等于 "true" 的字符串；</span><br><span class="line">  *       否则，返回一个等于 "false" 的字符串。</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 char 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 int 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 long 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 float 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 double 参数的字符串表示形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line">  * 返回 char 数组参数的特定子数组的字符串表示形式</span><br><span class="line">  * 说明：字符数组的内容已被复制，后续修改不会影响新创建的字符串</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h1><p><strong>源码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">Returns a canonical representation for the string object. </span><br><span class="line"></span><br><span class="line">A pool of strings, initially empty, is maintained privately by the class String. </span><br><span class="line"></span><br><span class="line">When the intern method is invoked, if the pool already contains a string equal to</span><br><span class="line">this String object as determined by the equals(Object) method, then the string </span><br><span class="line">from the pool is returned. Otherwise, this String object is added to the pool </span><br><span class="line">and a reference to this String object is returned. </span><br><span class="line"></span><br><span class="line">It follows that for any two strings s and t, s.intern() == t.intern() is true </span><br><span class="line">if and only if s.equals(t) is true. </span><br><span class="line"></span><br><span class="line">All literal strings and string-valued constant expressions are interned. </span><br><span class="line">String literals are defined in section 3.10.5 of the The Java™ Language Specification.</span><br><span class="line"></span><br><span class="line">Returns:</span><br><span class="line">a string that has the same contents as this string, </span><br><span class="line">but is guaranteed to be from a pool of unique strings.</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>由源码可知，当调用<code>intern</code>方法时，如果字符串资源池中已经包含一个等于该String对象的字符串(通过equals(object)方法确定)，则返回资源池中相等字符串的引用；否则，将该String对象添加到资源池中，并返回该String对象的引用。<br>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">"1"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>).append(<span class="string">"1"</span>).toString();</span><br><span class="line">        s3.intern();</span><br><span class="line">        String s4 = <span class="string">"11"</span>;       </span><br><span class="line">        System.out.println(s3 == s4);    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>).append(<span class="string">"string"</span>).toString();</span><br><span class="line">      System.out.println(str1.intern() == str1);</span><br><span class="line">      String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">      System.out.println(str2.intern() == str2);   	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>问题待解决。。。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">深入解析String#intern</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拓扑排序算法(Topological Sorting)]]></title>
      <url>http://gongchuangsu.com/2016/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F(Topological%20Sorting)%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="拓扑排序-Topological-Sorting"><a href="#拓扑排序-Topological-Sorting" class="headerlink" title="拓扑排序(Topological Sorting)"></a>拓扑排序(Topological Sorting)</h1><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>
<ul>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul>
<a id="more"></a>
<p>用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为<strong>AOV网（Activity On Vertex Network）</strong>。<br>另外，AOV网是一种有向无回路的图。那么，每个AOV网都至少存在一个拓扑排序。</p>
<h1 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h1><p>对AOV网进行拓扑排序的基本思路如下：</p>
<ul>
<li>从AOV网中选择一个入度为0的顶点输出</li>
<li>删除此顶点，并删除以此顶点为尾的弧（更新顶点入度）</li>
<li>继续重复前面两个步骤，直到全部定点输出</li>
</ul>
<p>大概流程图如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="enter image description here"></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 拓扑排序算法（TopologicalSort）</span><br><span class="line"> *          输入：领接表表示的有向图</span><br><span class="line"> *          输出：若图无回路，则输出拓扑排序序列并返回OK</span><br><span class="line"> *                若图有回路，则返回ERROR.     </span><br><span class="line"> * <span class="doctag">@author</span>  GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span>   2016.04.19</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> </span>&#123;</span><br><span class="line">    Stack &lt; Integer &gt; stack; <span class="comment">// 用于存储入度为0的顶点的下标</span></span><br><span class="line">    Queue &lt; Integer &gt; queue; <span class="comment">// 用于存储拓扑排序结果</span></span><br><span class="line">    <span class="keyword">int</span> vlen;                <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree;          <span class="comment">// 入度数组</span></span><br><span class="line">    <span class="keyword">int</span> count;               <span class="comment">// 统计输出顶点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">topologicalSort</span><span class="params">(ListDG listDG)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack &lt; Integer &gt; ();</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList &lt; Integer &gt; ();</span><br><span class="line">        <span class="keyword">this</span>.vlen = listDG.vlen;</span><br><span class="line">        indegree = <span class="keyword">new</span> <span class="keyword">int</span>[vlen];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个顶点的入度数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            ListDG.EdgeNode edgeNode = <span class="keyword">new</span> ListDG.EdgeNode();</span><br><span class="line">            edgeNode = listDG.vertexNodeList[i].firstedge;</span><br><span class="line">            <span class="keyword">while</span> (edgeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                indegree[edgeNode.adjvex]++;</span><br><span class="line">                edgeNode = edgeNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将入度为0的顶点入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.pop(); <span class="comment">// 出栈</span></span><br><span class="line">            queue.offer(top);</span><br><span class="line">            count++;               <span class="comment">// 统计输出顶点个数</span></span><br><span class="line">            ListDG.EdgeNode edgeNode = <span class="keyword">new</span> ListDG.EdgeNode();</span><br><span class="line">            edgeNode = listDG.vertexNodeList[top].firstedge;</span><br><span class="line">            <span class="keyword">while</span> (edgeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                indegree[edgeNode.adjvex]--;        <span class="comment">// 与此顶点连接的各顶点入度减1</span></span><br><span class="line">                <span class="keyword">if</span> (indegree[edgeNode.adjvex] == <span class="number">0</span>) <span class="comment">// 判断连接顶点的入度是否为0，若为0，则入栈</span></span><br><span class="line">                    stack.push(edgeNode.adjvex);</span><br><span class="line">                edgeNode = edgeNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在环</span></span><br><span class="line">        <span class="keyword">if</span> (count != vlen) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Graph has a cycle.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Error"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(queue);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码下载：<a href="https://github.com/GongchuangSu/Data_Structures_and_Algorithms/tree/master/%E5%9B%BE%28Graph%29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F" target="_blank" rel="external">拓扑排序</a></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>对于一个具有n个顶点e条弧的AOV网来说，将入度为0的顶点入栈的时间复杂度为$O(n)$，之后，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，则整个算法的时间复杂度为$O(n+e)$。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java字符串中如何显示双引号]]></title>
      <url>http://gongchuangsu.com/2016/04/18/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%8F%8C%E5%BC%95%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>使用转义字符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args[0]:"is"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"\"boy\""</span>;                      <span class="comment">//字符串两边含有双引号  </span></span><br><span class="line">        String str2 = <span class="string">"He \"is\" a boy"</span>;              <span class="comment">//字符串中间含有双引号 </span></span><br><span class="line">        String str3 = <span class="string">"He \""</span> + args[<span class="number">0</span>] + <span class="string">"\" a boy"</span>; <span class="comment">//字符串中间含有双引号  </span></span><br><span class="line">        String str4 = <span class="string">"\\boy"</span>;                        <span class="comment">//使用转义字符还可以使字符串包含其他字符  </span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"str1:"</span> + str1);</span><br><span class="line">        System.out.println(<span class="string">"str2:"</span> + str2);</span><br><span class="line">        System.out.println(<span class="string">"str3:"</span> + str3);</span><br><span class="line">        System.out.println(<span class="string">"str4:"</span> + str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span><br><span class="line">str1:"boy"</span><br><span class="line">str2:He "is" a boy</span><br><span class="line">str3:He "is" a boy</span><br><span class="line">str4:\boy</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[弗洛伊德(Floyd)算法]]></title>
      <url>http://gongchuangsu.com/2016/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7(Floyd)%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<center><br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/Floyd.jpg" alt="enter image description here"><br></center>

<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>罗伯特•弗洛伊德（Robert W．Floyd）计算机科学家，图灵奖得主，前后断言法的创始人，堆排序算法和Floyd-Warshall算法的创始人之一。第一次把“不确定性”概念引入程序，并且在分析理论、程序设计语言的逻辑与语义、自动程序验证、自动程序综合、算法分析以及编译器方面做出了巨大贡献，被授予第十三届图灵奖。</p>
<p>Floyd-Warshall算法，中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>弗洛伊德算法的原理是动态规划。假设图G中顶点个数为N，则需要对矩阵S进行N次更新。</p>
<ul>
<li>初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。</li>
<li>接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。</li>
<li>同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。</li>
<li>更新N次之后，操作完成！</li>
</ul>
<h1 id="算法实现-Java"><a href="#算法实现-Java" class="headerlink" title="算法实现(Java)"></a>算法实现(Java)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 最短路径之弗洛伊德(Floyd)算法(即求网图G中各顶点i到其余顶点j的最短路径prev[i][j]及带权长度dist[i][j])</span><br><span class="line"> *              输入 --&gt; G：无向有权图                          </span><br><span class="line"> *              输出 --&gt; 最短距离数组及长度</span><br><span class="line"> * <span class="doctag">@author</span>      GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span>       2016.04.18</span><br><span class="line"> * <span class="doctag">@version</span>     v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Floyd</span> </span>&#123;</span><br><span class="line">    WeightedGraph G;</span><br><span class="line">    <span class="keyword">int</span> vlen;     <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">int</span>[][] prev; <span class="comment">// 前驱顶点数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dist; <span class="comment">// 最短路径数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">(WeightedGraph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.G = G;</span><br><span class="line">        vlen = G.size();</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化前驱顶点数组和最短路径数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                dist[i][j] = G.getWeight(i, j); <span class="comment">// 顶点i到顶点j的路径长度为i到j的权值</span></span><br><span class="line">                prev[i][j] = j;                 <span class="comment">// 顶点i到顶点j的最短距离是经过顶点j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三重循环，找出所有顶点到所有顶点的最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; vlen; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vlen; v++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; vlen; w++) &#123;</span><br><span class="line">                	<span class="comment">// 如果经过k顶点的路径比原两点间路径更短，则将当前两点间权值设为更小的一个</span></span><br><span class="line">                    <span class="keyword">int</span> temp = (dist[v][k] == INF || dist[k][w] == INF) ? INF : (dist[v][k] + dist[k][w]);</span><br><span class="line">                    <span class="keyword">if</span> (dist[v][w] &gt; temp) &#123;</span><br><span class="line">                        dist[v][w] = temp;</span><br><span class="line">                        prev[v][w] = prev[v][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：打印最短路径数组和前驱顶点数组</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Floyd:\n"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"最短路径数组:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++)</span><br><span class="line">                System.out.printf(<span class="string">"%2d "</span>, dist[i][j]);</span><br><span class="line">            System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"前驱顶点数组:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++)</span><br><span class="line">                System.out.printf(<span class="string">"%d "</span>, prev[i][j]);</span><br><span class="line">            System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：根据起点source和终点target输出最短路径</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"(%d,%d)最短路径为：\n"</span>, source, target);</span><br><span class="line">        System.out.printf(<span class="string">"%d"</span>, target);</span><br><span class="line">        <span class="keyword">int</span> k = target;</span><br><span class="line">        <span class="keyword">while</span> (prev[k][source] != k) &#123;</span><br><span class="line">            System.out.printf(<span class="string">" &lt;-- %d"</span>, prev[k][source]);</span><br><span class="line">            k = prev[k][source];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码下载：<a href="https://github.com/GongchuangSu/Data_Structures_and_Algorithms/tree/master/%E5%9B%BE%28Graph%29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%28Floyd%29%E7%AE%97%E6%B3%95" target="_blank" rel="external">弗洛伊德(Floyd)算法</a></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由算法代码中的循环嵌套可得知其算法时间复杂度为$O(n^3)$。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[迪杰斯特拉(Dijkstra)算法]]></title>
      <url>http://gongchuangsu.com/2016/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89(Dijkstra)%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://7xsc5j.com1.z0.glb.clouddn.com/675px-Edsger_Wybe_Dijkstra.jpg" alt="enter image description here"><br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>迪杰斯特拉(Dijkstra)算法是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪杰斯特拉算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul>
<li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</li>
<li>从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</li>
<li>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</li>
<li>重复步骤(2)和(3)，直到遍历完所有顶点。</li>
</ul>
<p>具体流程如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%28Dijkstra%29%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="enter image description here"></p>
<h1 id="算法实现-Java"><a href="#算法实现-Java" class="headerlink" title="算法实现(Java)"></a>算法实现(Java)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 最短路径之迪杰斯特拉(Dijkstra)算法，即计算某顶点到其它各个顶点的最短路径及带权长度</span><br><span class="line"> *              输入 --&gt;    G：无向有权图</span><br><span class="line"> *                      start:起始顶点(即计算顶点s到其它顶点的最短距离)                            </span><br><span class="line"> *              输出 --&gt; 最短距离数组及长度</span><br><span class="line"> * <span class="doctag">@author</span>      GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span>       2016.04.18</span><br><span class="line"> * <span class="doctag">@version</span>     v1.0</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vlen;       <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag; <span class="comment">// flag[i]=true表示顶点start到顶点i的最短路径已求得</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start;      <span class="comment">// 起始顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] prev;     <span class="comment">// 前驱顶点数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dist;     <span class="comment">// 最短路径数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(WeightedGraph G, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        vlen = G.size();</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[vlen];</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="keyword">int</span>[vlen];</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[vlen];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            flag[i] = <span class="keyword">false</span>;</span><br><span class="line">            prev[i] = start;</span><br><span class="line">            dist[i] = G.getWeight(start, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化起始顶点</span></span><br><span class="line">        flag[start] = <span class="keyword">true</span>;</span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始主循环，每次求得起始顶点到其它某个顶点的最短距离</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = INF;                   <span class="comment">// 当前所知离起始顶点的最近距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123; <span class="comment">// 寻找离起始顶点最近的顶点</span></span><br><span class="line">                <span class="keyword">if</span> (flag[j] == <span class="keyword">false</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                    min = dist[j];</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag[k] = <span class="keyword">true</span>; <span class="comment">// 将当前找到的最近的顶点标记</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (G.getWeight(k, j) == INF ? INF : (min + G.getWeight(k, j)));</span><br><span class="line">                <span class="keyword">if</span> (!flag[j] &amp;&amp; (temp &lt; dist[j])) &#123;</span><br><span class="line">                    dist[j] = temp;</span><br><span class="line">                    prev[j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：打印最短路径数组和前驱顶点数组</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Dijkstra(%d):\n"</span>, start);</span><br><span class="line">        System.out.printf(<span class="string">"最短路径数组:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            System.out.printf(<span class="string">"%d "</span>, dist[i]);</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">        System.out.print(<span class="string">"前驱顶点数组:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            System.out.printf(<span class="string">"%d "</span>, prev[i]);</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：根据起点source和终点target输出最短路径</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    	System.out.printf(<span class="string">"(%d,%d)最短路径为：\n"</span> ,start ,target);</span><br><span class="line">    	System.out.printf(<span class="string">"%d"</span>, target);</span><br><span class="line">    	<span class="keyword">int</span> k = target;</span><br><span class="line">    	<span class="keyword">while</span>(prev[k] != k)&#123;</span><br><span class="line">    		System.out.printf(<span class="string">" &lt;-- %d"</span>, prev[k]);</span><br><span class="line">    		k = prev[k];</span><br><span class="line">    	&#125;</span><br><span class="line">    	System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码下载：<a href="https://github.com/GongchuangSu/Data_Structures_and_Algorithms/tree/master/%E5%9B%BE%28Graph%29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%28Dijkstra%29%E7%AE%97%E6%B3%95" target="_blank" rel="external">迪杰斯特拉(Dijkstra)算法</a></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由算法代码中的循环嵌套可得知其算法时间复杂度为$O(n^2)$。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最小生成树]]></title>
      <url>http://gongchuangsu.com/2016/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在含有n个顶点的连通加权无向图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 </p>
<a id="more"></a>
<h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
<ul>
<li>输入：一个加权连通图，其中顶点集合为$V$，边集合为$E$；</li>
<li>初始化：$V<em>{new} = {x}$，其中x为集合V中的任一节点（起始点），$E</em>{new} = {}$；</li>
<li>重复下列操作，直到$V_{new}$ = $V$：<ul>
<li>在集合E中选取权值最小的边（u, v），其中u为集合$V<em>{new}$中的元素，而v则是$V$中没有加入$V</em>{new}$的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>
<li>将v加入集合$V<em>{new}$中，将（u, v）加入集合$E</em>{new}$中；</li>
</ul>
</li>
<li>输出：使用集合$V<em>{new}$和$E</em>{new}$来描述所得到的最小生成树。</li>
</ul>
<p>具体流程如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E6%99%AE%E9%87%8C%E5%A7%86%28Prim%29%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="enter image description here"></p>
<h1 id="算法实现-Java"><a href="#算法实现-Java" class="headerlink" title="算法实现(Java)"></a>算法实现(Java)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 最小生成树之普里姆(Prim)算法</span><br><span class="line"> *              输入 --&gt; 无向有权图和起始顶点下标</span><br><span class="line"> *              输出 --&gt; 打印最小生成树边及其对应的权重</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.04.13</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line">    Edge[] result; <span class="comment">// 最小生成树数组</span></span><br><span class="line">    WeightedGraph G;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(WeightedGraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> Edge[G.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.G = G;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[G.size()];            <span class="comment">// 相关顶点间边的权值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] pred = <span class="keyword">new</span> <span class="keyword">int</span>[G.size()];            <span class="comment">// prim最小生成树结果数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.size()]; <span class="comment">// 顶点访问标记数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dist.length; i++) &#123;</span><br><span class="line">            dist[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[s] = <span class="number">0</span>; <span class="comment">// 将起始点对应的最小权值设置为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dist.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> next = minVertex(dist, visited); <span class="comment">// 在dist中寻找未被访问点所对应的最小权值，并返回该顶点坐标</span></span><br><span class="line">            visited[next] = <span class="keyword">true</span>;                      <span class="comment">// 将该顶点设置为已访问</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] n = G.getNighbors(next);       <span class="comment">// 取得与该顶点相邻接的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n.length; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> v = n[j];</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> d = G.getWeight(next, v);</span><br><span class="line">                <span class="keyword">if</span> (dist[v] &gt; d &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                    dist[v] = d;    <span class="comment">// 将更小权值保存至dist数组中</span></span><br><span class="line">                    pred[v] = next; <span class="comment">// 并将先前结点保存至pred数组中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果保存至最小生成树数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            result[i] = <span class="keyword">new</span> Edge(pred[i + <span class="number">1</span>], i + <span class="number">1</span>, G.getWeight(pred[i + <span class="number">1</span>], i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：在未遍历点中寻找距离最小的点，并返回该点位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minVertex</span><span class="params">(<span class="keyword">int</span>[] dist, <span class="keyword">boolean</span>[] v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> y = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dist.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i] &amp;&amp; dist[i] &lt; x) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">                x = dist[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：边集结构体</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> source;</span><br><span class="line">        <span class="keyword">int</span> target;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> target, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：打印结果</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Prim:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.size() - <span class="number">1</span>; i++)</span><br><span class="line">            System.out.printf(<span class="string">"(%d, %d) %d \n"</span>, result[i].source, result[i].target, result[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码下载：<a href="https://github.com/GongchuangSu/Data_Structures_and_Algorithms/tree/master/%E5%9B%BE%28Graph%29/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%99%AE%E9%87%8C%E5%A7%86%28Prim%29%E7%AE%97%E6%B3%95" target="_blank" rel="external">普里姆(Prim)算法</a></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由算法代码中的循环嵌套可得知其算法时间复杂度为$O(n^2)$。</p>
<h1 id="克鲁斯卡尔-Kruskal"><a href="#克鲁斯卡尔-Kruskal" class="headerlink" title="克鲁斯卡尔(Kruskal)"></a>克鲁斯卡尔(Kruskal)</h1><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><ul>
<li>新建图$G$，$G$中拥有原图中相同的节点，但没有边</li>
<li>将原图中所有的边按权值从小到大排序</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图$G$中不在同一个连通分量中，则添加这条边到图$G$中（不构成环）</li>
<li>重复3，直至图$G$中所有的节点都在同一个连通分量中</li>
</ul>
<p>具体流程如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%28Kruskal%29%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="enter image description here"></p>
<h2 id="为什么这条边一定属于最小树？"><a href="#为什么这条边一定属于最小树？" class="headerlink" title="为什么这条边一定属于最小树？"></a>为什么这条边一定属于最小树？</h2><p>反证法：如果这条边不在最小生成树中，它连接的两个连通分量最终还是要连起来的，通过其他的连法，那么另一种连法与这条边一定构成了环，而环中一定有一条权值大于这条边的边，用这条边将其替换掉，图仍旧保持连通，但总权值减小了。也就是说，如果不选取这条边，最后构成的生成树的总权值一定不会是最小的。</p>
<h2 id="算法实现-Java-1"><a href="#算法实现-Java-1" class="headerlink" title="算法实现(Java)"></a>算法实现(Java)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 最小生成树之克鲁斯卡尔(Kruskal)算法</span><br><span class="line"> *              输入 --&gt; 无向有权图</span><br><span class="line"> *              输出 --&gt; 打印最小生成树边及其对应的权重</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.04.13</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> vlen;      <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="keyword">int</span> elen;      <span class="comment">// 边个数</span></span><br><span class="line">	Edge[] edges;  <span class="comment">// 边集数组</span></span><br><span class="line">	Edge[] result; <span class="comment">// 最小生成树数组</span></span><br><span class="line">	<span class="keyword">int</span>[] parent;  <span class="comment">// 用来判断边与边是否形成环路</span></span><br><span class="line">	WeightedGraph G;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(WeightedGraph G)</span></span>&#123;</span><br><span class="line">	    vlen = G.size();           </span><br><span class="line">	    elen = G.getEdgNum();      </span><br><span class="line">		edges = <span class="keyword">new</span> Edge[elen];</span><br><span class="line">		result = <span class="keyword">new</span> Edge[vlen-<span class="number">1</span>];</span><br><span class="line">		parent = <span class="keyword">new</span> <span class="keyword">int</span>[vlen];</span><br><span class="line">		<span class="keyword">this</span>.G = G;</span><br><span class="line">		</span><br><span class="line">		edges = getEdges();  <span class="comment">// 获取图中所有的边</span></span><br><span class="line">		sortEdges(edges);    <span class="comment">// 对边进行排序</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 初始化数组值为0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)&#123;</span><br><span class="line">			parent[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">				</span><br><span class="line">		<span class="comment">// 循环每一条边</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++)&#123;               </span><br><span class="line">			<span class="keyword">int</span> n = getEnd(parent, edges[i].source);</span><br><span class="line">			<span class="keyword">int</span> m = getEnd(parent, edges[i].target);</span><br><span class="line">			<span class="comment">// 如果n与m不相等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">			<span class="keyword">if</span>(n != m)&#123; </span><br><span class="line">				parent[n] = m;</span><br><span class="line">				result[index++] = <span class="keyword">new</span> Edge(edges[i].source, edges[i].target, edges[i].weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 打印结果</span></span><br><span class="line">		print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 功能：边集结构体</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> source;</span><br><span class="line">		<span class="keyword">int</span> target;</span><br><span class="line">		<span class="keyword">int</span> weight;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> target, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.source = source;</span><br><span class="line">			<span class="keyword">this</span>.target = target;</span><br><span class="line">			<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 功能：获取图中所有的边</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Edge[] getEdges()&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		Edge[] edges = <span class="keyword">new</span> Edge[elen];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vlen; j++)</span><br><span class="line">				<span class="keyword">if</span>(G.getWeight(i, j) != <span class="number">0</span>)</span><br><span class="line">					edges[index++] = <span class="keyword">new</span> Edge(i, j, G.getWeight(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> edges;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 功能：将边按照权值大小由小到大进行排序</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(Edge[] edges)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; elen; j++)</span><br><span class="line">				<span class="keyword">if</span>(edges[i].weight &gt; edges[j].weight)&#123;</span><br><span class="line">					Edge temp = edges[i];</span><br><span class="line">					edges[i] = edges[j];</span><br><span class="line">					edges[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 功能：查找顶点在该最小树中的终点下标</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>( parent[i] &gt; <span class="number">0</span> )</span><br><span class="line">			i = parent[i];</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 功能：打印结果</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"Kruskal:\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen - <span class="number">1</span>; i++)</span><br><span class="line">			System.out.printf(<span class="string">"(%d, %d) %d \n"</span>,result[i].source, result[i].target, result[i].weight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码下载：<a href="https://github.com/GongchuangSu/Data_Structures_and_Algorithms/tree/master/%E5%9B%BE%28Graph%29/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%28Kruskal%29%E7%AE%97%E6%B3%95" target="_blank" rel="external">克鲁斯卡尔(Kruskal)算法</a></p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由算法代码中的循环嵌套可得知其算法时间复杂度为$O(Elog_2E)$，其中$E$为图中的边数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之HashMap和Hashtable的区别]]></title>
      <url>http://gongchuangsu.com/2016/04/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/rifVnSk.jpg" alt=""></p>
<a id="more"></a>
<p><code>HashMap</code>和<code>Hashtable</code>两个类都是实现的Map接口，它们都是保存键值(<code>key-value</code>)对。</p>
<p><strong>注意</strong>：它们都是通过拉链法来解决哈希冲突的。<br>可以从以下几个方面来比较两者的不同：</p>
<h1 id="继承的父类不同"><a href="#继承的父类不同" class="headerlink" title="继承的父类不同"></a>继承的父类不同</h1><p><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了<code>Map</code>接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">	<span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">	<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">	<span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">	<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h1 id="线程安全性不同"><a href="#线程安全性不同" class="headerlink" title="线程安全性不同"></a>线程安全性不同</h1><p><code>Hashtable</code> 中的方法是<code>Synchronize</code>的，而<code>HashMap</code>中的方法在缺省情况下是非<code>Synchronize</code>的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，不需要自己为它的方法实现同步，但使用<code>HashMap</code>时就必须要自己增加同步处理。这意味着<code>Hashtable</code>是线程安全的，多个线程可以共享一个<code>Hashtable</code>；而如果没有正确的同步的话，多个线程是不能共享<code>HashMap</code>的。<code>Java 5</code>提供了<code>ConcurrentHashMap</code>，它是<code>Hashtable</code>的替代，比<code>Hashtable</code>的扩展性更好。<br><code>HashMap</code>可以通过<code>synchronizedMap(HashMap)</code>方法进行同步。具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSynchronization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create map</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// populate the map</span></span><br><span class="line">        map.put(<span class="string">"1"</span>,<span class="string">"ALIVE "</span>);</span><br><span class="line">        map.put(<span class="string">"2"</span>,<span class="string">"IS"</span>);</span><br><span class="line">        map.put(<span class="string">"3"</span>,<span class="string">"AWESOME"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a synchronized map</span></span><br><span class="line">        Map&lt;String,String&gt; syncMap = Collections.synchronizedMap(map);          </span><br><span class="line">        System.out.println(<span class="string">"Synchronized map :"</span>+syncMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="是否提供contains方法"><a href="#是否提供contains方法" class="headerlink" title="是否提供contains方法"></a>是否提供contains方法</h1><p><code>HashMap</code>把<code>Hashtable</code>的<code>contains</code>方法去掉了，改成<code>containsValue</code>和<code>containsKey</code>，因为<code>contains</code>方法容易让人引起误解。<br><code>Hashtable</code>则保留了<code>contains</code>，<code>containsValue</code>和<code>containsKey</code>三个方法，其中<code>contains</code>和<code>containsValue</code>功能相同。</p>
<h1 id="key和value是否允许null值"><a href="#key和value是否允许null值" class="headerlink" title="key和value是否允许null值"></a>key和value是否允许null值</h1><p>其中<code>key</code>和<code>value</code>都是对象，并且不能包含重复<code>key</code>，但可以包含重复的<code>value</code>。<br><code>Hashtable</code>中，<code>key</code>和<code>value</code>都不允许出现<code>null</code>值。<br><code>HashMap</code>中，<code>null</code>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<code>null</code>。当<code>get()</code>方法返回<code>null</code>值时，可能是 <code>HashMap</code>中没有该键，也可能使该键所对应的值为<code>null</code>。因此，在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键， 而应该用<code>containsKey()</code>方法来判断。</p>
<h1 id="两个遍历方式的内部实现上不同"><a href="#两个遍历方式的内部实现上不同" class="headerlink" title="两个遍历方式的内部实现上不同"></a>两个遍历方式的内部实现上不同</h1><p><code>Hashtable</code>、<code>HashMap</code>都使用了<code>Iterator</code>。而由于历史原因，<code>Hashtable</code>还使用了<code>Enumeration</code>的方式 。</p>
<h1 id="hash值不同"><a href="#hash值不同" class="headerlink" title="hash值不同"></a>hash值不同</h1><p>哈希值的使用不同，<code>Hashtable</code>直接使用对象的<code>hashCode</code>。而<code>HashMap</code>重新计算<code>hash</code>值。</p>
<h1 id="内部实现使用的数组初始化和扩容方式不同"><a href="#内部实现使用的数组初始化和扩容方式不同" class="headerlink" title="内部实现使用的数组初始化和扩容方式不同"></a>内部实现使用的数组初始化和扩容方式不同</h1><p><code>Hashtable</code>中<code>hash</code>数组默认大小是<code>11</code>，增加的方式是 <code>old*2+1</code>。<code>HashMap</code>中<code>hash</code>数组的默认大小是<code>16</code>，而且一定是<code>2</code>的指数。</p>
<h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><p><code>HashMap</code>只支持<code>Iterator</code>(迭代器)遍历。而<code>Hashtable</code>支持<code>Iterator</code>(迭代器)和<code>Enumeration</code>(枚举器)两种方式遍历。</p>
<h2 id="HashMap遍历方式"><a href="#HashMap遍历方式" class="headerlink" title="HashMap遍历方式"></a>HashMap遍历方式</h2><p><strong>遍历HashMap的键值对</strong><br>第一步，通过<code>entrySet()</code>方法获取<code>HashMap</code>的“键值对”的<code>Set</code>集合<br>第二步，通过<code>Iterator</code>迭代器遍历“第一步”得到的<code>Set</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是HashMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)entry.getKey();</span><br><span class="line">    <span class="comment">// 获取value</span></span><br><span class="line">    integ = (Integer)entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>遍历HashMap的键</strong><br>第一步：通过<code>keySet()</code>方法获取<code>HashMap</code>的“键”的<code>Set</code>集合<br>第二步，通过<code>Iterator</code>迭代器遍历“第一步”得到的<code>Set</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是HashMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">String key = <span class="keyword">null</span>;</span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">    <span class="comment">// 根据key，获取value</span></span><br><span class="line">    <span class="comment">//integ = (Integer)map.get(key);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>遍历HashMap的值</strong><br>第一步：通过<code>values()</code>方法获取<code>HashMap</code>的“值”的<code>Collection</code>集合<br>第二步，通过<code>Iterator</code>迭代器遍历“第一步”得到的<code>Collection</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是HashMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Collection c = map.values();</span><br><span class="line">Iterator iter= c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Hashtable遍历方式"><a href="#Hashtable遍历方式" class="headerlink" title="Hashtable遍历方式"></a>Hashtable遍历方式</h2><p><strong>遍历Hashtable的键值对</strong><br>第一步：通过<code>entrySet()</code>获取<code>Hashtable</code>的“键值对”的<code>Set</code>集合<br>第二步：通过Iterator迭代器遍历“第一步”得到的<code>Set</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = table.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)entry.getKey();</span><br><span class="line">    <span class="comment">// 获取value</span></span><br><span class="line">    integ = (Integer)entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>通过Iterator遍历Hashtable的键</strong><br>第一步：通过<code>keySet()</code>获取<code>Hashtable</code>的“键”的<code>Set</code>集合<br>第二步：通过<code>Iterator</code>迭代器遍历“第一步”得到的<code>Set</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">String key = <span class="keyword">null</span>;</span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = table.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">    <span class="comment">// 根据key，获取value</span></span><br><span class="line">    <span class="comment">//integ = (Integer)table.get(key);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>通过Iterator遍历Hashtable的值</strong><br>第一步：通过<code>value()</code>获取<code>Hashtable</code>的“值”的<code>Collection</code>集合<br>第二步：通过<code>Iterator</code>迭代器遍历“第一步”得到的<code>Collection</code>集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Collection c = table.values();</span><br><span class="line">Iterator iter= c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>通过Enumeration遍历Hashtable的键</strong><br>第一步：通过<code>keys()</code>获取<code>Hashtable</code>的集合<br>第二步：通过<code>Enumeration</code>遍历“第一步”得到的集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enumeration enu = table.keys();</span><br><span class="line"><span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">    System.out.println(enu.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>通过Enumeration遍历Hashtable的值</strong><br>第一步：通过<code>elements()</code>获取<code>Hashtable</code>的集合<br>第二步：通过<code>Enumeration</code>遍历“第一步”得到的集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enumeration enu = table.elements();</span><br><span class="line"><span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">    System.out.println(enu.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h1><p>1.HashMap可以插入null的key或value，但只能有一个null的key，可以有多个null的value；HashMap插入的时候，会先检查是否有相同的key，如果没有，则直接插入；如果有，则覆盖旧的value。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap map=<span class="keyword">new</span> java.util.HashMap(); </span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="keyword">null</span>);      </span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"Jack"</span>);</span><br><span class="line">System.out.println(map.size());</span><br></pre></td></tr></table></figure></p>
<p>输出应该为1。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之访问权限修饰词]]></title>
      <url>http://gongchuangsu.com/2016/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>所有事物都具有某种形式的访问权限控制。Java中存在以下四种形式的权限修饰词：</p>
<ul>
<li><code>public</code></li>
<li><code>private</code></li>
<li><code>protected</code></li>
<li>包访问权限(friendly)<br><code>public</code>、<code>protected</code>和<code>private</code>这几个Java访问权限修饰词在使用时，是置于类中每个成员的定义之前的——无论它是一个域还是一个方法。<br>如果不提供任何访问修饰词，则意味着它是“包访问权限”。一般默认访问权限就是“包访问权限”。</li>
</ul>
<a id="more"></a>
<h1 id="public接口访问权限"><a href="#public接口访问权限" class="headerlink" title="public接口访问权限"></a>public接口访问权限</h1><p>使用关键字<code>public</code>，就意味着该成员变量和方法对每个人都是可用的。<br>例：<br>先创建一个<code>Cookie</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access.dessert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"Cookie constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bite</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"bite"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建一个使用<code>Cookie</code>类的程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.dessert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinner</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cookie x = <span class="keyword">new</span> Cookie();</span><br><span class="line">    <span class="comment">//! x.bite(); // Can't access</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">Cookie constructor</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从上面程序可以看到，由于<code>bite()</code>没有任何访问修饰词，故其默认为包访问权限，即只向在<code>dessert</code>包中的类提供访问权，所以<code>bite()</code>在<code>Dinner.java</code>之中是无法访问的。</p>
<h1 id="private你无法访问"><a href="#private你无法访问" class="headerlink" title="private你无法访问"></a>private你无法访问</h1><p>使用关键字<code>private</code>，就意味着，除了包含该成员的类外，其他任何类都无法访问这个成员。<br>默认的包访问权限通常已经提供了充足的隐藏措施（使用类的客户端程序员是无法访问包访问权限成员的）。而<code>private</code>在多线程环境下将会有更重要的应用。<br>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sundae</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Sundae <span class="title">makeASundae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sundae();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! Sundae x = new Sundae();</span></span><br><span class="line">    Sundae x = Sundae.makeASundae();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能你想控制如何创建对象，又想阻止别人直接访问某个特定的构造器。则可以用<code>private</code>修饰构造函数，这样就禁止通过构造函数来创建<code>Sundae</code>对象，必须通过<code>makeASundae()</code>方法来达到此目的。</p>
<h1 id="protected继承访问权限"><a href="#protected继承访问权限" class="headerlink" title="protected继承访问权限"></a>protected继承访问权限</h1><p>使用关键字<code>protected</code>，就意味着基类的protected成员只有派生类能够访问（同一包内的其他类也可以访问）。</p>
<h1 id="friendly包访问权限"><a href="#friendly包访问权限" class="headerlink" title="friendly包访问权限"></a>friendly包访问权限</h1><p>默认访问权限没有关键字，就意味着是包访问权限，也就是当前包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类却没有访问权限。</p>
<p><img src="http://i.imgur.com/rFVzUDs.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之堆排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<h1 id="堆排序简介"><a href="#堆排序简介" class="headerlink" title="堆排序简介"></a>堆排序简介</h1><p>堆排序（Heap Sort），是指利用堆这种数据结构所设计的一种排序算法。<br><strong>堆排序的基本思想</strong>：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它与末尾元素交换，此时末尾元素就是最大值，然后将剩余的<code>n-1</code>个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列。</p>
<a id="more"></a>
<h1 id="堆结点的访问"><a href="#堆结点的访问" class="headerlink" title="堆结点的访问"></a>堆结点的访问</h1><p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形下：</p>
<ul>
<li>父节点i的左子节点在位置(2*i+1)</li>
<li>父节点i的右子节点在位置(2*i+2)</li>
<li>子节点i的父节点在位置floor((i-1)/2)</li>
</ul>
<h1 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h1><p>具体排序过程如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作堆排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.04.01</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        heapSort(sqList);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：对顺序表L进行堆排序</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 第一步：将sqList构建成一个大顶堆</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = (sqList.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            heapAdjust(sqList, i, sqList.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 第二步：将堆顶记录和当前未经排序子序列的最后一个记录交换，并且再调整其成为大顶堆</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = sqList.length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            sqList[i] = returnFirst(sqList[<span class="number">1</span>], sqList[<span class="number">1</span>] = sqList[i]);</span><br><span class="line">            heapAdjust(sqList, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：已知sqList[s..m]中记录的关键字除sqList[s]外均满足堆的定义</span><br><span class="line">     *       该函数调整sqList[s]的关键字，使sqList[s..m]成为一个大顶堆</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] sqList, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, j;</span><br><span class="line">        temp = sqList[s];</span><br><span class="line">        <span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; m &amp;&amp; sqList[j] &lt; sqList[j + <span class="number">1</span>])</span><br><span class="line">                ++j; <span class="comment">// j为关键字中较大的记录的下标</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= sqList[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            sqList[s] = sqList[j];</span><br><span class="line">            s = j;</span><br><span class="line">        &#125;</span><br><span class="line">        sqList[s] = temp; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：用于两个数据的交换，相当于C/C++中的swap()函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">returnFirst</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为$\Theta(nlogn)$</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很明显，其空间复杂度为$\Theta(1)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>由于记录的比较和交换是跳跃式的，所以堆排序是不稳定的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之希尔排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<h1 id="希尔排序简介"><a href="#希尔排序简介" class="headerlink" title="希尔排序简介"></a>希尔排序简介</h1><p>希尔排序（Shell Sort），也称递减增量排序算法，是<code>Donald Shell</code>在1959年提出来的一种排序算法。它是插入排序的一种更高效的改进版本。</p>
<a id="more"></a>
<h1 id="希尔排序思想"><a href="#希尔排序思想" class="headerlink" title="希尔排序思想"></a>希尔排序思想</h1><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已经排好的了。</p>
<h1 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h1><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。</p>
<h1 id="希尔排序过程"><a href="#希尔排序过程" class="headerlink" title="希尔排序过程"></a>希尔排序过程</h1><p>具体排序过程如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作希尔排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.04.01</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        shellSort(sqList);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：希尔排序</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> increment = sqList.length - <span class="number">1</span>;</span><br><span class="line">        do &#123;</span><br><span class="line">        	<span class="comment">// 增量序列</span></span><br><span class="line">            increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = increment + <span class="number">1</span>; i &lt; sqList.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sqList[i] &lt; sqList[i - increment]) &#123;</span><br><span class="line">                	<span class="comment">// 需将sqList[i]插入有序增量子表</span></span><br><span class="line">                    sqList[<span class="number">0</span>] = sqList[i]; <span class="comment">// 暂存sqList[0]</span></span><br><span class="line">                    <span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">                    <span class="keyword">for</span> (j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; sqList[<span class="number">0</span>] &lt; sqList[j]; j -= increment)</span><br><span class="line">                        sqList[j + increment] = sqList[j];</span><br><span class="line">                    sqList[j + increment] = sqList[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在最好的情况下，其时间复杂度为$\Theta(n^1.3)$；<br>在最坏的情况下，其时间复杂度为$\Theta(n^2)$。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很明显，其空间复杂度为$\Theta(1)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>希尔排序是不稳定的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之简单选择排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<h1 id="选择排序简介"><a href="#选择排序简介" class="headerlink" title="选择排序简介"></a>选择排序简介</h1><p>选择排序（Selection Sort）是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<a id="more"></a>
<h1 id="简单选择排序过程"><a href="#简单选择排序过程" class="headerlink" title="简单选择排序过程"></a>简单选择排序过程</h1><p>简单排序过程很简单，其具体流程如下图所示：</p>
<p><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作简单选择排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.03.29</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        selectSort(sqList);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：简单选择排序</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, min;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; sqList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= sqList.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果有小于当前最小值的关键字，则将此关键字的下标赋值给min</span></span><br><span class="line">                <span class="keyword">if</span> (sqList[min] &gt; sqList[j])</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果min不等于i，说明找到比sqList[i]更小的值，则进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (i != min)</span><br><span class="line">                sqList[i] = returnFirst(sqList[min], sqList[min] = sqList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：用于两个数据的交换，相当于C/C++中的swap()函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">returnFirst</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>简单选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。<br>就<strong>交换次数</strong>而言，在最好情况下，交换次数为<code>0</code>；在最坏的情况下，交换次数为<code>n-1</code>。<br>无论最好最坏情况，其<strong>比较次数</strong>都是一样多的，基于最终的排序时间是比较和交换的次数总和，其时间复杂度为$\Theta(n^2)$。<br>在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很明显，其空间复杂度为$\Theta(1)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>选择排序是稳定的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之冒泡排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<h1 id="冒泡排序简介"><a href="#冒泡排序简介" class="headerlink" title="冒泡排序简介"></a>冒泡排序简介</h1><p><strong>冒泡排序（Bubble Sort）</strong>是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果反序则交换，重复地进行直到不再需要交换。</p>
<a id="more"></a>
<h1 id="冒泡排序过程"><a href="#冒泡排序过程" class="headerlink" title="冒泡排序过程"></a>冒泡排序过程</h1><ul>
<li>1.比较相邻的元素，如果第一个比第二个大，就进行交换</li>
<li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数</li>
<li>3.针对所有的元素重复以上的步骤，除了最后一个</li>
<li>4.持续每次对越来越少的元素重复上面的步骤，知道没有任何一对数字需要比较<br>仔细分析，这种算法的效率是非常低的。我们可进行简单的改进，元素交换不限于相邻的两个元素，部分流程图如下图所示：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></li>
</ul>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作冒泡排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.03.29</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        bubbleSort(sqList);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：冒泡排序法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; sqList.length - <span class="number">1</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = sqList.length - <span class="number">2</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sqList[j] &gt; sqList[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换sqList[j]和sqList[j+1]的值</span></span><br><span class="line">                    sqList[j] = returnFirst(sqList[j + <span class="number">1</span>], sqList[j + <span class="number">1</span>] = sqList[j]);</span><br><span class="line">                    <span class="comment">// 如果有数据交换，则flag为true</span></span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：用于两个数据的交换，相当于C/C++中的swap()函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">returnFirst</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在最好情况下，即要排序的数组本身就是有序的，则其时间复杂度为$\Theta(n)$；<br>在最坏的情况下，即要排序的数组是逆序的，其时间复杂度为$\Theta(n^2)$。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很明显，其空间复杂度为$\Theta(1)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>冒泡排序是稳定的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之直接插入排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<h1 id="直接插入排序简介"><a href="#直接插入排序简介" class="headerlink" title="直接插入排序简介"></a>直接插入排序简介</h1><p><strong>直接插入排序</strong>（Insertion Sort）是一种简单直观的排序算法。其工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<a id="more"></a>
<h1 id="直接插入排序过程"><a href="#直接插入排序过程" class="headerlink" title="直接插入排序过程"></a>直接插入排序过程</h1><ul>
<li>1.从第一个元素开始，该元素可以认为已经被排序</li>
<li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>3.如果该元素（已排序）大于新元素，将该元素移到下一个位置</li>
<li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>5.将新元素插入到该位置后</li>
<li>6.重复步骤2~5</li>
</ul>
<p><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作直接插入排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.03.28</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        insertSort(sqList);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * 功能：直接插入排序法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= sqList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sqList[i] &lt; sqList[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                sqList[<span class="number">0</span>] = sqList[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; sqList[j] &gt; sqList[<span class="number">0</span>]; j--)</span><br><span class="line">                    sqList[j + <span class="number">1</span>] = sqList[j];</span><br><span class="line">                sqList[j + <span class="number">1</span>] = sqList[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在最好情况下，即要排序的数组本身就是有序的，则其时间复杂度为$\Theta(n)$；<br>在最坏的情况下，其时间复杂度为$\Theta(n^2)$。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很明显，其空间复杂度为$\Theta(1)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>直接插入排序是稳定的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之快速排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center">There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.<br>—— C.A.R. Hoare (Designer of QuickSort)</blockquote>

<h1 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h1><p>快速排序（Quick Sort）是由东尼·霍尔所发明的一种排序算法，被列为20世纪十大算法之一。其发明者——东尼·霍尔（Tony Hoare），出生于斯里兰卡可伦坡，英国计算机科学家，图灵奖得主。</p>
<a id="more"></a>
<h1 id="快速排序思想"><a href="#快速排序思想" class="headerlink" title="快速排序思想"></a>快速排序思想</h1><p><strong>快速排序（Quick Sort）</strong>的基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
<h1 id="快速排序过程"><a href="#快速排序过程" class="headerlink" title="快速排序过程"></a>快速排序过程</h1><p>假设需要排序的数组为<code>sqList = {1000, 50, 10, 90, 30, 70, 40, 80, 60, 20}</code><br>快速排序最关键的<code>partition</code>函数：先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它的左边的值都比它小，右边的值都比它大，这样的关键字称为枢轴（<code>pivot</code>）。<br>在选取枢轴时，我们可通过<strong>三数取中法</strong>进行优化，即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可随机选取。<br><strong>快速排序过程示意图：</strong><br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png" alt=""><br>上面示意图只是一个递归过程，进行多次即可得到有序的数组。<br><strong><code>partition</code>函数具体实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能：选取关键点，使其成为枢轴，并返回其所在位置</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] sqList, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;</span><br><span class="line">    <span class="comment">// 三数取中</span></span><br><span class="line">    <span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sqList[low] &gt; sqList[high])</span><br><span class="line">        sqList[low] = returnFirst(sqList[high], sqList[high] = sqList[low]);</span><br><span class="line">    <span class="keyword">if</span> (sqList[m] &gt; sqList[high])</span><br><span class="line">        sqList[m] = returnFirst(sqList[high], sqList[high] = sqList[m]);</span><br><span class="line">    <span class="keyword">if</span> (sqList[m] &gt; sqList[low])</span><br><span class="line">        sqList[low] = returnFirst(sqList[m], sqList[m] = sqList[low]);</span><br><span class="line">    pivotkey = sqList[low];</span><br><span class="line">    sqList[<span class="number">0</span>] = pivotkey; <span class="comment">// 将枢轴关键字备份到sqList[0]</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; sqList[high] &gt;= pivotkey)</span><br><span class="line">            high--;</span><br><span class="line">        sqList[low] = sqList[high]; <span class="comment">// 采用替换而不是交换的方式进行操作，将比枢轴记录小的记录替换到低端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; sqList[low] &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        sqList[high] = sqList[low]; <span class="comment">// 采用替换而不是交换的方式进行操作，将比枢轴记录					</span></span><br><span class="line">    &#125;</span><br><span class="line">    sqList[low] = sqList[<span class="number">0</span>]; <span class="comment">// 将枢轴数值替换回sqList[low]	</span></span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>快速排序的时间性能取决于快速排序递归的深度。<br>在最优情况下，<code>partition</code>每次都划分得很均匀，则其时间复杂度为$\Theta(n\log n)$；<br>在最坏情况下，待排序的序列为正序或逆序，则其时间复杂度为$\Theta(n^2)$。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>在最优情况下，其空间复杂度为$\Theta(\log n)$。<br>在最坏情况下，其空间复杂度为$\Theta(n)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>由于关键字的比较是跳跃性的，所以快速排序是一种不稳定的排序方法。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表L作快速排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.03.28</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH_INSERT_SORT = <span class="number">7</span>; <span class="comment">// 数组长度阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// sqList[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] sqList = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        QSort(sqList, <span class="number">1</span>, sqList.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 输出打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sqList.length; i++)</span><br><span class="line">            System.out.println(String.valueOf(sqList[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>[] sqList, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot;</span><br><span class="line">        <span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123; <span class="comment">// 当high - low大于常数时用快速排序</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="comment">// 将sqList[low...high]一分为二，并算出枢轴值pivot</span></span><br><span class="line">                pivot = partition(sqList, low, high);</span><br><span class="line">                QSort(sqList, low, pivot - <span class="number">1</span>); <span class="comment">// 对低子表递归排序</span></span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当high - low小于等于常数时用直接插入排序</span></span><br><span class="line">            insertSort(sqList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：选取关键点，使其成为枢轴，并返回其所在位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] sqList, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotkey;</span><br><span class="line">        <span class="comment">// 三数取中</span></span><br><span class="line">        <span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (sqList[low] &gt; sqList[high])</span><br><span class="line">            sqList[low] = returnFirst(sqList[high], sqList[high] = sqList[low]);</span><br><span class="line">        <span class="keyword">if</span> (sqList[m] &gt; sqList[high])</span><br><span class="line">            sqList[m] = returnFirst(sqList[high], sqList[high] = sqList[m]);</span><br><span class="line">        <span class="keyword">if</span> (sqList[m] &gt; sqList[low])</span><br><span class="line">            sqList[low] = returnFirst(sqList[m], sqList[m] = sqList[low]);</span><br><span class="line">        pivotkey = sqList[low];</span><br><span class="line">        sqList[<span class="number">0</span>] = pivotkey; <span class="comment">// 将枢轴关键字备份到sqList[0]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; sqList[high] &gt;= pivotkey)</span><br><span class="line">                high--;</span><br><span class="line">            sqList[low] = sqList[high]; <span class="comment">// 采用替换而不是交换的方式进行操作，将比枢轴记录小的记录替换到低端</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; sqList[low] &lt;= pivotkey)</span><br><span class="line">                low++;</span><br><span class="line">            sqList[high] = sqList[low]; <span class="comment">// 采用替换而不是交换的方式进行操作，将比枢轴记录					</span></span><br><span class="line">        &#125;</span><br><span class="line">        sqList[low] = sqList[<span class="number">0</span>]; <span class="comment">// 将枢轴数值替换回sqList[low]	</span></span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：直接插入排序法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] sqList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= sqList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sqList[i] &lt; sqList[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                sqList[<span class="number">0</span>] = sqList[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; sqList[j] &gt; sqList[<span class="number">0</span>]; j--)</span><br><span class="line">                    sqList[j + <span class="number">1</span>] = sqList[j];</span><br><span class="line">                sqList[j + <span class="number">1</span>] = sqList[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：用于两个数据的交换，相当于C/C++中的swap()函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">returnFirst</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之归并排序(Java)]]></title>
      <url>http://gongchuangsu.com/2016/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Java)/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center">若人们不相信数学简单，只因他们未意识到生命之复杂。<br>—— 约翰·冯·诺伊曼</blockquote>

<h1 id="归并排序简介"><a href="#归并排序简介" class="headerlink" title="归并排序简介"></a>归并排序简介</h1><p>归并排序(Merge Sort)，是创建在归并操作上的一种有效的排序算法。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<a id="more"></a>
<h2 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h2><p>归并操作(merge)，也叫归并算法，是指将两个<strong>已经排序</strong>的序列合并成一个序列的操作。<br>归并操作有两种方法可实现：<strong>迭代法</strong>和<strong>递归法</strong>。本篇主要介绍性能最优的迭代法。</p>
<h2 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a>归并排序思想</h2><p>假设初始序列含有n个记录，则可以看成n个有序的子序列，每个子序列的长度为1,然后两两归并，得到$\lceil n/2 \rceil$（$\lceil x \rceil$表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，···，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</p>
<h1 id="归并排序过程"><a href="#归并排序过程" class="headerlink" title="归并排序过程"></a>归并排序过程</h1><p>具体过程示意图：<br><img src="http://7xsc5j.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B.png" alt=""></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@description</span> 对顺序表作归并非递归排序</span><br><span class="line"> * <span class="doctag">@author</span> GongchuangSu</span><br><span class="line"> * <span class="doctag">@since</span> 2016.03.27</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// SR[0]和TR[0]用作哨兵或临时变量</span></span><br><span class="line">        <span class="keyword">int</span>[] SR = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] TR = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        TR[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; SR.length) &#123;</span><br><span class="line">            MergePass(SR, TR, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">            MergePass(TR, SR, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TR.length; i++) &#123;</span><br><span class="line">            System.out.println( String.valueOf(SR[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：将SR[]中相邻长度为s的子序列两两归并到TR[]</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n - <span class="number">2</span> * s + <span class="number">1</span>) &#123;</span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);</span><br><span class="line">            i = i + <span class="number">2</span> * s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - s + <span class="number">1</span>) <span class="comment">// 归并最后两个序列</span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 若最后只剩下单个子序列</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; j++)</span><br><span class="line">                TR[j] = SR[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 功能：将有序的SR[i...m]和SR[m+1...n]归并为有序的TR[i...n]</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, l;</span><br><span class="line">        <span class="comment">// 将SR中记录由小到大归并入TR</span></span><br><span class="line">        <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (SR[i] &lt; SR[j]) &#123;</span><br><span class="line">                TR[k] = SR[i];</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR[k] = SR[j];</span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的SR[i...m]复制到TR</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line">                TR[k + l] = SR[i + l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的SR[j..n]复制到TR</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">                TR[k + l] = SR[j + l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>对于递归法，总的时间复杂度为$\Theta(n\log n)$，而且是其最好、最坏、平均的时间性能。<br>对于迭代法，其最优时间复杂度为$\Theta(n)$。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>对于递归法，其空间复杂度为$\Theta(n + \log n)$。<br>对于迭代法，其空间复杂度为$\Theta(n)$。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>归并排序是一种稳定的排序方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字节序（Endianness）]]></title>
      <url>http://gongchuangsu.com/2016/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88Endianness%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote class="blockquote-center">“endian”一词来源于乔纳森·斯威夫特的小说格列佛游记。小说中，小人国为水煮蛋该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开而争论，争论的双方分别被称为“大端派”和“小端派”。</blockquote>

<p>字节序，又称端序，尾序（Endianness）。在计算机科学邻域，是跨越多字节的程序对象的存储规则。</p>
<a id="more"></a>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如，在C语言中，一个类型为<code>int</code>的变量<code>x</code>地址为<code>0x100</code>，那么，x的四个字节将被存储在存储器的<code>0x100，0x101, 0x102, 0x103</code>位置。而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称<strong>小端序</strong>；反之则称<strong>大端序</strong>。<br>下面以内存中0x0A0B0C0D的存放方式为例，分别有以下几种方式：</p>
<h1 id="大端序（big-endian）"><a href="#大端序（big-endian）" class="headerlink" title="大端序（big-endian）"></a>大端序（big-endian）</h1><p><strong>数据以8bit为单位:</strong><br><img src="http://i.imgur.com/iiJmkVI.png" alt=""><br><img src="http://i.imgur.com/JJXwuof.png" alt=""></p>
<h1 id="小端序（little-endian）"><a href="#小端序（little-endian）" class="headerlink" title="小端序（little-endian）"></a>小端序（little-endian）</h1><p><strong>数据以8bit为单位:</strong><br><img src="http://i.imgur.com/h5sdFfY.png" alt=""><br><img src="http://i.imgur.com/xbTT7mt.png" alt=""></p>
<h1 id="大端小端转换方法"><a href="#大端小端转换方法" class="headerlink" title="大端小端转换方法"></a>大端小端转换方法</h1><p>Big-Endian转换成Little-Endian:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BigtoLittle16(A) ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))</span><br><span class="line">#define BigtoLittle32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \</span><br><span class="line">             (((uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))</span><br></pre></td></tr></table></figure></p>
<h1 id="大端小端检测方法"><a href="#大端小端检测方法" class="headerlink" title="大端小端检测方法"></a>大端小端检测方法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;i;   </span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="number">1</span>)     </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Little Endian"</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Big Endian"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VS2013程序打包部署详细图解]]></title>
      <url>http://gongchuangsu.com/2016/03/20/Visual%20Studio/VS2013%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>FILE –&gt; New –&gt; Project，如下图所示：<br><img src="http://i.imgur.com/Z06fAY4.png" alt=""></p>
<p><strong>注意：</strong>如果 <code>InstallShield Limited Edition Project</code> 显示灰色，说明还没有安装，这时点击灰色的点进行下载安装。</p>
<a id="more"></a>
<p>点击<code>OK</code>后，出现如下界面：<br><img src="http://i.imgur.com/lph5zkD.png" alt=""></p>
<h1 id="基本设置（语言、字体）"><a href="#基本设置（语言、字体）" class="headerlink" title="基本设置（语言、字体）"></a>基本设置（语言、字体）</h1><p><img src="http://i.imgur.com/lulrspD.png" alt=""><br><img src="http://i.imgur.com/Qc5Z3Rm.png" alt=""></p>
<h1 id="添加-NET-Framework-package"><a href="#添加-NET-Framework-package" class="headerlink" title="添加 .NET Framework package"></a>添加 .NET Framework package</h1><p><img src="http://i.imgur.com/EWaCLkt.png" alt=""></p>
<h1 id="添加程序文件"><a href="#添加程序文件" class="headerlink" title="添加程序文件"></a>添加程序文件</h1><p>首先看看程序文件bin/Release路径下有没有文件，如果没有，需要现将解决方案改为Release模式重新生成解决方案。然后将Release下生成的所有文件添加进去。<br><img src="http://i.imgur.com/p6Sqs62.png" alt=""></p>
<h1 id="设置快捷方式"><a href="#设置快捷方式" class="headerlink" title="设置快捷方式"></a>设置快捷方式</h1><p><img src="http://i.imgur.com/5QYBLMg.png" alt=""></p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>设置Setup.exe方式<br><img src="http://i.imgur.com/96dC5IJ.png" alt=""></p>
<p>解决方案设置为SingleImage（生成单一映像），重新生成解决方案即可。<br><img src="http://i.imgur.com/O8SENTV.png" alt=""></p>
<p>生成的安装文件在<code>Express\SingleImage\DiskImages\DISK1</code>路径下，点击安装即可。</p>
<p>注意：如果需要在XP上运行，需要安装<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=25150" target="_blank" rel="external">Microsoft .NET Framework 3.5 Service Pack 1</a>（XP系统支持的最高版本）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://gongchuangsu.com/2016/03/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[十字链表（Java）]]></title>
      <url>http://gongchuangsu.com/2016/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88Java%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，想要了解入度情况就必须要遍历整个图才能知道。反之也一样。那么，这一节就介绍有向图的一种存储方法，它能将邻接表和逆邻接表结合起来 —— <strong>十字链表</strong>。</p>
<a id="more"></a>
<h1 id="十字链表存储结构"><a href="#十字链表存储结构" class="headerlink" title="十字链表存储结构"></a>十字链表存储结构</h1><p><strong>定义顶点表结点结构：</strong><br><img src="http://i.imgur.com/j7bDQoN.png" alt="顶点表结点结构"><br>其中，firstIn表示入边表头指针，指向该顶点的入边表中第一个结点，firstOut表示出边表头指针，指向该顶点的出边表中的第一个结点。</p>
<p><strong>定义边表结点结构：</strong><br><img src="http://i.imgur.com/svRaLmr.png" alt=""><br>其中，tailvex是指弧起点在顶点表的下标，headvex是弧终点在顶点表的下标，headlink是指入边表指针域，指向终点相同的下一条边，tailvex是指边表指针域，指向起点相同的下一条边。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 作者：GongchuangSu</span><br><span class="line"> * 时间：2016.03.12</span><br><span class="line"> * 功能：十字链表有向图（已提供参数）</span><br><span class="line"> * 输入说明：vexs  --  顶点数组</span><br><span class="line"> * 		   edges  --  边数组</span><br><span class="line"> * 输出说明：十字链表（即对每个顶点vi都建立一个链接为vi为弧尾和弧头的表）</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OListDG</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vlen; <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> elen; <span class="comment">// 边个数</span></span><br><span class="line">    VertexNode[] vertexNodeList; <span class="comment">// 顶点数组</span></span><br><span class="line">    EdgeNode edgeNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * <span class="doctag">@param</span> vexs</span><br><span class="line">     * <span class="doctag">@param</span> edges</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OListDG</span><span class="params">(<span class="keyword">char</span>[] vexs, <span class="keyword">char</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        vlen = vexs.length;</span><br><span class="line">        elen = edges.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化顶点,建立顶点表</span></span><br><span class="line">        vertexNodeList = <span class="keyword">new</span> VertexNode[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            vertexNodeList[i] = <span class="keyword">new</span> VertexNode();</span><br><span class="line">            vertexNodeList[i].vertex = vexs[i];</span><br><span class="line">            vertexNodeList[i].firstIn = <span class="keyword">null</span>;</span><br><span class="line">            vertexNodeList[i].firstOut = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化边，利用头插法建立十字链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++) &#123;</span><br><span class="line">            EdgeNode edgeNode_1 = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">            EdgeNode edgeNode_2 = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">            <span class="keyword">int</span> vi = getPosition(edges[i][<span class="number">0</span>], vexs);</span><br><span class="line">            <span class="keyword">int</span> vj = getPosition(edges[i][<span class="number">1</span>], vexs);</span><br><span class="line">             </span><br><span class="line">            edgeNode_1.tailvex = vi;</span><br><span class="line">            edgeNode_1.headvex = vj;</span><br><span class="line">            edgeNode_1.taillink = vertexNodeList[vi].firstOut;</span><br><span class="line">            vertexNodeList[vi].firstOut = edgeNode_1;</span><br><span class="line">            </span><br><span class="line">            edgeNode_2.tailvex = vi;</span><br><span class="line">            edgeNode_2.headvex = vj;</span><br><span class="line">            edgeNode_2.headlink = vertexNodeList[vj].firstIn;</span><br><span class="line">            vertexNodeList[vj].firstIn = edgeNode_2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  功能：顶点表结点结构</span><br><span class="line">     *  参数：vertex --&gt; 顶点域，存储顶点信息</span><br><span class="line">     *       firstIn --&gt; 入边表头指针，指向该顶点的入边表中第一个结点</span><br><span class="line">     *       firstOut --&gt; 出边表头指针，指向该顶点的出边表中第一个结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> vertex; </span><br><span class="line">        EdgeNode firstIn;</span><br><span class="line">        EdgeNode firstOut; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  功能：边表结点</span><br><span class="line">     *  参数：tailvex --&gt; 弧起点在顶点表的下标</span><br><span class="line">     *        headvex --&gt; 弧终点在顶点表的下标</span><br><span class="line">     *        headlink --&gt; 入边表指针域,指向终点相同的下一条边</span><br><span class="line">     *        taillink --&gt; 边表指针域，指向起点相同的下一条边</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> tailvex;</span><br><span class="line">    	<span class="keyword">int</span> headvex;</span><br><span class="line">    	EdgeNode headlink;</span><br><span class="line">    	EdgeNode taillink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  功能：返回ch位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">char</span>[] vexs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            <span class="keyword">if</span> (vexs[i] == ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  功能：打印邻接表和逆邻接表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"AdjList:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            System.out.print(vertexNodeList[i].vertex + <span class="string">"--&gt;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (vertexNodeList[i].firstOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                EdgeNode mEdgeNode = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">                mEdgeNode = vertexNodeList[i].firstOut;</span><br><span class="line">                System.out.print(mEdgeNode.headvex);</span><br><span class="line">                <span class="keyword">while</span> (mEdgeNode.taillink != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mEdgeNode = mEdgeNode.taillink;</span><br><span class="line">                    System.out.print(mEdgeNode.headvex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"----------\n"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">"InvAdjList:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            System.out.print(vertexNodeList[i].vertex + <span class="string">"&lt;--"</span>);</span><br><span class="line">            <span class="keyword">if</span> (vertexNodeList[i].firstIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                EdgeNode mEdgeNode = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">                mEdgeNode = vertexNodeList[i].firstIn;</span><br><span class="line">                System.out.print(mEdgeNode.tailvex);</span><br><span class="line">                <span class="keyword">while</span> (mEdgeNode.headlink != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mEdgeNode = mEdgeNode.headlink;</span><br><span class="line">                    System.out.print(mEdgeNode.tailvex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 顶点数组</span></span><br><span class="line">        <span class="keyword">char</span>[] vexs = &#123;</span><br><span class="line">            <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 边数组</span></span><br><span class="line">        <span class="keyword">char</span>[][] edges = <span class="keyword">new</span> <span class="keyword">char</span>[][] &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'B'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'C'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'B'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        OListDG listUDG = <span class="keyword">new</span> OListDG(vexs, edges);</span><br><span class="line">        listUDG.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AdjList:  </span><br><span class="line">A--&gt;<span class="number">321</span>  </span><br><span class="line">B--&gt;<span class="number">3</span>  </span><br><span class="line">C--&gt;<span class="number">3</span>  </span><br><span class="line">D--&gt;  </span><br><span class="line"><span class="string">'----------'</span> </span><br><span class="line">InvAdjList:  </span><br><span class="line">A&lt;--  </span><br><span class="line">B&lt;--<span class="number">0</span>  </span><br><span class="line">C&lt;--<span class="number">0</span>  </span><br><span class="line">D&lt;--<span class="number">210</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[邻接表（Java）]]></title>
      <url>http://gongchuangsu.com/2016/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88Java%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="邻接表无线图"><a href="#邻接表无线图" class="headerlink" title="邻接表无线图"></a>邻接表无线图</h1><p>无向图的邻接表结构如下所示：<br><img src="http://i.imgur.com/r5CmERk.png" alt="无向图的邻接表结构"></p>
<p>无向图的邻接表的代码实现：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 邻接表无向图（已提供参数）</span><br><span class="line"> * 输入说明：vexs  --  顶点数组</span><br><span class="line"> * 		   edges  --  边数组</span><br><span class="line"> * 输出说明：邻接表（即每个顶点所连接的点）</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUDG</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vlen; <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> elen; <span class="comment">// 边个数</span></span><br><span class="line">    VertexNode[] vertexNodeList; <span class="comment">// 顶点数组</span></span><br><span class="line">    EdgeNode edgeNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * <span class="doctag">@param</span> vexs</span><br><span class="line">     * <span class="doctag">@param</span> edges</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListUDG</span><span class="params">(<span class="keyword">char</span>[] vexs, <span class="keyword">char</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        vlen = vexs.length;</span><br><span class="line">        elen = edges.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化顶点,建立顶点表</span></span><br><span class="line">        vertexNodeList = <span class="keyword">new</span> VertexNode[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            vertexNodeList[i] = <span class="keyword">new</span> VertexNode();</span><br><span class="line">            vertexNodeList[i].vertex = vexs[i];</span><br><span class="line">            vertexNodeList[i].firstedge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化边，利用头插法建立邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++) &#123;</span><br><span class="line">            EdgeNode edgeNode_1 = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">            EdgeNode edgeNode_2 = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">            <span class="keyword">int</span> vi = getPosition(edges[i][<span class="number">0</span>], vexs);</span><br><span class="line">            <span class="keyword">int</span> vj = getPosition(edges[i][<span class="number">1</span>], vexs);</span><br><span class="line">             </span><br><span class="line">            edgeNode_1.adjvex = edges[i][<span class="number">1</span>];</span><br><span class="line">            edgeNode_1.next = vertexNodeList[vi].firstedge;</span><br><span class="line">            vertexNodeList[vi].firstedge = edgeNode_1;</span><br><span class="line"></span><br><span class="line">            edgeNode_2.adjvex = edges[i][<span class="number">0</span>];</span><br><span class="line">            edgeNode_2.next = vertexNodeList[vj].firstedge;</span><br><span class="line">            vertexNodeList[vj].firstedge = edgeNode_2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  顶点表结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> vertex; <span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">        EdgeNode firstedge; <span class="comment">// 边表头指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  边表结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> adjvex; <span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">        EdgeNode next; <span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  返回ch位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">char</span>[] vexs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            <span class="keyword">if</span> (vexs[i] == ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  打印邻接表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"AdjList:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            System.out.print(vertexNodeList[i].vertex + <span class="string">"--&gt;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (vertexNodeList[i].firstedge != <span class="keyword">null</span>) &#123;</span><br><span class="line">                EdgeNode mEdgeNode = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">                mEdgeNode = vertexNodeList[i].firstedge;</span><br><span class="line">                System.out.print(mEdgeNode.adjvex);</span><br><span class="line">                <span class="keyword">while</span> (mEdgeNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mEdgeNode = mEdgeNode.next;</span><br><span class="line">                    System.out.print(mEdgeNode.adjvex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主函数</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 顶点数组</span></span><br><span class="line">        <span class="keyword">char</span>[] vexs = &#123;</span><br><span class="line">            <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 边数组</span></span><br><span class="line">        <span class="keyword">char</span>[][] edges = <span class="keyword">new</span> <span class="keyword">char</span>[][] &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'B'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'C'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'B'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListUDG listUDG = <span class="keyword">new</span> ListUDG(vexs, edges);</span><br><span class="line">        listUDG.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AdjList:  </span><br><span class="line">A--&gt;DCB  </span><br><span class="line">B--&gt;DA  </span><br><span class="line">C--&gt;DA  </span><br><span class="line">D--&gt;CBA</span><br></pre></td></tr></table></figure>
<h1 id="邻接表有向图"><a href="#邻接表有向图" class="headerlink" title="邻接表有向图"></a>邻接表有向图</h1><p>有向图的邻接表结构如下所示：</p>
<p><img src="http://i.imgur.com/3l7ok77.png" alt="有向图的邻接表结构"></p>
<p>有向图的邻接表的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 邻接表有向图（已提供参数）</span><br><span class="line"> * 输入说明：vexs  --  顶点数组</span><br><span class="line"> * 		   edges  --  边数组</span><br><span class="line"> * 输出说明：邻接表（即对每个顶点vi都建立一个链接为vi为弧尾的表）</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDG</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vlen; <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> elen; <span class="comment">// 边个数</span></span><br><span class="line">    VertexNode[] vertexNodeList; <span class="comment">// 顶点数组</span></span><br><span class="line">    EdgeNode edgeNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * <span class="doctag">@param</span> vexs</span><br><span class="line">     * <span class="doctag">@param</span> edges</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListDG</span><span class="params">(<span class="keyword">char</span>[] vexs, <span class="keyword">char</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        vlen = vexs.length;</span><br><span class="line">        elen = edges.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化顶点,建立顶点表</span></span><br><span class="line">        vertexNodeList = <span class="keyword">new</span> VertexNode[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            vertexNodeList[i] = <span class="keyword">new</span> VertexNode();</span><br><span class="line">            vertexNodeList[i].vertex = vexs[i];</span><br><span class="line">            vertexNodeList[i].firstedge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化边，利用头插法建立邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++) &#123;</span><br><span class="line">            EdgeNode edgeNode = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">            <span class="keyword">int</span> vi = getPosition(edges[i][<span class="number">0</span>], vexs);</span><br><span class="line">            <span class="keyword">int</span> vj = getPosition(edges[i][<span class="number">1</span>], vexs);</span><br><span class="line">             </span><br><span class="line">            edgeNode.adjvex = edges[i][<span class="number">1</span>];</span><br><span class="line">            edgeNode.next = vertexNodeList[vi].firstedge;</span><br><span class="line">            vertexNodeList[vi].firstedge = edgeNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  顶点表结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> vertex; <span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">        EdgeNode firstedge; <span class="comment">// 边表头指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  边表结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> adjvex; <span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">        EdgeNode next; <span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  返回ch位置</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">char</span>[] vexs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            <span class="keyword">if</span> (vexs[i] == ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  打印邻接表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"AdjList:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            System.out.print(vertexNodeList[i].vertex + <span class="string">"--&gt;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (vertexNodeList[i].firstedge != <span class="keyword">null</span>) &#123;</span><br><span class="line">                EdgeNode mEdgeNode = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">                mEdgeNode = vertexNodeList[i].firstedge;</span><br><span class="line">                System.out.print(mEdgeNode.adjvex);</span><br><span class="line">                <span class="keyword">while</span> (mEdgeNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mEdgeNode = mEdgeNode.next;</span><br><span class="line">                    System.out.print(mEdgeNode.adjvex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主函数</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 顶点数组</span></span><br><span class="line">        <span class="keyword">char</span>[] vexs = &#123;</span><br><span class="line">            <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 边数组</span></span><br><span class="line">        <span class="keyword">char</span>[][] edges = <span class="keyword">new</span> <span class="keyword">char</span>[][] &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'B'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'C'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'B'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">'C'</span>, <span class="string">'D'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListDG listDG = <span class="keyword">new</span> ListDG(vexs, edges);</span><br><span class="line">        listDG.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AdjList:  </span><br><span class="line">A--&gt;DCB  </span><br><span class="line">B--&gt;D  </span><br><span class="line">C--&gt;D  </span><br><span class="line">D--&gt;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之自定义类数组的创建和使用]]></title>
      <url>http://gongchuangsu.com/2016/03/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>简单介绍Java自定义类数组的创建和使用，具体代码如下：<br>第一步：创建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点表结点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="keyword">char</span> vertex;   <span class="comment">// 顶点域，存储顶点信息  </span></span><br><span class="line">VertexNode firstedge;  <span class="comment">// 边表头指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：定义顶点数组并初始化</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化顶点,建立顶点表  </span></span><br><span class="line">VertexNode[] vertexNodeList = <span class="keyword">new</span> VertexNode[vlen];</span><br></pre></td></tr></table></figure>
<p>第三步：初始化数组中每一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertexNodeList[i] = <span class="keyword">new</span> VertexNode();</span><br></pre></td></tr></table></figure>
<p>【注意】第三步是必须的，不然会出现空指针的错误。具体原因还没搞清楚，欢迎指教！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之变量类型]]></title>
      <url>http://gongchuangsu.com/2016/03/09/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>一个变量为我们提供了被命名的存储空间。Java中的每个变量都一个特定的类型，其能够决定变量内存的大小和布局；值的范围可以存储在这个内存中；并且操作集可以应用于该变量。</p>
<p>在使用变量之前，必须先声明该变量。一个变量声明的基本形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data type variable [ = value][, variable [= value] ...] ;</span><br></pre></td></tr></table></figure>
<p>这里，<code>data type</code>是Java数据类型之一，<code>variable</code>是变量名。如果要声明指定类型的多个变量，可以使用逗号分离的列表。</p>
<p>Java中变量的声明和初始化如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;         <span class="comment">// Declares three ints, a, b, and c.</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">10</span>;  <span class="comment">// Example of initialization</span></span><br><span class="line"><span class="keyword">byte</span> B = <span class="number">22</span>;         <span class="comment">// initializes a byte type variable B.</span></span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// declares and assigns a value of PI.</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'a'</span>;        <span class="comment">// the char variable a iis initialized with value 'a'</span></span><br></pre></td></tr></table></figure>
<p>本节将介绍Java语言中可用的各种变量类型。这里列出了三种变量：</p>
<ul>
<li>局部变量(local variables)</li>
<li>成员变量(member variables)<ul>
<li>实例变量(instance variables)</li>
<li>类/静态变量(class/static variables)</li>
</ul>
</li>
</ul>
<h1 id="局部变量（Local-variables）"><a href="#局部变量（Local-variables）" class="headerlink" title="局部变量（Local variables）"></a>局部变量（Local variables）</h1><ul>
<li>局部变量是在方法、构造函数或块中进行声明的。</li>
<li>当程序进入方法、构造函数或块中时，局部变量就会被创建；而一旦程序退出了方法、构造函数或块时，该变量就会被摧毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只能在声明的方法，构造函数或块中可见。</li>
<li>局部变量是在堆栈层内部实现。</li>
<li>局部变量是没有默认值的，所以在使用之前，必须先声明且初始化赋初值。</li>
</ul>
<p>如下，<code>age</code>是一个局部变量，其是在<code>pupAge()</code>方法内部定义的，故其作用范围仅限于该方法内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pupAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">      age = age + <span class="number">7</span>;</span><br><span class="line">      System.out.println(<span class="string">"Puppy age is : "</span> + age);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      test.pupAge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Puppy age is: 7</span><br></pre></td></tr></table></figure>
<p>下面是<code>age</code>没有被初始化，结果就报错了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pupAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age;</span><br><span class="line">      age = age + <span class="number">7</span>;</span><br><span class="line">      System.out.println(<span class="string">"Puppy age is : "</span> + age);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      test.pupAge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.java:<span class="number">4</span>:variable number might not have been initialized</span><br></pre></td></tr></table></figure></p>
<h1 id="实例变量（Instance-variables）"><a href="#实例变量（Instance-variables）" class="headerlink" title="实例变量（Instance variables）"></a>实例变量（Instance variables）</h1><ul>
<li>实例变量是在类中，但在方法、构造函数或块之外声明的。</li>
<li>当空间被分配给堆中的对象时，将为每个实例变量值创建插槽。</li>
<li>当一个对象用<code>new</code>关键字被创建时，其实例变量即被创建，而当对象被摧毁时，其实例变量也将被摧毁。</li>
<li>访问修饰符可用来修饰实例变量。</li>
<li>实例变量对类中所有的方法、构造函数和块都是可见的。通常，建议将这些变量设置为<code>private</code>（访问级别）。然而，子类的可见性可通过这些运用访问修饰符的变量给出。</li>
<li>实例变量有默认值。对于数字，其默认值为<code>0</code>，对于布尔值，其默认值为<code>false</code>，对于对象的引用，其默认值为<code>null</code>。其默认值可在声明期间或构造函数中进行分配。</li>
<li>实例变量可直接通过调用类里面的变量名来访问。然而，在<code>static</code>方法和不同的类中调用时需使用全名，如 <code>ObjectReference.VariableName</code></li>
</ul>
<p>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">   <span class="comment">// this instance variable is visible for any child class.</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// salary  variable is visible in Employee class only.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// The name variable is assigned in the constructor. </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span> <span class="params">(String empName)</span></span>&#123;</span><br><span class="line">      name = empName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The salary variable is assigned a value.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> empSal)</span></span>&#123;</span><br><span class="line">      salary = empSal;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// This method prints the employee details.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"name  : "</span> + name );</span><br><span class="line">      System.out.println(<span class="string">"salary :"</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Employee empOne = <span class="keyword">new</span> Employee(<span class="string">"Ransika"</span>);</span><br><span class="line">      empOne.setSalary(<span class="number">1000</span>);</span><br><span class="line">      empOne.printEmp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name  : Ransika</span><br><span class="line">salary :<span class="number">1000.0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="类-静态变量（Class-static-variables）"><a href="#类-静态变量（Class-static-variables）" class="headerlink" title="类/静态变量（Class/static variables）"></a>类/静态变量（Class/static variables）</h1><p>有些面向对象语言采用<strong>类变量（类数据）</strong>和<strong>类方法</strong>两个术语，但意思都是一样，都代表着变量和方法只是作为整个类，而不是类的某个特定的对象而存在的。</p>
<ul>
<li>类变量也称为静态变量，其在类中，但在方法、构造函数或块之外利用<code>static</code>关键字进行声明。</li>
<li>每个类只存在一个类变量的副本，而与被创建的对象个数无关。</li>
<li>静态变量除了被声明为常量，很少使用到。常量是被声明为<code>public</code>/<code>private</code>, <code>final</code> and <code>static</code>的变量。常变量初始化后就不会再改变。</li>
<li>静态变量存储在静态内存中。</li>
<li>静态变量在程序开始执行时被创建，在程序停止时被摧毁。</li>
<li>其可见性跟实例变量类似。然而，大多数静态变量被声明为<code>public</code>，因为它们必须对类用户可见。</li>
<li>其默认值也和实例变量类似。</li>
<li>引用静态变量有两种方法：一、可通过一个对象去定位它，如<code>className.VariableName</code>，二、可通过调用类名<code>ClassName.VariableName</code>进行访问。其静态方法也一样。</li>
<li><code>static</code>方法的一个重要方法就是在不创建任何对象的前提下就可以调用它。</li>
<li>当类变量声明为<code>public static final</code>，其变量名要全部大写；如果静态变量不是<code>public</code>和 <code>final</code>，其变量名语法与实例变量和局部变量一样。</li>
</ul>
<blockquote>
<p>特别注意：当类变量声明为static final时，必须得赋初始值。这是由final变量的性质所决定的。</p>
</blockquote>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">   <span class="comment">// salary  variable is a private static variable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// DEPARTMENT is a constant</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEPARTMENT = <span class="string">"Development "</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      salary = <span class="number">1000</span>;</span><br><span class="line">      System.out.println(DEPARTMENT + <span class="string">"average salary:"</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Development average salary:<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>注意：如果变量是从外部类进行访问，其常变量应该这样访问：<code>Employee.DEPARTMENT</code>。</p>
<h1 id="静态变量与实例变量的区别"><a href="#静态变量与实例变量的区别" class="headerlink" title="静态变量与实例变量的区别"></a>静态变量与实例变量的区别</h1><p>静态变量不属于某个实例对象，而是属于类，故能够通过类名来访问，不需要创建一个类的对象来访问该类的静态变量(当然也可以通过一个类的对象来访问静态变量，但是不提倡)；而实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能够使用这个实例变量。<br>每个类只存在一个类变量的副本，而与被创建的对象个数无关，静态变量位于方法区，被类的所有实例共享，其生命周期取决于类的生命周期；而实例变量则是没创建一个实例，java虚拟机就会为实例变量分配一次内存，实例变量位于堆区，其生命周期取决于实例的生命周期。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	  Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">	  System.out.println(a);</span><br><span class="line">	  <span class="comment">//System.out.println(b);       //It's not OK!   </span></span><br><span class="line">	  System.out.println(test1.b);   <span class="comment">//It's OK!</span></span><br><span class="line">	  </span><br><span class="line">	  Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">	  a = <span class="number">1</span>;</span><br><span class="line">	  test2.b = <span class="number">1</span>;</span><br><span class="line">	  System.out.println(a); </span><br><span class="line">	  System.out.println(test1.b);</span><br><span class="line">	  System.out.println(test2.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** output</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>注意：如果变量是从外部类进行访问，其常变量应该这样访问：<code>Employee.DEPARTMENT</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之基本数据类型]]></title>
      <url>http://gongchuangsu.com/2016/03/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>变量只不过是为了存储数值而保存内存位置。也就是说，当创建一个变量时，将会得到内存中一些空间。</p>
<p>根据变量的数据类型，操作系统将为其分配内存，并决定哪些可以存储在分配的内存中。因此，通过给变量分配不同的数据类型，我们可以在变量中存储整数（integers）、小数（decimals）或字符（characters ）。</p>
<p>在Java中有两种可用的数据类型：</p>
<ul>
<li>基本数据类型（Primitive Data Types）</li>
<li>参考/对象数据类型（Reference/Object Data Types）</li>
</ul>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>这里列出了8类Java所支持的基本数据类型。基本数据类型是由语言预定义并且由关键字来命名的。</p>
<a id="more"></a>
<h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><ul>
<li>字节数据类型是一个8位的有符号的二进制补码整数</li>
<li>最小值为-128（-2^7）</li>
<li>最大值为127（2^7-1）</li>
<li>默认值为<code>0</code></li>
<li>字节数据类型用于在大型阵列中节省空间，主要是替换整数，因为一个字节（byte）比一个整型（int）要小四倍</li>
<li>例如：<code>byte a = 100，byte b = -50</code></li>
</ul>
<h2 id="short"><a href="#short" class="headerlink" title="short"></a>short</h2><ul>
<li>短数据类型是一个16位的有符号的二进制补码整数</li>
<li>最小值为-32,768 (-2^15)</li>
<li>最大值为32,767 (2^15 -1)</li>
<li>默认值为<code>0</code></li>
<li>短数据类型也可以作为字节数据类型用来节省空间，一个短数据类型（short）比一个整型（int）要小两倍</li>
<li>例如：<code>short s = 10000, short r = -20000</code></li>
</ul>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul>
<li>整数数据类型是一个32位的有符号的二进制补码整数</li>
<li>最小值为- 2,147,483,648.(-2^31)</li>
<li>最大值为 2,147,483,647.(2^31 -1)</li>
<li>默认值为<code>0</code></li>
<li>整数数据类型一般用作整数值的默认数据类型</li>
<li>例如：<code>int a = 100000, int b = -200000</code></li>
</ul>
<h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><ul>
<li>长数据类型是一个64位的有符号的二进制补码整数</li>
<li>最小值为-9,223,372,036,854,775,808.(-2^63)</li>
<li>最大值为 9,223,372,036,854,775,807. (2^63 -1)</li>
<li>默认值为<code>0L</code></li>
<li>长数据类型一般用于一个数值超过整型范围</li>
<li>例如： <code>long a = 100000L, long b = -200000L</code></li>
</ul>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul>
<li>float数据类型是32位IEEE 754单精确度的浮点</li>
<li>float数据类型主要用于在大型的浮点数阵列中节省空间</li>
<li>默认值为 <code>0.0f</code></li>
<li>float数据类型从来不用于精确值，如货币</li>
<li>例如： <code>float f1 = 234.5f</code></li>
</ul>
<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><ul>
<li>double数据类型是64位IEEE 754双精确度的浮点</li>
<li>这种数据类型一般用于小数值的默认数据类型</li>
<li>double数据类型从来不用于精确值，如货币</li>
<li>默认值为<code>0.0d</code></li>
<li>例如：<code>double d1 = 123.4</code></li>
</ul>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ul>
<li>布尔数据类型代表一个比特的信息</li>
<li>仅存在两种可能值：<code>true</code> and <code>false</code></li>
<li>这种数据类型用于追踪真/假条件的简单标记</li>
<li>默认值为<code>false</code></li>
<li>例如：<code>boolean one = true</code></li>
</ul>
<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul>
<li>char数据类型是一个16位的Unicode字符</li>
<li>最小值为’\u0000’ (or 0)</li>
<li>最大值为 ‘\uffff’ (or 65,535 inclusive)</li>
<li>char数据类型用于存储任意字符</li>
<li>例如：<code>char letterA =&#39;A&#39;</code></li>
</ul>
<h1 id="参考数据类型"><a href="#参考数据类型" class="headerlink" title="参考数据类型"></a>参考数据类型</h1><ul>
<li>参考变量是使用类定义的构造函数创建的。他们被用来访问对象。这些变量被声明为一种不能改变的特定类型。例如：<code>Employee</code>, <code>Puppy</code>等</li>
<li>类对象以及数组变量的各种类型应归入参考变量类型</li>
<li>任何参考变量的默认值为<code>null</code></li>
<li>一个参考变量可被用于访问任一声明类型或相容类型的对象</li>
<li>例如: <code>Animal animal = new Animal(&quot;giraffe&quot;)</code></li>
</ul>
<h1 id="Java文本（Literals）"><a href="#Java文本（Literals）" class="headerlink" title="Java文本（Literals）"></a>Java文本（Literals）</h1><p>文本是一个固定值的源代码表示。他们在没有任何计算的代码中直接表示。</p>
<p>文本可以被分配到任一原始类型的变量中。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">68</span>;</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span></span><br></pre></td></tr></table></figure>
<p>byte, int, long, and short可以用十进制、十六进制或八进制的数字系统表示。</p>
<p>当用这些数字系统表示文本时，经常用前缀0用来表示八进制，前缀0x用来表示十六进制。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> decimal = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> octal = <span class="number">0144</span>;</span><br><span class="line"><span class="keyword">int</span> hexa =  <span class="number">0x64</span>;</span><br></pre></td></tr></table></figure>
<p>Java中的字符串跟大多数语言中的一样，都是指被一对封闭的双引号所包含的字符序列。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello World"</span></span><br><span class="line"><span class="string">"two\nlines"</span></span><br><span class="line"><span class="string">"\"This is in quotes\""</span></span><br></pre></td></tr></table></figure>
<p><code>String</code> and <code>char</code>文本可以包含任一Unicode字符。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'\u0001'</span>;</span><br><span class="line">String a = <span class="string">"\u0001"</span>;</span><br></pre></td></tr></table></figure>
<p>Java语言支持一些<code>string</code> and <code>char</code>文本特殊的转义字符。如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">所代表字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行 (0x0a)</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车符 (0x0d)</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页 (0x0c)</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">退格 (0x08)</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">空格 (0x20)</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">tab</td>
</tr>
<tr>
<td style="text-align:left">\”</td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td style="text-align:left">\’</td>
<td style="text-align:left">单引号</td>
</tr>
<tr>
<td style="text-align:left">\ \</td>
<td style="text-align:left">反斜线</td>
</tr>
<tr>
<td style="text-align:left">\ddd</td>
<td style="text-align:left">八进制字符（ddd）</td>
</tr>
<tr>
<td style="text-align:left">\uxxxx</td>
<td style="text-align:left">十六进制UNICODE字符（xxxx）</td>
</tr>
<tr>
<td style="text-align:left">\\u0024</td>
<td style="text-align:left">.(点)</td>
</tr>
<tr>
<td style="text-align:left">\\u0024</td>
<td style="text-align:left">$(美元符号)</td>
</tr>
<tr>
<td style="text-align:left">\\u005E</td>
<td style="text-align:left">^(乘方符号)</td>
</tr>
<tr>
<td style="text-align:left">\\u007B</td>
<td style="text-align:left">{(左大括号)</td>
</tr>
<tr>
<td style="text-align:left">\\u005B</td>
<td style="text-align:left">[(左方括号)</td>
</tr>
<tr>
<td style="text-align:left">\\u0028</td>
<td style="text-align:left">((左圆括弧)</td>
</tr>
<tr>
<td style="text-align:left">\\u007C</td>
<td style="text-align:left"></td>
<td>(竖线)</td>
</tr>
<tr>
<td style="text-align:left">\\u0029</td>
<td style="text-align:left">)(右圆括弧)</td>
</tr>
<tr>
<td style="text-align:left">\\u002A</td>
<td style="text-align:left">*(星号)</td>
</tr>
<tr>
<td style="text-align:left">\\u002B</td>
<td style="text-align:left">+(加号)</td>
</tr>
<tr>
<td style="text-align:left">\\u003F</td>
<td style="text-align:left">?(问号)</td>
</tr>
</tbody>
</table>
<h1 id="进制之间相互转换"><a href="#进制之间相互转换" class="headerlink" title="进制之间相互转换"></a>进制之间相互转换</h1><p>二进制，八进制，十六进制，十进制间进行相互转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 十进制转成十六进制：   </span><br><span class="line">  </span><br><span class="line">Integer.toHexString(int i)   </span><br><span class="line">  </span><br><span class="line">// 十进制转成八进制   </span><br><span class="line">  </span><br><span class="line">Integer.toOctalString(int i)   </span><br><span class="line">  </span><br><span class="line">// 十进制转成二进制   </span><br><span class="line">  </span><br><span class="line">Integer.toBinaryString(int i)   </span><br><span class="line">  </span><br><span class="line">// 十六进制转成十进制   </span><br><span class="line">  </span><br><span class="line">Integer.valueOf(&quot;FFFF&quot;,16).toString()   </span><br><span class="line">  </span><br><span class="line">// 八进制转成十进制   </span><br><span class="line">  </span><br><span class="line">Integer.valueOf(&quot;876&quot;,8).toString()   </span><br><span class="line">  </span><br><span class="line">// 二进制转十进制   </span><br><span class="line">  </span><br><span class="line">Integer.valueOf(&quot;0101&quot;,2).toString()</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之对象与类]]></title>
      <url>http://gongchuangsu.com/2016/03/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>Java是一种面向对象的语言，它具有面向对象语言的一些特征，支持以下基本概念：</p>
<ul>
<li>多态性（Polymorphism）</li>
<li>继承（Inheritance）</li>
<li>封装（Encapsulation）</li>
<li>抽象（Abstraction）</li>
<li>类（Classes）</li>
<li>对象（Objects）</li>
<li>实例化（Instance）</li>
<li>方法（Method）</li>
<li>消息解析（Message Parsing）</li>
</ul>
<p>在这篇博客中，主要探究类和对象的概念。</p>
<a id="more"></a>
<blockquote>
<p>对象（Object）：对象具有状态和行为。例如：一条狗具有颜色、名字、品种等属性，同时也具有摇摆、犬叫和吃等行为。对象是类的一个实例。</p>
<p>类（Class）：类可以被定义为一种描述行为或状态的模板或蓝图。</p>
</blockquote>
<h1 id="Java中的对象（Objects）"><a href="#Java中的对象（Objects）" class="headerlink" title="Java中的对象（Objects）"></a>Java中的对象（Objects）</h1><p>在现实生活中，我们能够轻易地找出很多对象，如车子、狗以及人类等等，这些对象都有对应的状态和行为。</p>
<p>相比现实生活中的对象，软件中的对象也有相似的特征。它们也有状态和行为。只不过软件中的状态是存储在字段（fields）中的，而行为是通过方法（methods）体现出来的。</p>
<h1 id="Java中的类（Classes）"><a href="#Java中的类（Classes）" class="headerlink" title="Java中的类（Classes）"></a>Java中的类（Classes）</h1><p>类是创建单个对象的蓝图。</p>
<p>类的创建如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"> String breed;</span><br><span class="line">   <span class="keyword">int</span> ageC</span><br><span class="line">   String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">barking</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造函数（Constructors）"><a href="#构造函数（Constructors）" class="headerlink" title="构造函数（Constructors）"></a>构造函数（Constructors）</h1><p>每一个类都有一个构造函数。如果我们没有明确地为一个类写构造函数，那么Java编译器将为这个类创建一个默认的构造函数。</p>
<p>每当一个新对象被创建时，至少会有一个构造函数被调用。构造函数必须与类同名。一个类可以有多个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">// This constructor has one parameter, name.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>正如前面提到，类为对象提供了蓝图。所以对象是从类创建而来。在Java中，需要用<code>new</code>关键字创建新对象。</p>
<p>创建对象步骤：</p>
<ul>
<li>声明（Declaration）</li>
<li>实例化（Instantiation）：<code>new</code>关键字</li>
<li>初始化（Initialization）：<code>new</code>关键字之后是对构造函数的调用，并初始化。</li>
</ul>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">// This constructor has one parameter, name.</span></span><br><span class="line">      System.out.println(<span class="string">"Passed Name is :"</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">      <span class="comment">// Following statement would create an object myPuppy</span></span><br><span class="line">      Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Passed Name is :tommy</span><br></pre></td></tr></table></figure>
<h1 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h1><p>访问实例变量和方法是通过创建对象实现的。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First create an object */</span></span><br><span class="line">ObjectReference = <span class="keyword">new</span> Constructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now call a variable as follows */</span></span><br><span class="line">ObjectReference.variableName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now you can call a class method as follows */</span></span><br><span class="line">ObjectReference.MethodName();</span><br></pre></td></tr></table></figure>
<p>完整的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> puppyAge;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">// This constructor has one parameter, name.</span></span><br><span class="line">      System.out.println(<span class="string">"Name chosen is :"</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> age )</span></span>&#123;</span><br><span class="line">       puppyAge = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">( )</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Puppy's age is :"</span> + puppyAge ); </span><br><span class="line">       <span class="keyword">return</span> puppyAge;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">      <span class="comment">/* Object creation */</span></span><br><span class="line">      Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Call class method to set puppy's age */</span></span><br><span class="line">      myPuppy.setAge( <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Call another class method to get puppy's age */</span></span><br><span class="line">      myPuppy.getAge( );</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* You can access instance variable as follows as well */</span></span><br><span class="line">      System.out.println(<span class="string">"Variable Value :"</span> + myPuppy.puppyAge ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name chosen is :tommy</span><br><span class="line">Puppy&apos;s age is :2</span><br><span class="line">Variable Value :2</span><br></pre></td></tr></table></figure>
<h1 id="源文件的声明规则"><a href="#源文件的声明规则" class="headerlink" title="源文件的声明规则"></a>源文件的声明规则</h1><p>在源文件中类声明、<code>import</code>语句、<code>package</code>语句时必须遵循以下规则：</p>
<ul>
<li>每个源文件中只能有一个<code>public</code>类；</li>
<li>一个源文件中可以有多个非<code>public</code>类；</li>
<li><code>public</code>类名应该与源文件名一致，且源文件名需以后缀<code>.java</code>结尾；</li>
<li>如果一个类定义在某个包中，那么<code>package</code>语句应该在源文件的首行；</li>
<li>如果源文件中存在<code>import</code>语句，那么它必须放在<code>package</code>语句和类声明之间；如果源文件中没有<code>package</code>语句，那么它应该放在源文件的首行；</li>
<li><code>import</code>语句和<code>package</code>语句对源文件中所有的类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<p>类有几种不同的访问级别，而且类也分不同类型；如<code>abstract</code> 类、<code>final</code>类等。除了这几种类，Java还有一些特别的类，<code>Inner</code> 类和<code>Anonymous</code>类；</p>
<h1 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h1><p>它为类和接口的分类提供了简便的方法。我们知道，在Java开发应用中，经常会有几百个类和接口写入，那么把这些进行分类将会简便我们的工作。</p>
<h1 id="Import语句"><a href="#Import语句" class="headerlink" title="Import语句"></a>Import语句</h1><p>在Java中，如果提供一个完全合格的名称，其包含包名和类名，那么编译器将很容易定位到源代码或类。<code>Import</code>语句 就是这样一种给编译器提供恰当位置的方法。</p>
<p>例如，下面这行代码就是告诉编译器载入<code>java_installation/java/io</code>目录下所有的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br></pre></td></tr></table></figure>
<h1 id="一个简单的案例研究"><a href="#一个简单的案例研究" class="headerlink" title="一个简单的案例研究"></a>一个简单的案例研究</h1><p><strong>Employee.java文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   String designation;</span><br><span class="line">   <span class="keyword">double</span> salary;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// This is the constructor of the class Employee</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Assign the age of the Employee  to the variable age.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empAge</span><span class="params">(<span class="keyword">int</span> empAge)</span></span>&#123;</span><br><span class="line">      age =  empAge;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Assign the designation to the variable designation.*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empDesignation</span><span class="params">(String empDesig)</span></span>&#123;</span><br><span class="line">      designation = empDesig;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Assign the salary to the variable	salary.*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empSalary</span><span class="params">(<span class="keyword">double</span> empSalary)</span></span>&#123;</span><br><span class="line">      salary = empSalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Print the Employee details */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Name:"</span>+ name );</span><br><span class="line">      System.out.println(<span class="string">"Age:"</span> + age );</span><br><span class="line">      System.out.println(<span class="string">"Designation:"</span> + designation );</span><br><span class="line">      System.out.println(<span class="string">"Salary:"</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>EmployeeTest.java文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">/* Create two objects using constructor */</span></span><br><span class="line">      Employee empOne = <span class="keyword">new</span> Employee(<span class="string">"James Smith"</span>);</span><br><span class="line">      Employee empTwo = <span class="keyword">new</span> Employee(<span class="string">"Mary Anne"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoking methods for each object created</span></span><br><span class="line">      empOne.empAge(<span class="number">26</span>);</span><br><span class="line">      empOne.empDesignation(<span class="string">"Senior Software Engineer"</span>);</span><br><span class="line">      empOne.empSalary(<span class="number">1000</span>);</span><br><span class="line">      empOne.printEmployee();</span><br><span class="line"></span><br><span class="line">      empTwo.empAge(<span class="number">21</span>);</span><br><span class="line">      empTwo.empDesignation(<span class="string">"Software Engineer"</span>);</span><br><span class="line">      empTwo.empSalary(<span class="number">500</span>);</span><br><span class="line">      empTwo.printEmployee();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; javac Employee.java</span><br><span class="line">C:\&gt; javac EmployeeTest.java</span><br><span class="line">C:\&gt; java EmployeeTest</span><br><span class="line">Name:James Smith</span><br><span class="line">Age:26</span><br><span class="line">Designation:Senior Software Engineer</span><br><span class="line">Salary:1000.0</span><br><span class="line">Name:Mary Anne</span><br><span class="line">Age:21</span><br><span class="line">Designation:Software Engineer</span><br><span class="line">Salary:500.0</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之基本语法]]></title>
      <url>http://gongchuangsu.com/2016/03/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="基本语法（Basic-Syntax）"><a href="#基本语法（Basic-Syntax）" class="headerlink" title="基本语法（Basic Syntax）"></a>基本语法（Basic Syntax）</h1><p>在Java编程中，我们需要注意以下几点问题：</p>
<ol>
<li>大小写敏感（Case Sensitivity）：如Hello和hello在java中代表着不同的含义；</li>
<li>类名称（Class Names）：所有类的名称的首字母必须大写，而且，如果类名是由几个单词组成，那么这几个单词的首字母也必须大写，如类名：<code>MyFirstJavaClass</code>；</li>
<li>方法名称（Method Names）：所有的方法名称的首字母必须小写，而且，如果方法名是由几个单词组成，那么除第一个字母小写外，其他单词的首字母必须大写，如 <code>public void myMethodName()</code>；</li>
<li>程序文件名称（Program File Name）：所有的程序文件名称应该和类名相匹配。如果程序文件名与类名不匹配，程序将不能被编译。如假设’MyFirstJavaProgram’ 是类名，那么文件名应该设置为 ‘MyFirstJavaProgram.java’；</li>
<li><code>public static void main(String args[])</code> ：Java程序是从<code>main()</code>方法开始执行的，这是每个Java程序所必有的一部分。</li>
</ol>
<a id="more"></a>
<h1 id="Java标识符（Identifiers）"><a href="#Java标识符（Identifiers）" class="headerlink" title="Java标识符（Identifiers）"></a>Java标识符（Identifiers）</h1><p>在Java中，关于标识符，有以下几点需要说明：</p>
<ol>
<li>所有的标识符必须以字母（A-Z或a-z）、货币符号（$）或下划线（_）开头；</li>
<li>在第一个字符之后，标识符可以由以上三种任意字符组合，不能包含空格；</li>
<li>关键字不能用于标识符；</li>
<li>标识符是区分大小写的；</li>
<li>合法的标识符如：<code>age, $salary, _value, __1_value</code></li>
<li>不合法的标识符如：<code>123abc, -salary</code></li>
</ol>
<h1 id="Java修饰符（Modifiers）"><a href="#Java修饰符（Modifiers）" class="headerlink" title="Java修饰符（Modifiers）"></a>Java修饰符（Modifiers）</h1><p>跟其他语言一样，可能需要用修饰符修饰类、方法等等。可以将修饰符分为两类：</p>
<ul>
<li>访问修饰符（Access Modifiers）：<code>default, public , protected, private</code></li>
<li>非访问修饰符（Non-access Modifiers）：<code>final, abstract, strictfp</code></li>
</ul>
<h1 id="Java变量（Variables）"><a href="#Java变量（Variables）" class="headerlink" title="Java变量（Variables）"></a>Java变量（Variables）</h1><p>Java中有以下几种类型的变量：</p>
<ul>
<li>局部变量（Local Variables）</li>
<li>类\静态变量（Class\Static Variables）</li>
<li>实例\非静态变量（Instance\Non-static Variables）</li>
</ul>
<h1 id="Java数组（Arrays）"><a href="#Java数组（Arrays）" class="headerlink" title="Java数组（Arrays）"></a>Java数组（Arrays）</h1><p>数组是存储多个相同类型变量的对象。在接下来的博客中，将具体介绍如何声明、构造和初始化数组。</p>
<h1 id="Java枚举（Enums）"><a href="#Java枚举（Enums）" class="headerlink" title="Java枚举（Enums）"></a>Java枚举（Enums）</h1><p>枚举是在java5.0中引进而来的。它限制了一个变量只能在一些预先设定好的数值中进行选择。这个枚举列表中的值称为枚举值。</p>
<p>枚举的运用，可以减少代码中bug出现的次数。</p>
<p>举一个新鲜果汁店的例子，它限制了杯子的大小只能为<code>small, medium and large</code>，它不允许客户选择这三个之外尺寸的杯子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreshJuice</span> </span>&#123;</span><br><span class="line">   <span class="keyword">enum</span> FreshJuiceSize&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">   FreshJuiceSize size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshJuiceTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      FreshJuice juice = <span class="keyword">new</span> FreshJuice();</span><br><span class="line">      juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;</span><br><span class="line">      System.out.println(<span class="string">"Size: "</span> + juice.size);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java关键字（Keywords）"><a href="#Java关键字（Keywords）" class="headerlink" title="Java关键字（Keywords）"></a>Java关键字（Keywords）</h1><p>下面列出了Java中的保留字：</p>
<table>
<thead>
<tr>
<th style="text-align:left">abstract</th>
<th style="text-align:left">assert</th>
<th style="text-align:left">boolean</th>
<th>break</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">case</td>
<td style="text-align:left">catch</td>
<td>char</td>
</tr>
<tr>
<td style="text-align:left">class</td>
<td style="text-align:left">const</td>
<td style="text-align:left">continue</td>
<td>default</td>
</tr>
<tr>
<td style="text-align:left">do</td>
<td style="text-align:left">double</td>
<td style="text-align:left">else</td>
<td>enum</td>
</tr>
<tr>
<td style="text-align:left">extends</td>
<td style="text-align:left">final</td>
<td style="text-align:left">finally</td>
<td>float</td>
</tr>
<tr>
<td style="text-align:left">for</td>
<td style="text-align:left">goto</td>
<td style="text-align:left">if</td>
<td>implements</td>
</tr>
<tr>
<td style="text-align:left">import</td>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">int</td>
<td>interface</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">native</td>
<td style="text-align:left">new</td>
<td>package</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">public</td>
<td>return</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">static</td>
<td style="text-align:left">strictfp</td>
<td>super</td>
</tr>
<tr>
<td style="text-align:left">switch</td>
<td style="text-align:left">synchronized</td>
<td style="text-align:left">this</td>
<td>throw</td>
</tr>
<tr>
<td style="text-align:left">throws</td>
<td style="text-align:left">transient</td>
<td style="text-align:left">try</td>
<td>void</td>
</tr>
<tr>
<td style="text-align:left">volatile</td>
<td style="text-align:left">while</td>
<td style="text-align:left">null</td>
</tr>
</tbody>
</table>
<h1 id="Java中的注释（Comments）"><a href="#Java中的注释（Comments）" class="headerlink" title="Java中的注释（Comments）"></a>Java中的注释（Comments）</h1><p>Java支持单行和多行注释，跟C和C++很相似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstJavaProgram</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* This is my first java program.</span><br><span class="line">    * This will print 'Hello World' as the output</span><br><span class="line">    * This is an example of multi-line comments.</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">       <span class="comment">// This is an example of single line comment</span></span><br><span class="line">       <span class="comment">/* This is also an example of single line comment. */</span></span><br><span class="line">       System.out.println(<span class="string">"Hello World"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h1><p>在Java中，类可以继承类。一般来讲，如果你想创建一个新类，而这里存在一个类，这个类里有一些你需要的代码，那么你可以从这个已经存在的类中继承得到新类。</p>
<p>这个概念允许我们重复使用已存在类中的字段和方法，而无需在新类中重写代码。在这种情形下，已存在的类被称为父类，继承而来的类被称为子类。</p>
<h1 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h1><p>在Java语言中，接口可以被定义为：类之间相互交流的契约。当涉及到继承的概念时，接口扮演着重要的角色。</p>
<p>接口定义的方法，其子类必须使用。并且其方法的实现完全由子类实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java和JVM运行原理]]></title>
      <url>http://gongchuangsu.com/2016/03/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E5%92%8CJVM%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h1><p><strong>编译型语言</strong>：专门的编译器，针对特定的操作系统翻译成机器码，并包装成该操作系统可执行程序的格式。<br><strong>优点</strong>：执行速度快、效率高<br><strong>缺点</strong>：依赖编译器、跨平台性差<br><strong>代表语言</strong>：C、C++、Delphi、Pascal、Fortran</p>
<a id="more"></a>
<p><strong>解释型语言</strong>：在运行程序的时候进行翻译，专门的解释器负责在每个语句执行的时候解释程序代码。<br><strong>优点</strong>：依赖解释器、跨平台性强<br><strong>缺点</strong>：执行速度慢、效率低<br><strong>代表语言</strong>：Java、Basic</p>
<h1 id="Java程序编译原理"><a href="#Java程序编译原理" class="headerlink" title="Java程序编译原理"></a>Java程序编译原理</h1><p>Java语言可以说是一种编译型-解释型语言，但这里的所谓的“编译”与传统的编译是不同的。Java程序很特殊，它也需要编译，但是没有直接编译成机器语言，而是将<strong>.java文件编译成与平台无关的字节码.class文件</strong>，class类文件不能在计算机上直接执行，它需要被<strong>Java虚拟机(JVM)</strong>翻译成本地的机器码后才能执行，而Java虚拟机(JVM)的翻译过程则是解释型的。</p>
<p>java字节码首先被加载至计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为<strong>java语言的解释执行</strong>。该过程是由java虚拟机完成的。我们可通过两条重要的命令<code>javac XXX.java</code>和<code>java XXX</code>来分别完成上面的编译和解释过程。</p>
<p><code>javac XXX.java</code>：将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p>
<p><code>java XXX</code>：解释前面生成的字节码，生成本地的机器码。</p>
<p>具体编译过程如下：<br><img src="http://i.imgur.com/wG9PZ4A.png" alt=""></p>
<h1 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机(JVM)"></a>Java虚拟机(JVM)</h1><p>JVM是java的核心和基础，是一种能够运行java字节码的虚拟机。JVM屏蔽了与具体操作平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>JVM执行程序的过程：</p>
<ul>
<li>加载.class文件</li>
<li>管理并分配内存</li>
<li>执行垃圾收集</li>
</ul>
<p><img src="http://i.imgur.com/jgzOLgu.png" width="50%" height="50%"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库索引]]></title>
      <url>http://gongchuangsu.com/2015/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p>
<h1 id="为什么要创建索引"><a href="#为什么要创建索引" class="headerlink" title="为什么要创建索引"></a>为什么要创建索引</h1><p>索引可以大大提高数据库的检索速度。</p>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ol>
<h1 id="创建索引的弊端"><a href="#创建索引的弊端" class="headerlink" title="创建索引的弊端"></a>创建索引的弊端</h1><p>索引虽然有很多优点，但并不是处处都可以创建索引。它也有许多不利的方面：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
</ol>
<h1 id="什么样的字段适合创建索引"><a href="#什么样的字段适合创建索引" class="headerlink" title="什么样的字段适合创建索引"></a>什么样的字段适合创建索引</h1><p>索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。<br>一般来说，应该在这些列上创建索引，例如：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度</li>
</ol>
<h1 id="什么样的字段不适合创建索引"><a href="#什么样的字段不适合创建索引" class="headerlink" title="什么样的字段不适合创建索引"></a>什么样的字段不适合创建索引</h1><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。<br>当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能</li>
</ol>
<h1 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h1><p>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建索引</span><br><span class="line">CREATE INDEX index_name ON table_name;</span><br><span class="line"></span><br><span class="line">// 删除索引</span><br><span class="line">DROP INDEX index_name;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：删除索引时应当特别小心，数据库的性能可能会因此而降低或者提高。</p>
</blockquote>
<h2 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h2><p>单列索引基于单一的字段创建，其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">	ON table_name (column_name);</span><br></pre></td></tr></table></figure></p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引不止用于提升查询性能，还用于保证数据完整性。唯一索引不允许向表中插入任何重复值。其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">	ON table_name (column_name);</span><br></pre></td></tr></table></figure></p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引在表中两个或更多的列的基础上建立。其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">	ON table_name (column1, column2);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：创建单列索引还是聚簇索引，要看每次查询中，哪些列在作为过滤条件的 WHERE 子句中最常出现。如果只需要一列，那么就应当创建单列索引。如果作为过滤条件的 WHERE 子句用到了两个或者更多的列，那么聚簇索引就是最好的选择。</p>
</blockquote>
<h2 id="隐式索引"><a href="#隐式索引" class="headerlink" title="隐式索引"></a>隐式索引</h2><p>隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQL命令]]></title>
      <url>http://gongchuangsu.com/2015/08/01/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>用于与关系型数据库交互的标准 SQL 命令有 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP，这些命令按用途分成如下几组：</p>
<h2 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言(DDL)"></a>数据定义语言(DDL)</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CREATE</td>
<td style="text-align:left">创建新的表、视图或者其他数据库中的对象</td>
</tr>
<tr>
<td style="text-align:left">ALTER</td>
<td style="text-align:left">修改现存数据库对象，比如一张表</td>
</tr>
<tr>
<td style="text-align:left">DROP</td>
<td style="text-align:left">删除表、视图或者数据库中的其他对象</td>
</tr>
</tbody>
</table>
<h2 id="数据操纵语言-DML"><a href="#数据操纵语言-DML" class="headerlink" title="数据操纵语言(DML)"></a>数据操纵语言(DML)</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SELECT</td>
<td style="text-align:left">从一张或者多张表中检索特定的数据</td>
</tr>
<tr>
<td style="text-align:left">INSERT</td>
<td style="text-align:left">创建一条新记录</td>
</tr>
<tr>
<td style="text-align:left">UPDATE</td>
<td style="text-align:left">修改记录</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">删除记录</td>
</tr>
</tbody>
</table>
<h2 id="数据控制语言-DCL"><a href="#数据控制语言-DCL" class="headerlink" title="数据控制语言(DCL)"></a>数据控制语言(DCL)</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GRANT</td>
<td style="text-align:left">赋予用户特权</td>
</tr>
<tr>
<td style="text-align:left">REVOKE</td>
<td style="text-align:left">收回赋予用户的特权</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQL学习笔记]]></title>
      <url>http://gongchuangsu.com/2015/08/01/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>创建名为<code>CUSTOMERS</code>数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE CUSTOMERS(</span><br><span class="line">	ID INT NOT NULL,</span><br><span class="line">	NAME VARCHAR (20) NOT NULL,</span><br><span class="line">	AGE INT NOT NULL,</span><br><span class="line">	ADDRESS CHAR (25) ,</span><br><span class="line">	SALARY DECIMAL (18, 2),</span><br><span class="line">	PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>NOT NULL 约束：保证列中数据不能有 NULL 值</li>
<li>DEFAULT 约束：提供该列数据未指定时所采用的默认值</li>
<li>UNIQUE 约束：保证列中的所有数据各不相同</li>
<li>主键约束：唯一标识数据表中的行/记录</li>
<li>外键约束：唯一标识其他表中的一条行/记录</li>
<li>CHECK 约束：此约束保证列中的所有值满足某一条件</li>
<li>索引：用于在数据库中快速创建或检索数据</li>
</ul>
<h2 id="NOT-NULL约束"><a href="#NOT-NULL约束" class="headerlink" title="NOT NULL约束"></a><code>NOT NULL</code>约束</h2><p>给某字段添加<code>NOT NULL</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	MODIFY SALARY DECIMAL (18, 2) NOT NULL;</span><br></pre></td></tr></table></figure></p>
<h2 id="DEFAULT约束"><a href="#DEFAULT约束" class="headerlink" title="DEFAULT约束"></a><code>DEFAULT</code>约束</h2><p>给某字段添加<code>DEFAULT</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	MODIFY SALARY DECIMAL (18, 2) DEFAULT 5000.00;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除某字段<code>DEFAULT</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	ALTER COLUMN SALARY DROP DEFAULT;</span><br></pre></td></tr></table></figure></p>
<h2 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a><code>UNIQUE</code>约束</h2><p>给某字段添加<code>UNIQUE</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	MODIFY AGE INT NOT NULL UNIQUE;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>将多个列定义<code>UNIQUE</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	ADD CONSTRAINT myUniqueConstraint UNIQUE(AGE, SALARY);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除<code>UNIQUE</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	DROP CONSTRAINT myUniqueConstraint;</span><br></pre></td></tr></table></figure></p>
<h2 id="主键-Primary-Key-约束"><a href="#主键-Primary-Key-约束" class="headerlink" title="主键(Primary Key)约束"></a>主键(Primary Key)约束</h2><p>将某个字段定义为主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	ADD PRIMARY (ID);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>将多个字段定义为主键(组合键)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	ADD CONSTRAINT PK_CUSTID PRIMARY KEY (ID, NAME);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure></p>
<h2 id="外键-FOREIGN-KEY-约束"><a href="#外键-FOREIGN-KEY-约束" class="headerlink" title="外键(FOREIGN KEY)约束"></a>外键(FOREIGN KEY)约束</h2><p>设置外键<br><code>CUSTOMERS</code> 表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE CUSTOMERS(</span><br><span class="line">	ID INT NOT NULL,</span><br><span class="line">	NAME VARCHAR (20) NOT NULL,</span><br><span class="line">	AGE INT NOT NULL,</span><br><span class="line">	ADDRESS CHAR (25) ,</span><br><span class="line">	SALARY DECIMAL (18, 2),</span><br><span class="line">	PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>ORDERS</code> 表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ORDERS (</span><br><span class="line">	ID INT NOT NULL,</span><br><span class="line">	DATE DATETIME,</span><br><span class="line">	CUSTOMER_ID INT references CUSTOMERS(ID),</span><br><span class="line">	AMOUNT double,</span><br><span class="line">	PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果 ORDERS 表已经存在，并且没有设置外键，那么可以使用下面的语法来修改数据表以指定外键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE ORDERS</span><br><span class="line">	ADD FOREIGN KEY (Customer_ID) REFERENCES CUSTOMERS (ID);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除外键约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE ORDERS</span><br><span class="line">	DROP FOREIGN KEY;</span><br></pre></td></tr></table></figure></p>
<h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a><code>CHECK</code>约束</h2><p>给某字段添加<code>CHECK</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	MODIFY AGE INT NOT NULL CHECK (AGE &gt;= 18 );</span><br><span class="line"></span><br><span class="line">// 或使用以下语法</span><br><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	ADD CONSTRAINT myCheckConstraint CHECK(AGE &gt;= 18);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除<code>CHECK</code>约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE CUSTOMERS</span><br><span class="line">	DROP CONSTRAINT myCheckConstraint;</span><br></pre></td></tr></table></figure></p>
<h2 id="索引约束"><a href="#索引约束" class="headerlink" title="索引约束"></a>索引约束</h2><p>创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">	ON table_name ( column1, column2.....);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>删除索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	DROP INDEX index_name;</span><br></pre></td></tr></table></figure></p>
<h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><p>完整性约束用于保证关系型数据库中数据的精确性和一致性。对于关系型数据库来说，数据完整性由参照完整性（referential integrity，RI）来保证。<br>有很多种约束可以起到参照完整性的作用，这些约束包括主键约束（Primary Key）、外键约束（Foreign Key）、唯一性约束（Unique Constraint）以及上面提到的其他约束。</p>
<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><ul>
<li>实体完整性：表中没有重复的行</li>
<li>域完整性：通过限制数据类型、格式或者范围来保证给定列的数据有效性</li>
<li>参照完整性：不能删除被其他记录引用的行</li>
<li>用户定义完整性：施加某些不属于上述三种完整性的业务规则</li>
</ul>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在 RDBMS 中，数据库名应该是唯一的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE DatabaseName;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE DatabaseName;</span><br></pre></td></tr></table></figure>
<h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p>如果你的数据库架构中有多个数据库同时存在，那么在开始操作之前必须先选定其中一个。<br><code>USE DatabaseName;</code></p>
<h2 id="显示现有数据库列表"><a href="#显示现有数据库列表" class="headerlink" title="显示现有数据库列表"></a>显示现有数据库列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>创建一个基本的表需要做的工作包括：命名表、定义列和各列的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">	column1 datatype,</span><br><span class="line">	column2 datatype,</span><br><span class="line">	column3 datatype,</span><br><span class="line">	.....</span><br><span class="line">	columnN datatype,</span><br><span class="line">	PRIMARY KEY( one or more columns )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>SQL DROP TABLE 语句用于移除表定义以及表中所有的数据、索引、触发器、约束和权限设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure></p>
<h2 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h2><p>SQL INSERT INTO 语句用于向数据库中的表添加新行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一种语法格式</span><br><span class="line">INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)</span><br><span class="line">VALUES (value1, value2, value3,...valueN);</span><br></pre></td></tr></table></figure></p>
<p>如果要为表中所有的字段都添加数据的话，就不需要指定字段名了。不过这种情况下，必须保证值的顺序按照表中字段出现的顺序排列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 第二种语法格式</span><br><span class="line">INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);</span><br></pre></td></tr></table></figure></p>
<h2 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h2><p>SQL SELECT 语句用于从数据库的表中取回所需的数据，并以表的形式返回。返回的表被称作结果集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name;</span><br></pre></td></tr></table></figure></p>
<p>这里，column1, column2…是你想要从表中取回的字段。如果要取回表中所有字段的话，可以使用下面的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name;</span><br></pre></td></tr></table></figure></p>
<h2 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h2><p>SQL UPDATE 语句用于修改表中现有的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2...., columnN = valueN</span><br><span class="line">WHERE [condition];</span><br></pre></td></tr></table></figure></p>
<h2 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h2><p>SQL DELETE 语句用于删除表中现有的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE [condition];</span><br></pre></td></tr></table></figure></p>
<h2 id="LIKE-子句"><a href="#LIKE-子句" class="headerlink" title="LIKE 子句"></a>LIKE 子句</h2><p>SQL LIKE 子句通过通配符来将一个值同其他相似的值作比较。可以同 LIKE 运算符一起使用的通配符有两个：</p>
<ol>
<li>百分号（%）:代表零个、一个或者多个字符</li>
<li>下划线（_）:代表单个数字或者字符</li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语句</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘200%’</td>
<td style="text-align:left">找出所有 200 开头的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘%200%’</td>
<td style="text-align:left">找出所有含有 200 的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘_00%’</td>
<td style="text-align:left">找出所有第二位和第三位为 0 的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘2<em>%</em>%’</td>
<td style="text-align:left">找出所有以 2 开始，并且长度至少为 3 的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘%2’</td>
<td style="text-align:left">找出所有以 2 结尾的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘_2%3’</td>
<td style="text-align:left">找出所有第二位为 2，并且以3结束的值</td>
</tr>
<tr>
<td style="text-align:left">WHERE SALARY LIKE ‘2___3’</td>
<td style="text-align:left">找出所有以 2 开头以 3 结束的五位数</td>
</tr>
</tbody>
</table>
<h2 id="TOP、LIMIT-和-ROWNUM-子句"><a href="#TOP、LIMIT-和-ROWNUM-子句" class="headerlink" title="TOP、LIMIT 和 ROWNUM 子句"></a>TOP、LIMIT 和 ROWNUM 子句</h2><p>这三个子句都是用于从一张数据表取回前N个或者X% 的记录。针对不同的数据库系统，使用不同的子句。Sql Server支持TOP子句，MySQL支持LIMIT子句，Oracle支持ROWNUM子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// TOP子句</span><br><span class="line">SELECT TOP number|percent column_name(s)</span><br><span class="line">	FROM table_name</span><br><span class="line">	WHERE [condition]</span><br><span class="line">// LIMIT子句</span><br><span class="line">SELECT * FROM CUSTOMERS</span><br><span class="line">	LIMIT 3;</span><br><span class="line">// ROWNUM子句</span><br><span class="line">SELECT * FROM CUSTOMERS</span><br><span class="line">	WHERE ROWNUM &lt;= 3;</span><br></pre></td></tr></table></figure></p>
<h2 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h2><p>SQL ORDER BY 子句根据一列或者多列的值，按照升序或者降序排列数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list</span><br><span class="line">	FROM table_name</span><br><span class="line">	[WHERE condition]</span><br><span class="line">	[ORDER BY column1, column2, .. columnN] [ASC | DESC];</span><br></pre></td></tr></table></figure></p>
<h2 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h2><p>SQL GROUP BY 子句与 SELECT 语句结合在一起使用，可以将相同数据分成一组。<br>在 SELECT 语句中，GROUP BY 子句紧随 WHERE 子句，在 ORDER BY 子句之前(如果有)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2</span><br><span class="line">	FROM table_name</span><br><span class="line">	WHERE [ conditions ]</span><br><span class="line">	GROUP BY column1, column2</span><br><span class="line">	ORDER BY column1, column2</span><br></pre></td></tr></table></figure></p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id  name  dept  salary  edlevel  hiredate   </span><br><span class="line">1 张三 开发部 2000 3 2009-10-11  </span><br><span class="line">2 李四 开发部 2500 3 2009-10-01  </span><br><span class="line">3 王五 设计部 2600 5 2010-10-02  </span><br><span class="line">4 王六 设计部 2300 4 2010-10-03  </span><br><span class="line">5 马七 设计部 2100 4 2010-10-06  </span><br><span class="line">6 赵八 销售部 3000 5 2010-10-05  </span><br><span class="line">7 钱九 销售部 3100 7 2010-10-07  </span><br><span class="line">8 孙十 销售部 3500 7 2010-10-06</span><br></pre></td></tr></table></figure></p>
<p>sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT dept, MAX(salary) AS MAXIMUM FROM STAFF GROUP BY dept</span><br></pre></td></tr></table></figure></p>
<p>查询结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dept  MAXIMUM   </span><br><span class="line">开发部 2500  </span><br><span class="line">设计部 2600  </span><br><span class="line">销售部 3500</span><br></pre></td></tr></table></figure></p>
<p>分析：使用<code>GROUP BY</code>对部门进行分组，然后对每个部门返回一个结果(一行记录)，即每个部门的最高薪水。</p>
<h2 id="DISTINCT-关键字"><a href="#DISTINCT-关键字" class="headerlink" title="DISTINCT 关键字"></a>DISTINCT 关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT column1, column2,.....columnN</span><br><span class="line">	FROM table_name</span><br><span class="line">	WHERE [condition]</span><br></pre></td></tr></table></figure>
<h1 id="SQL连接类型"><a href="#SQL连接类型" class="headerlink" title="SQL连接类型"></a>SQL连接类型</h1><p>SQL 中有多种不同的连接：</p>
<ul>
<li>内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。</li>
<li>左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。</li>
<li>右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。</li>
<li>全连接（FULL JOIN）：只要某一个表存在匹配，就返回行。</li>
<li>笛卡尔连接（CARTESIAN JOIN）：返回两个或者更多的表中记录集的笛卡尔积。</li>
</ul>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">INNER JOIN table2</span><br><span class="line">ON table1.common_field = table2.common_field;</span><br></pre></td></tr></table></figure>
<h2 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">LEFT JOIN table2</span><br><span class="line">ON table1.common_field = table2.common_field;</span><br></pre></td></tr></table></figure>
<h2 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">RIGHT JOIN table2</span><br><span class="line">ON table1.common_field = table2.common_field;</span><br></pre></td></tr></table></figure>
<h2 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">FULL JOIN table2</span><br><span class="line">ON table1.common_field = table2.common_field;</span><br></pre></td></tr></table></figure>
<h2 id="笛卡尔连接"><a href="#笛卡尔连接" class="headerlink" title="笛卡尔连接"></a>笛卡尔连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1, table2 [, table3 ]</span><br></pre></td></tr></table></figure>
<h1 id="UNION-子句"><a href="#UNION-子句" class="headerlink" title="UNION 子句"></a>UNION 子句</h1><p>SQL UNION 子句/运算符用于将两个或者更多的 SELECT 语句的运算结果组合起来。<br>在使用 UNION 的时候，每个 SELECT 语句必须有相同数量的选中列、相同数量的列表达式、相同的数据类型，并且它们出现的次序要一致，不过长度不一定要相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1 [, column2 ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">[WHERE condition1]</span><br><span class="line"></span><br><span class="line">UNION</span><br><span class="line"></span><br><span class="line">SELECT column1 [, column2 ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">[WHERE condition1]</span><br></pre></td></tr></table></figure></p>
<h1 id="NULL-值"><a href="#NULL-值" class="headerlink" title="NULL 值"></a>NULL 值</h1><p>SQL 中，NULL 用于表示缺失的值。数据表中的 NULL 值表示该值所处的字段为空。NULL 值与 0 或者包含空白（spaces）的字段是不同的，更多的表示的是未知。</p>
<h1 id="别名-Alias"><a href="#别名-Alias" class="headerlink" title="别名(Alias)"></a>别名(Alias)</h1><p>使用别名（Alias）可以对数据表或者列进行临时命名。<br>表别名的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2....</span><br><span class="line">	FROM table_name AS alias_name</span><br><span class="line">	WHERE [condition];</span><br></pre></td></tr></table></figure></p>
<p>列别名的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name AS alias_name</span><br><span class="line">	FROM table_name</span><br><span class="line">	WHERE [condition];</span><br></pre></td></tr></table></figure></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。简单说来，索引就是指向表中数据的指针。数据库的索引同书籍后面的索引非常相像。<br>索引能够提高 SELECT 查询和 WHERE 子句的速度，但是却降低了包含 UPDATE 语句或 INSERT 语句的数据输入过程的速度。索引的创建与删除不会对表中的数据产生影响。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建索引</span><br><span class="line">CREATE INDEX index_name ON table_name;</span><br><span class="line"></span><br><span class="line">// 删除索引</span><br><span class="line">DROP INDEX index_name;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：删除索引时应当特别小心，数据库的性能可能会因此而降低或者提高。</p>
</blockquote>
<h2 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h2><p>单列索引基于单一的字段创建，其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">	ON table_name (column_name);</span><br></pre></td></tr></table></figure></p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引不止用于提升查询性能，还用于保证数据完整性。唯一索引不允许向表中插入任何重复值。其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">	ON table_name (column_name);</span><br></pre></td></tr></table></figure></p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引在表中两个或更多的列的基础上建立。其基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">	ON table_name (column1, column2);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：创建单列索引还是聚簇索引，要看每次查询中，哪些列在作为过滤条件的 WHERE 子句中最常出现。如果只需要一列，那么就应当创建单列索引。如果作为过滤条件的 WHERE 子句用到了两个或者更多的列，那么聚簇索引就是最好的选择。</p>
</blockquote>
<h2 id="隐式索引"><a href="#隐式索引" class="headerlink" title="隐式索引"></a>隐式索引</h2><p>隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。</p>
<h2 id="什么时候应当避免使用索引"><a href="#什么时候应当避免使用索引" class="headerlink" title="什么时候应当避免使用索引"></a>什么时候应当避免使用索引</h2><p>尽管创建索引的目的是提升数据库的性能，但是还是有一些情况应当避免使用索引。</p>
<ul>
<li>小的数据表不应当使用索引</li>
<li>需要频繁进行大批量的更新或者插入操作的表</li>
<li>如果列中包含大数或者 NULL 值，不宜创建索引</li>
<li>频繁操作的列不宜创建索引</li>
</ul>
<h1 id="ALTER-TABLE-命令"><a href="#ALTER-TABLE-命令" class="headerlink" title="ALTER TABLE 命令"></a>ALTER TABLE 命令</h1><p>SQL ALTER TABLE 命令用于添加、删除或者更改现有数据表中的列。还可以用 ALTER TABLE 命令来添加或者删除现有数据表上的约束。</p>
<ul>
<li><p>添加列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD column_name datatype;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改现有列的数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY COLUMN column_name datatype;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加NOT NULL约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY column_name datatype NOT NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加唯一约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加CHECK约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加主键约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	DROP CONSTRAINT MyUniqueConstraint;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">	DROP CONSTRAINT MyPrimaryKey;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="TRUNCATE-TABLE-命令"><a href="#TRUNCATE-TABLE-命令" class="headerlink" title="TRUNCATE TABLE 命令"></a>TRUNCATE TABLE 命令</h1><p>SQL TRUNCATE TABLE 命令用于删除现有数据表中的所有数据。<br>与DROP TABLE 命令不同的是，DROP TABLE 命令不但会删除表中所有数据，还会将整个表结构从数据库中移除。如果想要重新向表中存储数据的话，必须重建该数据表。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br></pre></td></tr></table></figure></p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图无非就是存储在数据库中并具有名字的 SQL 语句，或者说是以预定义的 SQL 查询的形式存在的数据表的成分。<br>视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。<br>视图，一种虚拟的表，允许用户执行以下操作：</p>
<ul>
<li>以用户或者某些类型的用户感觉自然或者直观的方式来组织数据；</li>
<li>限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据；</li>
<li>从多个表中汇总数据，以产生报表。</li>
</ul>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>CREATE VIEW 语句的基本语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS</span><br><span class="line">	SELECT column1, column2.....</span><br><span class="line">	FROM table_name</span><br><span class="line">	WHERE [condition];</span><br></pre></td></tr></table></figure></p>
<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>视图可以在特定的情况下更新：</p>
<ul>
<li>SELECT 子句不能包含 DISTINCT 关键字</li>
<li>SELECT 子句不能包含任何汇总函数（summary functions）</li>
<li>SELECT 子句不能包含任何集合函数（set functions）</li>
<li>SELECT 子句不能包含任何集合运算符（set operators）</li>
<li>SELECT 子句不能包含 ORDER BY 子句</li>
<li>FROM 子句中不能有多个数据表</li>
<li>WHERE 子句不能包含子查询（subquery）</li>
<li>查询语句中不能有 GROUP BY 或者 HAVING</li>
<li>计算得出的列不能更新</li>
<li>视图必须包含原始数据表中所有的 NOT NULL 列，否则 INSERT 操作生效</li>
</ul>
<p>如果视图满足以上所有的条件，该视图就可以被更新。最终更新的还是原始数据表，只是其结果反应在了视图上。</p>
<h2 id="向视图中插入新行"><a href="#向视图中插入新行" class="headerlink" title="向视图中插入新行"></a>向视图中插入新行</h2><p>可以向视图中插入新行，其规则同（使用 UPDATE 命令）更新视图所遵循的规则相同。</p>
<h2 id="删除视图中的行"><a href="#删除视图中的行" class="headerlink" title="删除视图中的行"></a>删除视图中的行</h2><p>视图中的数据行可以被删除。删除数据行与更新视图和向视图中插入新行遵循相同的规则。</p>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>基本语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW view_name;</span><br></pre></td></tr></table></figure></p>
<h1 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h1><p>HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。</p>
<blockquote>
<p>与WHERE 子句的区别：WHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。</p>
</blockquote>
<p>HAVING 子句在 SELECT 查询中的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2</span><br><span class="line">FROM table1, table2</span><br><span class="line">WHERE [ conditions ]</span><br><span class="line">GROUP BY column1, column2</span><br><span class="line">HAVING [ conditions ]</span><br><span class="line">ORDER BY column1, column2</span><br></pre></td></tr></table></figure></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是在数据库上按照一定的逻辑顺序执行的任务序列。事务实际上就是对数据库的一个或者多个更改。当你在某张表上创建更新或者删除记录的时，你就已经在使用事务了。控制事务以保证数据完整性，并对数据库错误做出处理，对数据库来说非常重要。</p>
<h2 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h2><p>事务具有以下四个标准属性，通常用缩略词 ACID 来表示：</p>
<ul>
<li>原子性：保证任务中的所有操作都执行完毕；否则，事务会在出现错误时终止，并回滚之前所有操作到原始状态。</li>
<li>一致性：如果事务成功执行，则数据库的状态得到了进行了正确的转变。</li>
<li>隔离性：保证不同的事务相互独立、透明地执行。</li>
<li>持久性：即使出现系统故障，之前成功执行的事务的结果也会持久存在。</li>
</ul>
<h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>有四个命令用于控制事务：</p>
<ul>
<li>COMMIT：提交更改；</li>
<li>ROLLBACK：回滚更改；</li>
<li>SAVEPOINT：在事务内部创建一系列可以 ROLLBACK 的还原点；</li>
<li>SET TRANSACTION：命名事务；</li>
</ul>
<h3 id="COMMIT-命令"><a href="#COMMIT-命令" class="headerlink" title="COMMIT 命令"></a>COMMIT 命令</h3><p>COMMIT 命令用于保存事务对数据库所做的更改。COMMIT 命令会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></p>
<h3 id="ROLLBACK-命令"><a href="#ROLLBACK-命令" class="headerlink" title="ROLLBACK 命令"></a>ROLLBACK 命令</h3><p>ROLLBACK 命令用于撤销尚未保存到数据库中的事务。ROLLBACK 命令只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></p>
<h3 id="SAVEPOINT-命令"><a href="#SAVEPOINT-命令" class="headerlink" title="SAVEPOINT 命令"></a>SAVEPOINT 命令</h3><p>SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT SAVEPOINT_NAME;</span><br></pre></td></tr></table></figure></p>
<p>回滚至某一保存点的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK TO SAVEPOINT_NAME;</span><br></pre></td></tr></table></figure></p>
<p>删除先前创建的保存点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT SAVEPOINT_NAME;</span><br></pre></td></tr></table></figure></p>
<p>保存点一旦被释放，你就不能够再用 ROLLBACK 命令来撤销该保存点之后的事务了。</p>
<h3 id="SET-TRANSACTION-命令"><a href="#SET-TRANSACTION-命令" class="headerlink" title="SET TRANSACTION 命令"></a>SET TRANSACTION 命令</h3><p>SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。<br>例如，你可以将某个事务指定为只读或者读写。SET TRANSACTION 命令的语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION [ READ WRITE | READ ONLY ];</span><br></pre></td></tr></table></figure></p>
<h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><p>某些关系型数据库管理系统支持临时表。临时表是一项很棒的特性，能够让你像操作普通的 SQL 数据表一样，使用 SELECT、UPDATE 和 JOIN 等功能来存储或者操作中间结果。<br>临时表有时候对于保存临时数据非常有用。有关临时表你需要知道的最重要的一点是，它们会在当前的终端会话结束后被删除。<br>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建临时表</span><br><span class="line">CREATE TEMPORARY TABLE SALESSUMMARY</span><br><span class="line"></span><br><span class="line">// 删除临时表</span><br><span class="line">DROP TABLE SALESSUMMARY;</span><br></pre></td></tr></table></figure></p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询（Sub Query）或者说内查询（Inner Query），也可以称作嵌套查询（Nested Query），是一种嵌套在其他 SQL 查询的 WHERE 子句中的查询。<br>使用子查询必须遵循以下几个规则：</p>
<ul>
<li>子查询必须括在圆括号中。</li>
<li>子查询的 SELECT 子句中只能有一个列，除非主查询中有多个列，用于与子查询选中的列相比较。</li>
<li>子查询不能使用 ORDER BY，不过主查询可以。在子查询中，GROUP BY 可以起到同 ORDER BY 相同的作用。</li>
<li>返回多行数据的子查询只能同多值操作符一起使用，比如 IN 操作符。</li>
<li>SELECT 列表中不能包含任何对 BLOB、ARRAY、CLOB 或者 NCLOB 类型值的引用。</li>
<li>子查询不能直接用在集合函数中。</li>
<li>BETWEEN 操作符不能同子查询一起使用，但是 BETWEEN 操作符可以用在子查询中。</li>
</ul>
<h2 id="SELECT-语句中的子查询"><a href="#SELECT-语句中的子查询" class="headerlink" title="SELECT 语句中的子查询"></a>SELECT 语句中的子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM CUSTOMERS</span><br><span class="line">	WHERE ID IN (SELECT ID</span><br><span class="line">	FROM CUSTOMERS</span><br><span class="line">	WHERE SALARY &gt; 4500) ;</span><br></pre></td></tr></table></figure>
<h2 id="INSERT-语句中的子查询"><a href="#INSERT-语句中的子查询" class="headerlink" title="INSERT 语句中的子查询"></a>INSERT 语句中的子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CUSTOMERS 表和CUSTOMERS_BKP 表拥有相似的结构</span><br><span class="line">INSERT INTO CUSTOMERS_BKP</span><br><span class="line">	SELECT * FROM CUSTOMERS</span><br><span class="line">	WHERE ID IN (SELECT ID</span><br><span class="line">	FROM CUSTOMERS) ;</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE-语句中的子查询"><a href="#UPDATE-语句中的子查询" class="headerlink" title="UPDATE 语句中的子查询"></a>UPDATE 语句中的子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE CUSTOMERS</span><br><span class="line">	SET SALARY = SALARY * 0.25</span><br><span class="line">	WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP</span><br><span class="line">	WHERE AGE &gt;= 27 );</span><br></pre></td></tr></table></figure>
<h2 id="DELETE-语句中的子查询"><a href="#DELETE-语句中的子查询" class="headerlink" title="DELETE 语句中的子查询"></a>DELETE 语句中的子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM CUSTOMERS</span><br><span class="line">	WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP</span><br><span class="line">	WHERE AGE &gt; 27 );</span><br></pre></td></tr></table></figure>
<h1 id="使用序列"><a href="#使用序列" class="headerlink" title="使用序列"></a>使用序列</h1><p>序列是根据需要产生的一组有序整数：1, 2, 3 … 序列在数据库中经常用到，因为许多应用要求数据表中的的每一行都有一个唯一的值，序列为此提供了一种简单的方法。</p>
<h2 id="使用-AUTO-INCREMENT-列"><a href="#使用-AUTO-INCREMENT-列" class="headerlink" title="使用 AUTO_INCREMENT 列"></a>使用 AUTO_INCREMENT 列</h2><p>在 MySQL 中使用序列最简单的方式是，把某列定义为 AUTO_INCREMENT，然后将剩下的事情交由 MySQL 处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">id INT UNSIGNED NOT NULL AUTO_INCREMENT</span><br><span class="line">...</span><br><span class="line">// 默认情况下，MySQL 中序列的起始值为 1,也可以设置为其他值</span><br><span class="line">...</span><br><span class="line">id INT UNSIGNED NOT NULL AUTO_INCREMENT = 100</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h1 id="SQL-常用函数"><a href="#SQL-常用函数" class="headerlink" title="SQL 常用函数"></a>SQL 常用函数</h1><table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">COUNT 函数</td>
<td style="text-align:left">用于统计返回的记录数</td>
</tr>
<tr>
<td style="text-align:center">MAX 函数</td>
<td style="text-align:left">用于找出记录集中具有最大值的记录</td>
</tr>
<tr>
<td style="text-align:center">MIN 函数</td>
<td style="text-align:left">用于找出记录集中具有最大值的记录</td>
</tr>
<tr>
<td style="text-align:center">AVG 函数</td>
<td style="text-align:left">用于找出表中记录在某字段处的平均值</td>
</tr>
<tr>
<td style="text-align:center">SUM 函数</td>
<td style="text-align:left">用于找出表中记录在某字段处的总和</td>
</tr>
<tr>
<td style="text-align:center">SQRT 函数</td>
<td style="text-align:left">用于计算得出任何数值的平方根</td>
</tr>
<tr>
<td style="text-align:center">RAND 函数</td>
<td style="text-align:left">用于产生 0 至 1 之间的随机数</td>
</tr>
<tr>
<td style="text-align:center">CONCAT 函数</td>
<td style="text-align:left">用于将两个字符串连接为一个字符串</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第五篇 学习OpenCV之视频处理]]></title>
      <url>http://gongchuangsu.com/2015/07/29/OpenCV/%E7%AC%AC%E4%BA%94%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong>源代码：</strong><br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.26</span></span><br><span class="line"><span class="comment">// 说明：从视频文件中读入数据，将读入数据转换为灰度图，对图像做Canny边缘检测。</span></span><br><span class="line"><span class="comment">//       将上面三个步骤实现显示在一个图像中，并在图像的三个不同部分写上合适的</span></span><br><span class="line"><span class="comment">//       标签,同时在这幅图像中任何地方点击鼠标，将当前图像的坐标显示于点击鼠标处。</span></span><br><span class="line"><span class="comment">// 注意：当R = G = B时为灰度色。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")</span></span><br><span class="line"><span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">30</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"><span class="comment">// 定义 Canny 边缘检测函数</span></span><br><span class="line"><span class="function">IplImage* <span class="title">doCanny</span><span class="params">(</span><br><span class="line">    IplImage* in,</span><br><span class="line">    <span class="keyword">int</span> lowThresh,</span><br><span class="line">    <span class="keyword">int</span> highThresh,</span><br><span class="line">    <span class="keyword">int</span> aperture</span><br><span class="line">    )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( in-&gt;nChannels != <span class="number">1</span>)  <span class="comment">// Canny只能处理灰度图片</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">        IplImage* out = cvCreateImage(</span><br><span class="line">            cvGetSize( in ),</span><br><span class="line">            in-&gt;depth,</span><br><span class="line">            in-&gt;nChannels</span><br><span class="line">            );</span><br><span class="line">        cvCanny( in, out, lowThresh, highThresh, aperture );</span><br><span class="line">        <span class="keyword">return</span>( out );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义鼠标回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_mouse_callback</span><span class="params">( <span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( event == CV_EVENT_LBUTTONDOWN)&#123;</span><br><span class="line">        col = x;</span><br><span class="line">        row = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义 Canny 边缘检测的阈值</span></span><br><span class="line">    <span class="keyword">int</span> thresh = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 定义字体相关属性</span></span><br><span class="line">    CvFont font;</span><br><span class="line">    cvInitFont( &amp;font, CV_FONT_HERSHEY_PLAIN, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *AviName=<span class="string">"MV.mp4"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *WindowsTitle = <span class="string">"Merge"</span>;</span><br><span class="line">    cvNamedWindow( WindowsTitle, <span class="number">1</span>);</span><br><span class="line">    CvCapture *capture=cvCreateFileCapture(AviName);</span><br><span class="line">    <span class="comment">// 取得视频文件的大小并输出 </span></span><br><span class="line">    CvSize size = cvSize(</span><br><span class="line">        (<span class="keyword">int</span>)cvGetCaptureProperty( capture, CV_CAP_PROP_FRAME_WIDTH),</span><br><span class="line">        (<span class="keyword">int</span>)cvGetCaptureProperty( capture, CV_CAP_PROP_FRAME_HEIGHT)</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// 创建图像 </span></span><br><span class="line">    IplImage *src = cvCreateImage( size, IPL_DEPTH_8U, <span class="number">3</span>);</span><br><span class="line">    IplImage *dst_gray = cvCreateImage( size, IPL_DEPTH_8U, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_canny = cvCreateImage( size, IPL_DEPTH_8U, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_merge = cvCreateImage( cvSize( size.width*<span class="number">3</span>, size.height), IPL_DEPTH_8U, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 创建三个图像头，分别指向图像 dst_merge 的开始处、1/3处、2/3处</span></span><br><span class="line">    IplImage *src_header = cvCreateImageHeader( size, IPL_DEPTH_8U, <span class="number">3</span>);</span><br><span class="line">    src_header-&gt;origin = dst_merge-&gt;origin;</span><br><span class="line">    src_header-&gt;widthStep = dst_merge-&gt;widthStep;</span><br><span class="line">    src_header-&gt;imageData = dst_merge-&gt;imageData;</span><br><span class="line">    IplImage *dst_gray_header = cvCreateImageHeader( size, IPL_DEPTH_8U, <span class="number">3</span>);</span><br><span class="line">    dst_gray_header-&gt;origin = dst_merge-&gt;origin;</span><br><span class="line">    dst_gray_header-&gt;widthStep = dst_merge-&gt;widthStep;</span><br><span class="line">    dst_gray_header-&gt;imageData = dst_merge-&gt;imageData + dst_merge-&gt;widthStep/<span class="number">3</span>;</span><br><span class="line">    IplImage *dst_canny_header = cvCreateImageHeader( size, IPL_DEPTH_8U, <span class="number">3</span>);</span><br><span class="line">    dst_canny_header-&gt;origin = dst_merge-&gt;origin;</span><br><span class="line">    dst_canny_header-&gt;widthStep = dst_merge-&gt;widthStep;</span><br><span class="line">    dst_canny_header-&gt;imageData = dst_merge-&gt;imageData + dst_merge-&gt;widthStep*<span class="number">2</span>/<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 创建图像头 dst_gray_header 的单通道 r ，g ，b 图像</span></span><br><span class="line">    IplImage *dst_gray_header_r = cvCreateImage( cvGetSize(dst_gray_header), dst_gray_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_gray_header_g = cvCreateImage( cvGetSize(dst_gray_header), dst_gray_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_gray_header_b = cvCreateImage( cvGetSize(dst_gray_header), dst_gray_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建图像头 dst_canny_header 的单通道 r ，g ，b 图像</span></span><br><span class="line">    IplImage *dst_canny_header_r = cvCreateImage( cvGetSize(dst_canny_header), dst_canny_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_canny_header_g = cvCreateImage( cvGetSize(dst_canny_header), dst_canny_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    IplImage *dst_canny_header_b = cvCreateImage( cvGetSize(dst_canny_header), dst_canny_header-&gt;depth, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 读取视频并转换</span></span><br><span class="line">    <span class="keyword">while</span>( (src = cvQueryFrame(capture)) != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将原始图像拷贝给指向合并图像开始处的图像头</span></span><br><span class="line">        cvCopy( src, src_header);</span><br><span class="line">        <span class="comment">// 将原始图像转换为灰度图像</span></span><br><span class="line">        cvConvertImage( src, dst_gray);</span><br><span class="line">        <span class="comment">// 将灰度图像头分割成红、绿、蓝三个单通道图像，并将灰度图像拷贝给三个单通道图像，然后再将三个单通道</span></span><br><span class="line">        <span class="comment">// 合并，以使灰度图像头显示的是灰度图像。</span></span><br><span class="line">        cvZero(dst_gray_header);</span><br><span class="line">        cvSplit( dst_gray_header, dst_gray_header_r, dst_gray_header_g, dst_gray_header_b, <span class="number">0</span>);</span><br><span class="line">        cvCopy( dst_gray, dst_gray_header_r);</span><br><span class="line">        cvCopy( dst_gray, dst_gray_header_g);</span><br><span class="line">        cvCopy( dst_gray, dst_gray_header_b);</span><br><span class="line">        cvMerge( dst_gray_header_r, dst_gray_header_g, dst_gray_header_b, <span class="number">0</span>, dst_gray_header);</span><br><span class="line">        <span class="comment">// 将灰度图像进行 Canny 边缘检测处理</span></span><br><span class="line">        dst_canny = doCanny( dst_gray, thresh, <span class="number">3</span>*thresh, <span class="number">3</span>);</span><br><span class="line">        cvZero(dst_canny_header);</span><br><span class="line">        cvSplit( dst_canny_header, dst_canny_header_r, dst_canny_header_g, dst_canny_header_b, <span class="number">0</span>);</span><br><span class="line">        cvCopy( dst_canny, dst_canny_header_r);</span><br><span class="line">        cvCopy( dst_canny, dst_canny_header_g);</span><br><span class="line">        cvCopy( dst_canny, dst_canny_header_b);</span><br><span class="line">        cvMerge( dst_canny_header_r, dst_canny_header_g, dst_canny_header_b, <span class="number">0</span>, dst_canny_header);</span><br><span class="line">        <span class="comment">// 在合并图像的三个不同处显示相应的文字</span></span><br><span class="line">        cvPutText( dst_merge, <span class="string">"Color"</span>, cvPoint(<span class="number">315</span>,<span class="number">25</span>), &amp;font, cvScalar( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">        cvPutText( dst_merge, <span class="string">"Gray"</span>, cvPoint(<span class="number">315</span>*<span class="number">3</span>,<span class="number">25</span>), &amp;font, cvScalar( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">        cvPutText( dst_merge, <span class="string">"Canny"</span>, cvPoint(<span class="number">315</span>*<span class="number">5</span>,<span class="number">25</span>), &amp;font, cvScalar( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">        cvShowImage( WindowsTitle, dst_merge);</span><br><span class="line">        <span class="comment">// 设置鼠标回调函数</span></span><br><span class="line">        cvSetMouseCallback(</span><br><span class="line">            WindowsTitle,</span><br><span class="line">            my_mouse_callback,</span><br><span class="line">            (<span class="keyword">void</span> *)dst_merge</span><br><span class="line">            );</span><br><span class="line">        <span class="comment">// 输出坐标值</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"( x, y) = "</span>&lt;&lt;<span class="string">"( "</span>&lt;&lt;col&lt;&lt;<span class="string">", "</span>&lt;&lt;row&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">memset</span>( str, <span class="number">0</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 将格式化的数据写入字符串缓冲区</span></span><br><span class="line">        <span class="built_in">sprintf</span>( str, <span class="string">"( %d, %d)"</span>,col,row);</span><br><span class="line">        <span class="comment">// 将字符串显示在相应的图像位置</span></span><br><span class="line">        cvPutText( dst_merge, str, cvPoint(col,row), &amp;font, cvScalar( <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)); </span><br><span class="line">        cvShowImage(WindowsTitle,dst_merge);</span><br><span class="line">        <span class="comment">// 等待按键触发</span></span><br><span class="line">        <span class="keyword">char</span> c = cvWaitKey(<span class="number">33</span>);</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源，销毁窗口</span></span><br><span class="line">    cvReleaseCapture(&amp;capture);</span><br><span class="line">    cvReleaseImage(&amp;dst_merge);</span><br><span class="line">    cvReleaseImage(&amp;src);</span><br><span class="line">    cvReleaseImage(&amp;dst_gray);</span><br><span class="line">    cvReleaseImage(&amp;dst_canny);</span><br><span class="line">    cvReleaseImageHeader(&amp;src_header);</span><br><span class="line">    cvReleaseImageHeader(&amp;dst_gray_header);</span><br><span class="line">    cvReleaseImageHeader(&amp;dst_canny_header);</span><br><span class="line">    cvReleaseImage(&amp;dst_gray_header_r);</span><br><span class="line">    cvReleaseImage(&amp;dst_gray_header_g);</span><br><span class="line">    cvReleaseImage(&amp;dst_gray_header_b);</span><br><span class="line">    cvReleaseImage(&amp;dst_canny_header_r);</span><br><span class="line">    cvReleaseImage(&amp;dst_canny_header_g);</span><br><span class="line">    cvReleaseImage(&amp;dst_canny_header_b);</span><br><span class="line">    cvDestroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果：</strong><br><img src="http://i.imgur.com/QUBJ2EE.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第四篇 学习OpenCV之访问图像数据]]></title>
      <url>http://gongchuangsu.com/2015/07/25/OpenCV/%E7%AC%AC%E5%9B%9B%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E8%AE%BF%E9%97%AE%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这一篇，我们主要学习OpenCV矩阵和图像类型以及如何访问矩阵和图像数据。<br><img src="http://i.imgur.com/7rZH9lK.jpg" alt=""><br>在开始探讨图像细节之前，我们需要先了解另一种数据类型<code>CvMat</code>，OpenCV的矩阵结构。虽然OpenCV完全由C语言实现，但<code>CvMat</code>和<code>IplImage</code>之间的关系就如同C++中的继承关系。实质上，<code>IplImage</code>可以被视为从<code>CvMat</code>中派生的。因此，在试图了解复杂的派生类之前，最好先了解基本的类。第三个类<code>CvArr</code>，可以被视为一个抽象基类，<code>CvMat</code>由它派生。</p>
<a id="more"></a>
<h1 id="CvMat矩阵结构"><a href="#CvMat矩阵结构" class="headerlink" title="CvMat矩阵结构"></a>CvMat矩阵结构</h1><h2 id="矩阵头"><a href="#矩阵头" class="headerlink" title="矩阵头"></a>矩阵头</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> CvMat</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">// 矩阵元素的数据类型</span></span><br><span class="line">    <span class="keyword">int</span> step; <span class="comment">// 全行的字节长度（单位为字节）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for internal use only */</span></span><br><span class="line">    <span class="keyword">int</span>* refcount;</span><br><span class="line">    <span class="keyword">int</span> hdr_refcount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        uchar* ptr; <span class="comment">// pointer to 8-bit unsigned elements</span></span><br><span class="line">        <span class="keyword">short</span>* s;   <span class="comment">// pointer to 16-bit signed elements</span></span><br><span class="line">        <span class="keyword">int</span>* i;     <span class="comment">// pointer to 32-bit signed elements</span></span><br><span class="line">        <span class="keyword">float</span>* fl;  <span class="comment">// pointer to 32-bit floating-point elements</span></span><br><span class="line">        <span class="keyword">double</span>* db; <span class="comment">// pointer to 64-bit floating-point elements</span></span><br><span class="line">    &#125; data; <span class="comment">// Pointers to the actual matrix data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> rows;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cols;</span><br><span class="line">        <span class="keyword">int</span> width;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; CvMat;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>： </p>
<ol>
<li>矩阵的元素<code>data</code>是一个联合体，它是指向实际矩阵数据的指针。对这个指针解引用的时候，必须指明结构体中的正确的元素以便得到正确的指针类型。 </li>
<li><code>CvMat</code>结构中为了兼容<code>IplImage</code>结构，有宽度和高度的概念，这个概念已经被最新的行和列取代。</li>
</ol>
<h2 id="矩阵数据的存取"><a href="#矩阵数据的存取" class="headerlink" title="矩阵数据的存取"></a>矩阵数据的存取</h2><p>访问矩阵中的数据有三种方法：简单的方法、麻烦的方法和恰当的方法。 </p>
<h3 id="简单的方法"><a href="#简单的方法" class="headerlink" title="简单的方法"></a>简单的方法</h3><p>从矩阵中得到一个元素的最简单的方法是利用<code>CV_MAT_ELEM()</code>和<code>CV_MAT_ELEM_PTR()</code>宏。<br><strong>例1：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.20</span></span><br><span class="line"><span class="comment">// 说明：利用CV_MAT_ELEM()和CV_MAT_ELEM_PTR()宏存取矩阵数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵</span></span><br><span class="line">    CvMat *srcMat = cvCreateMat( <span class="number">250</span>, <span class="number">250</span>, CV_32FC1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"srcMat-&gt;step = %d\n"</span>,srcMat-&gt;step);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"srcMat-&gt;width = %d\n"</span>,srcMat-&gt;width);</span><br><span class="line">    <span class="comment">// 清空数组</span></span><br><span class="line">    cvZero(srcMat);</span><br><span class="line">    <span class="comment">// 利用CV_MAT_ELEM()宏返回提取出的元素的值</span></span><br><span class="line">    <span class="keyword">float</span> element_125_125 = CV_MAT_ELEM( *srcMat, <span class="keyword">float</span>, <span class="number">125</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before set: elemrnt_125_125 = %f\n"</span>,element_125_125);</span><br><span class="line">    <span class="comment">// 利用CV_MAT_ELEM_PTR()宏为矩阵的某个元素设置一个数值</span></span><br><span class="line">    element_125_125 = <span class="number">7.7</span>;</span><br><span class="line">    *((<span class="keyword">float</span> *)CV_MAT_ELEM_PTR( *srcMat, <span class="number">125</span>, <span class="number">125</span>)) = element_125_125;</span><br><span class="line">    <span class="comment">// 利用CV_MAT_ELEM_PTR()宏返回提取出的元素的值</span></span><br><span class="line">    element_125_125 = *((<span class="keyword">float</span> *)CV_MAT_ELEM_PTR( *srcMat, <span class="number">125</span>, <span class="number">125</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After set: elemrnt_125_125 = %f\n"</span>,element_125_125);</span><br><span class="line">    <span class="comment">// 创建窗口，显示矩阵</span></span><br><span class="line">    cvNamedWindow(<span class="string">"Easy way"</span>);</span><br><span class="line">    cvShowImage(<span class="string">"Easy way"</span>, srcMat);</span><br><span class="line">    <span class="comment">// 等待按键，释放内存</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    cvReleaseMat(&amp;srcMat);</span><br><span class="line">    cvDestroyWindow( <span class="string">"Easy way"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果： </strong><br><img src="http://i.imgur.com/nAtNjZm.jpg" alt=""><br><img src="http://i.imgur.com/RfYVlEK.jpg" alt=""><br><strong>说明：</strong> </p>
<ol>
<li><p><code>CV_MAT_ELEM()</code>宏原型：<code>CV_MAT_ELEM( mat, elemtype, row, col )</code><br><code>mat</code>：传入的矩阵。<br><code>elemtype</code>：待提取的元素的类型。<br><code>row</code>：行数。<br><code>col</code>：列数</p>
</li>
<li><p><code>CV_MAT_ELEM_PTR()</code>宏原型：<code>CV_MAT_ELEM_PTR( mat, row, col )</code><br>参数说明同上。</p>
</li>
<li>这两个宏最重要的区别是后者在指针解引用之前将其转化成指定的类型。如果需要同时读取数据和设置数据，可以直接调用<code>CV_MAT_ELEM_PTR()</code>。但在这种情况下，必须自己将指针转化成恰当的类型（具体可通过程序来体会）。 </li>
<li>通过程序可以看出，这些宏在每次调用时都重新计算指针，首先要查找指向矩阵基本元素数据区的指针、计算目标数据在矩阵中的相对地址，然后将相对位置与基本位置相加。所以这种方法虽然简单直接，但不是存取矩阵数据的最佳方法。在计划顺序访问矩阵中的所有元素时，这种方法的缺点尤为突出。</li>
</ol>
<h3 id="麻烦的方法"><a href="#麻烦的方法" class="headerlink" title="麻烦的方法"></a>麻烦的方法</h3><p>简单的方法”中讨论的两个宏仅仅适用于访问1维或2维的数组。事实上，OpenCV可以支持普通的N维的数组，这个N值可以取值为任意大的数。<br>为了访问普通矩阵中的数据，我们可以利用<code>cvPtr*D</code>和<code>cvGet*D</code>…等函数族。<br><strong>例2：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.20</span></span><br><span class="line"><span class="comment">// 说明：利用函数族cvPtr*D遍历矩阵，对矩阵元素的通道值进行相关的设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵：行数-&gt;250 列数-&gt;250 元素类型-&gt;32位浮点型三通道</span></span><br><span class="line">    CvMat *srcMat = cvCreateMat( <span class="number">250</span>, <span class="number">250</span>, CV_32FC3);</span><br><span class="line">    <span class="comment">// 清空数组</span></span><br><span class="line">    cvSetZero(srcMat);</span><br><span class="line">    <span class="comment">// 显示矩阵的行数据长度（字节）、宽度（元素）、高度（元素）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;step = "</span> &lt;&lt; srcMat-&gt;step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;rows = "</span> &lt;&lt; srcMat-&gt;rows &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;cols = "</span> &lt;&lt; srcMat-&gt;cols &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 循环扫描、设置</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( row = <span class="number">0</span>; row &lt; srcMat-&gt;rows; row++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( col = <span class="number">0</span>; col &lt; srcMat-&gt;cols; col++)&#123;</span><br><span class="line">            <span class="comment">// +0 -&gt; B; +4 -&gt; G; +8 -&gt; R</span></span><br><span class="line">            *((<span class="keyword">float</span> *)(cvPtr2D( srcMat, row, col, <span class="literal">NULL</span>) + <span class="number">0</span> )) = <span class="number">255</span>;</span><br><span class="line">            *((<span class="keyword">float</span> *)(cvPtr2D( srcMat, row, col, <span class="literal">NULL</span>) + <span class="number">4</span> )) = <span class="number">0</span>;</span><br><span class="line">            *((<span class="keyword">float</span> *)(cvPtr2D( srcMat, row, col, <span class="literal">NULL</span>) + <span class="number">8</span> )) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建窗口，显示矩阵</span></span><br><span class="line">    cvNamedWindow(<span class="string">"Hard way"</span>);</span><br><span class="line">    cvShowImage(<span class="string">"Hard way"</span>, srcMat);</span><br><span class="line">    <span class="comment">// 等待按键，释放内存</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    cvReleaseMat(&amp;srcMat);</span><br><span class="line">    cvDestroyWindow( <span class="string">"Hard way"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果：</strong><br><img src="http://i.imgur.com/CDXIPZ5.jpg" alt=""><br><img src="http://i.imgur.com/jhAYOGX.jpg" alt=""></p>
<p>说明： </p>
<ol>
<li><code>cvPtr2D</code>函数原型：<code>uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type=NULL)</code><br>其中，<code>arr</code>指输入的矩阵，<code>idx0</code>指元素的行值，<code>idx1</code>指元素的列值，<code>type</code>指矩阵元素类型输出参数。函数<code>cvPtr2D</code> 返回指向特殊数组元素的指针。<br><strong>特别注意：</strong>默认情况下，函数返回的是指向uchar类型的指针，当矩阵元素不是<code>uchar</code>类型时，应将指针所指向元素的类型转化为恰当的类型。如：当矩阵元素类型为<code>CV_32FC3</code>，函数应转化为<code>(float *) cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type=NULL)</code>。 </li>
<li>默认情况下，函数返回的指针的类型（而不是指针指向的数据的类型） 是<code>uchar</code>型，占一个字节。当矩阵元素类型为<code>CV_32FC3</code> 时，要想使指针从一个通道指向另一个通道，需在原先指针的基础上加4（因为每个通道占4个字节）。 </li>
<li>对于N维矩阵，可以利用函数<code>cvPtrND()</code>实现。这些指针函数访问矩阵中的特定的点，然后由这个点出发，用指针的算术运算得到指向矩阵中的其他数据的指针。需要了解的是，在多通道的矩阵中，通道是连续的，而且矩阵数据如下存储：<code>bgrbgrbgr…</code></li>
</ol>
<h3 id="恰当的方法"><a href="#恰当的方法" class="headerlink" title="恰当的方法"></a>恰当的方法</h3><p>上面两种方法基本可以满足矩阵中数据的访问，当大多数时候，计算机视觉是一种运算密集型的任务，因而要尽量利用最有效的方法做事。由上面例子可以看出，通过这些函数接口是不可能做到十分高效的。相反地，应该定义自己的指针计算并且在矩阵中利用自己的方法。如果打算对数组中的每一个元素执行一些操作，使用自己的指针是尤为重要的。<br><strong>例3：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.21</span></span><br><span class="line"><span class="comment">// 说明：通过指向实际矩阵数据的一些指针（联合体data）来直接访问</span></span><br><span class="line"><span class="comment">//       矩阵中的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    CvMat *srcMat = cvCreateMat( <span class="number">250</span>, <span class="number">250</span>, CV_8UC3);</span><br><span class="line">    <span class="comment">// 清空数组</span></span><br><span class="line">    cvZero(srcMat);</span><br><span class="line">    <span class="comment">// 显示矩阵的行数据长度（字节）、宽度（元素）、高度（元素）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;step = "</span> &lt;&lt; srcMat-&gt;step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;width = "</span> &lt;&lt; srcMat-&gt;width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcMat-&gt;height = "</span> &lt;&lt; srcMat-&gt;height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 循环访问、设置</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> row = <span class="number">0</span>; row &lt; srcMat-&gt;rows; row++)&#123;</span><br><span class="line">        uchar *ptr = ( uchar *)( srcMat-&gt;data.ptr + row * srcMat-&gt;step );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> col = <span class="number">0</span>; col &lt; srcMat-&gt;cols; col++)&#123;</span><br><span class="line">            <span class="comment">// +0 -&gt; B; +1 -&gt; G; +2 -&gt; R</span></span><br><span class="line">            ptr[ <span class="number">3</span>*col ] = <span class="number">255</span>;</span><br><span class="line">            ptr[ <span class="number">3</span>*col + <span class="number">1</span> ] = <span class="number">0</span>;</span><br><span class="line">            ptr[ <span class="number">3</span>*col + <span class="number">2</span> ] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建窗口，显示矩阵</span></span><br><span class="line">    cvNamedWindow(<span class="string">"Right way"</span>);</span><br><span class="line">    cvShowImage(<span class="string">"Right way"</span>, srcMat);</span><br><span class="line">    <span class="comment">// 等待按键，释放内存</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    cvReleaseMat(&amp;srcMat);</span><br><span class="line">    cvDestroyWindow( <span class="string">"Right way"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果：</strong><br><img src="http://i.imgur.com/iM6CswZ.jpg" alt=""><br><img src="http://i.imgur.com/KhLUJFH.jpg" alt=""></p>
<p><strong>说明： </strong></p>
<ol>
<li>为了使指针产生正确的偏移，必须用矩阵的行数据长度元素（<code>step</code>），上面已提到，行数据元素是用字节来计算的。为了安全，指针最好用字节计算，然后分配恰当的类型。 </li>
<li>若矩阵数据类型设置为<code>CV_32FC3</code>，那么在循环访问时指针指向的数据类型应设置为对应的浮点型。上面的程序需做如下修改：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CvMat *srcMat = cvCreateMat( <span class="number">250</span>, <span class="number">250</span>, CV_32FC3);</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> row = <span class="number">0</span>; row &lt; srcMat-&gt;rows; row++)&#123;</span><br><span class="line">    <span class="keyword">float</span> *ptr = ( <span class="keyword">float</span> *)( srcMat-&gt;data.ptr + row * srcMat-&gt;step );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> col = <span class="number">0</span>; col &lt; srcMat-&gt;cols; col++)&#123;</span><br><span class="line">        <span class="comment">// +0 -&gt; B; +1 -&gt; G; +2 -&gt; R</span></span><br><span class="line">        ptr[ <span class="number">3</span>*col ] = <span class="number">255</span>;</span><br><span class="line">        ptr[ <span class="number">3</span>*col + <span class="number">1</span> ] = <span class="number">0</span>;</span><br><span class="line">        ptr[ <span class="number">3</span>*col + <span class="number">2</span> ] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>特别注意：</strong> 根据联合体<code>data</code>可知，访问数据的指针类型（而不是指针指向的数据的类型） 可以有多种选择。需要注意的是，当指针类型不同时，我们在将某点指针指向该点的下一行元素时，需要对<code>step</code>进行相关的算术运算处理才能得到正确的偏移量。具体如下： </p>
<ul>
<li><p>指针类型为<code>uchar（data.ptr）</code>时,<br>  float <em>ptr = ( float </em>)( srcMat-&gt;data.ptr + row * srcMat-&gt;step );</p>
</li>
<li><p>指针类型为<code>short（data.s）</code>时,<br>  float <em>ptr = ( float </em>)( srcMat-&gt;data.s + row * srcMat-&gt;step/2 );</p>
</li>
<li>指针类型为<code>int/float（data.i/data.fl）</code>时,<br>  float <em>ptr = ( float </em>)( srcMat-&gt;data.i /<em>srcMat-&gt;data.fl</em>/ + row * srcMat-&gt;step/4 );</li>
<li>指针类型为<code>double（data.db）</code>时,<br>  float <em>ptr = ( float </em>)( srcMat-&gt;data.db + row * srcMat-&gt;step/8 );</li>
</ul>
<ol>
<li>由程序可知，我们为每行都重新计算了 <code>ptr</code> ，而不是简单地从开头开始，尔后每次读的时候累加指针。</li>
</ol>
<h1 id="IplImage数据结构"><a href="#IplImage数据结构" class="headerlink" title="IplImage数据结构"></a>IplImage数据结构</h1><h2 id="IplImage结构"><a href="#IplImage结构" class="headerlink" title="IplImage结构"></a>IplImage结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IplImage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nSize; <span class="comment">/* 图像结构大小 */</span></span><br><span class="line"><span class="keyword">int</span> ID;    <span class="comment">/* 版本 (=0)*/</span></span><br><span class="line"><span class="keyword">int</span> nChannels;    <span class="comment">/* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span></span><br><span class="line"><span class="keyword">int</span> alphaChannel; <span class="comment">/* 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">int</span> depth; <span class="comment">/* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span></span><br><span class="line"><span class="keyword">char</span> colorModel[<span class="number">4</span>]; <span class="comment">/* 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">char</span> channelSeq[<span class="number">4</span>]; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">int</span> dataOrder;      <span class="comment">/* 0 - 交叉存取颜色通道, 1 - 分开的颜色通道.</span><br><span class="line">cvCreateImage只能创建交叉存取图像 */</span></span><br><span class="line"><span class="keyword">int</span> origin; <span class="comment">/* 0 - 顶—左结构,</span><br><span class="line">               1 - 底—左结构 (Windows bitmaps 风格) */</span></span><br><span class="line"><span class="keyword">int</span> align;  <span class="comment">/* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span></span><br><span class="line"><span class="keyword">int</span> width;  <span class="comment">/* 图像宽像素数 */</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">/* 图像高像素数*/</span></span><br><span class="line"><span class="keyword">struct</span> _IplROI *roi;  <span class="comment">/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span></span><br><span class="line"><span class="keyword">struct</span> _IplImage *maskROI; <span class="comment">/* 在 OpenCV中必须置NULL */</span></span><br><span class="line"><span class="keyword">void</span> *imageId; <span class="comment">/* 同上*/</span></span><br><span class="line"><span class="keyword">struct</span> _IplTileInfo *tileInfo; <span class="comment">/*同上*/</span></span><br><span class="line"><span class="keyword">int</span> imageSize; <span class="comment">/* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span></span><br><span class="line"><span class="keyword">char</span> *imageData; <span class="comment">/* 指向排列的图像数据 */</span></span><br><span class="line"><span class="keyword">int</span> widthStep;   <span class="comment">/* 排列的图像行大小，以字节为单位 */</span></span><br><span class="line"><span class="keyword">int</span> BorderMode[<span class="number">4</span>];  <span class="comment">/* 边际结束模式, 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">int</span> BorderConst[<span class="number">4</span>]; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">char</span> *imageDataOrigin; <span class="comment">/* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span></span><br><span class="line">&#125;</span><br><span class="line">IplImage;</span><br></pre></td></tr></table></figure>
<h2 id="访问图像数据"><a href="#访问图像数据" class="headerlink" title="访问图像数据"></a>访问图像数据</h2><p>通常，我们需要非常迅速和高效地访问图像中的数据。这意味着我们不应受制于存取函数（如<code>cvSet*D</code>之类）。实际上，我们想要用最直接的方式访问图像内的数据。现在，应用已掌握的 <code>IplImage</code> 内部结构的知识，我们知道怎样做才是最佳方法。<br><strong>例4：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.21</span></span><br><span class="line"><span class="comment">// 说明：通过指针遍历图像各通道，并进行相关设置改变图像色彩值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cxcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ImageName=<span class="string">"cat.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *WindowsTitle=<span class="string">"Cat"</span>;</span><br><span class="line">    IplImage *srcImg=cvLoadImage(ImageName);</span><br><span class="line">    <span class="comment">// 显示图像的相关属性</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;width = "</span> &lt;&lt; srcImg-&gt;width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;height = "</span> &lt;&lt; srcImg-&gt;height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;imageSize = "</span> &lt;&lt; srcImg-&gt;imageSize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;nChannels = "</span> &lt;&lt; srcImg-&gt;nChannels &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;depth = "</span> &lt;&lt; srcImg-&gt;depth &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;widthStep = "</span> &lt;&lt; srcImg-&gt;widthStep &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 循环遍历、设置</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> row = <span class="number">0</span>; row &lt; srcImg-&gt;height; row++)&#123;</span><br><span class="line">        uchar *ptr = (uchar *)(</span><br><span class="line">            srcImg-&gt;imageData + row * srcImg-&gt;widthStep</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> col = <span class="number">0</span>; col &lt; srcImg-&gt;width; col++)&#123;</span><br><span class="line">            <span class="comment">// 设置三通道B、G、R色彩值</span></span><br><span class="line">            ptr[<span class="number">3</span> * col] = <span class="number">150</span>;</span><br><span class="line">            <span class="comment">//ptr[3 * col + 1] = 120;</span></span><br><span class="line">            <span class="comment">//ptr[3 * col + 2] = 120;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    cvNamedWindow(WindowsTitle,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cvShowImage(WindowsTitle,srcImg);</span><br><span class="line">    <span class="comment">// 使程序暂停，等待触发按键操作</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    cvReleaseImage(&amp;srcImg);</span><br><span class="line">    <span class="comment">// 销毁窗口</span></span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果： </strong><br><img src="http://i.imgur.com/JExoZhD.jpg" alt=""><br><img src="http://i.imgur.com/0stnUv4.jpg" alt=""></p>
<p><strong>说明：</strong><br>该例程中，我们使用指针遍历图像，类似于例3中的矩阵遍历。然而，有一些细微的不同，是源于 <code>IplImage</code> 和 <code>CvMat</code> 结构的差异。与 <code>CvMat</code> 的成员 <code>data</code> 相比，<code>IplImage</code> 和 <code>CvMat</code> 之间的一个重要的区别在于 <code>imagedata</code> 。<code>CvMat</code> 的 <code>data</code> 元素类型是联合类型，所以必须说明需要使用的指针类型。<code>imagedata</code> 指针是字节类型指针<code>（uchar *）</code>，这意味着，在图像进行指针运算时，我们可以简单的增加 <code>widthstep</code> （也是以字节为单位），而不必关心实际数据类型。当要处理的是矩阵时，必须对偏移进行调整，因为数据指针可能是非字节类型；当要处理的是图像时，可以直接使用偏移，因为数据指针总是字节类型。</p>
<p><code>ROI</code> 和 <code>widthstep</code> 在实际工作中有很重要的作用，在很多情况下，使用它们会提高计算机视觉代码的执行速度。这是因为它们允许对图像的某一小部分进行操作，而不是对整个图像进行运算。<br>为了解释 <code>ROI</code> 的用法，我们编写程序加载一幅图像并修改一些区域，读取一幅图像，并设置想要的 <code>ROI</code> 的 <code>x, y, width</code>和 <code>height</code> 的值，最后将 <code>ROI</code> 区域中的像素都加上一个整数。</p>
<p><strong>例5：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.19</span></span><br><span class="line"><span class="comment">// 说明：读取一幅图像，并设置特定的ROI的x,y,width和height的值，最后将ROI区</span></span><br><span class="line"><span class="comment">//       域中像素都加上一个整数。该例程实现在猫脸上用ROI增加150像素。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ImageName=<span class="string">"cat.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *WindowsTitle=<span class="string">"ROI_ADD"</span>;</span><br><span class="line">    IplImage *src = cvLoadImage(ImageName,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">150</span>;</span><br><span class="line">    <span class="comment">// 设置图像ROI</span></span><br><span class="line">    cvSetImageROI(src, cvRect(x,y,width,height));</span><br><span class="line">    <span class="comment">// 进行或运算，增加图像ROI的像素</span></span><br><span class="line">    cvAddS(src, cvScalar(add,<span class="number">0</span>,<span class="number">0</span>), src);</span><br><span class="line">    <span class="comment">// 释放图像ROI</span></span><br><span class="line">    cvResetImageROI(src);</span><br><span class="line">    cvNamedWindow(WindowsTitle, <span class="number">0</span>);</span><br><span class="line">    cvShowImage(WindowsTitle, src);</span><br><span class="line">    <span class="comment">// 等待按键触发</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放内存，销毁窗口</span></span><br><span class="line">    cvReleaseImage(&amp;src);</span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果：</strong><br><img src="http://i.imgur.com/c5IPaE9.jpg" alt=""><br>通过巧妙地使用<code>widthstep</code>，我们可以达到同样的效果。要做到这一点，我们首先创建另一个图像头，让它的 <code>width</code> 和 <code>height</code> 的值等于 <code>interest_rect</code> 的 <code>width</code> 和 <code>height</code> 的值。我们还需要按照 <code>interest_rect</code> 起点设置图像起点（左上角或左下角）。下一步，我们设置子图像的 <code>widthstep</code> 与较大的 <code>interest_img</code> 相同。这样，即可在子图像中逐步地进到大图像里的子区域中下一行开始处的合适位置。最后设置子图像的 <code>imagedate</code> 指针指向兴趣子区域的开始。</p>
<p><strong>例6：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.21</span></span><br><span class="line"><span class="comment">// 说明：利用widthstep方法把图像感兴趣区域的所有像素值增加一定数值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ImageName=<span class="string">"cat.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *WindowsTitle=<span class="string">"ROI_ADD"</span>;</span><br><span class="line">    <span class="comment">// 设置感兴趣区域的起始点坐标和该区域的大小</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">150</span>;</span><br><span class="line">    <span class="comment">// 创建感兴趣区域图像头</span></span><br><span class="line">    IplImage *srcImage = cvLoadImage(ImageName,<span class="number">1</span>);</span><br><span class="line">    IplImage *subImage = cvCreateImageHeader(</span><br><span class="line">        cvSize( width, height),</span><br><span class="line">        srcImage-&gt;depth,</span><br><span class="line">        srcImage-&gt;nChannels</span><br><span class="line">    );</span><br><span class="line">    subImage-&gt;origin = srcImage-&gt;origin;</span><br><span class="line">    subImage-&gt;widthStep = srcImage-&gt;widthStep;</span><br><span class="line">    subImage-&gt;imageData = srcImage-&gt;imageData +</span><br><span class="line">        ( y - <span class="number">1</span> ) * srcImage-&gt;widthStep +</span><br><span class="line">        ( x - <span class="number">1</span> ) * srcImage-&gt;nChannels;</span><br><span class="line">    <span class="comment">// 进行或运算，增加图像ROI的像素</span></span><br><span class="line">    cvAddS(subImage, cvScalar(add,<span class="number">0</span>,<span class="number">0</span>), subImage);</span><br><span class="line">    cvNamedWindow(WindowsTitle, <span class="number">0</span>);</span><br><span class="line">    cvShowImage(WindowsTitle, subImage);</span><br><span class="line">    <span class="comment">// 等待按键触发</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放内存，销毁窗口</span></span><br><span class="line">    cvReleaseImage(&amp;srcImage);</span><br><span class="line">    cvReleaseImageHeader(&amp;subImage);</span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果： </strong><br><img src="http://i.imgur.com/q1hyoNQ.jpg" alt=""><br>看起来设置和重置 ROI 更方便一些，为什么还要使用 <strong>widthstep</strong> ？ 原因在于有些时候在处理的过程中，想在操作过程中设置和保持一幅图像的多个子区域处于活动状态，但是 ROI 只能串行处理并且必须不断地设置和重置。<br>除了上面两种方法来设置图像部分区域的像素值外，还可以通过底层指针遍历特定的部分区域。</p>
<p><strong>例7：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.21</span></span><br><span class="line"><span class="comment">// 说明：通过指针遍历图像各通道，并进行相关设置改变图像色彩值,实现</span></span><br><span class="line"><span class="comment">//       与函数cvAddS（）同样的功能。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cxcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ImageName=<span class="string">"cat.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *WindowsTitle=<span class="string">"ROI_ADD"</span>;</span><br><span class="line">    IplImage *srcImg=cvLoadImage(ImageName);</span><br><span class="line">    <span class="comment">// 显示图像的相关属性</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;width = "</span> &lt;&lt; srcImg-&gt;width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;height = "</span> &lt;&lt; srcImg-&gt;height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;imageSize = "</span> &lt;&lt; srcImg-&gt;imageSize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;nChannels = "</span> &lt;&lt; srcImg-&gt;nChannels &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;depth = "</span> &lt;&lt; srcImg-&gt;depth &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"srcImg-&gt;widthStep = "</span> &lt;&lt; srcImg-&gt;widthStep &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 设置感兴趣区域的起始点坐标和该区域的大小</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">150</span>;</span><br><span class="line">    <span class="comment">// 循环遍历、设置</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> row = y; row &lt; ( y + height ); row++)&#123;</span><br><span class="line">        uchar *ptr = (uchar *)(</span><br><span class="line">            srcImg-&gt;imageData + row * srcImg-&gt;widthStep</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> col = x; col &lt; ( x + width ); col++)&#123;</span><br><span class="line">            <span class="comment">// 设置三通道B、G、R色彩值</span></span><br><span class="line">            <span class="comment">// B</span></span><br><span class="line">            <span class="keyword">if</span>( ptr[<span class="number">3</span> * col] + add &gt;= <span class="number">255</span> )</span><br><span class="line">                ptr[<span class="number">3</span> * col] = <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptr[<span class="number">3</span> * col] += add;</span><br><span class="line">            <span class="comment">//// G</span></span><br><span class="line">            <span class="comment">//if( ptr[3 * col + 1] + add &gt;= 255 )</span></span><br><span class="line">            <span class="comment">//  ptr[3 * col + 1] = 255;</span></span><br><span class="line">            <span class="comment">//else</span></span><br><span class="line">            <span class="comment">//  ptr[3 * col + 1] += add;</span></span><br><span class="line">            <span class="comment">//// R</span></span><br><span class="line">            <span class="comment">//if( ptr[3 * col + 2] + add &gt;= 255 )</span></span><br><span class="line">            <span class="comment">//  ptr[3 * col + 2] = 255;</span></span><br><span class="line">            <span class="comment">//else</span></span><br><span class="line">            <span class="comment">//  ptr[3 * col + 2] += add;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    cvNamedWindow(WindowsTitle,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cvShowImage(WindowsTitle,srcImg);</span><br><span class="line">    <span class="comment">// 使程序暂停，等待触发按键操作</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    cvReleaseImage(&amp;srcImg);</span><br><span class="line">    <span class="comment">// 销毁窗口</span></span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果：</strong><br><img src="http://i.imgur.com/YCWIXQ7.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第三篇 学习OpenCV之图像变换（3）]]></title>
      <url>http://gongchuangsu.com/2015/07/05/OpenCV/%E7%AC%AC%E4%B8%89%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在本篇前两节中，我们学习了对图像进行简单的高斯模糊处理以及Canny边缘检测，它们处理的都是从其他地方载入的固定图像。而在更多的情况下，我们需要处理从摄像机或某视频文件中实时读入的视频流。HighGUI做了很多工作才使得摄像机图像序列看起来像一个视频文件，当我们需要处理摄像机或视频文件中的图像序列时我们只需要简单地从摄像机或视频文件获得图像，像图像一样处理。<br>接下来，我们将编程实现读入一个彩色视频文件，并以灰度格式输出这个视频文件，同时将每一帧图像转换为对数极坐标格式，输出并写入新的视频文件中。 </p>
<a id="more"></a>
<p><strong>源程序：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.07.05                          </span></span><br><span class="line"><span class="comment">// 说明：打开一个视频文件，读取文件内容，将每一帧图像转换为</span></span><br><span class="line"><span class="comment">//      对数极坐标格式和灰度格式，并将转换后的图像序列写入</span></span><br><span class="line"><span class="comment">//      新的视频文件中，并输出。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")  //用于屏蔽控制台应用程序的窗口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 定义视频输入输出名称 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *VideoName_Input = <span class="string">"MV.mp4"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *VideoName_Output = <span class="string">"logpolar.mp4"</span>;</span><br><span class="line">    <span class="comment">/* 创建窗口 */</span></span><br><span class="line">    cvNamedWindow( <span class="string">"原视频"</span>, CV_WINDOW_AUTOSIZE );</span><br><span class="line">    cvNamedWindow( <span class="string">"logpolar"</span>, CV_WINDOW_AUTOSIZE );</span><br><span class="line">    cvNamedWindow( <span class="string">"gray"</span>, CV_WINDOW_AUTOSIZE );</span><br><span class="line">    <span class="comment">/* 读取文件 */</span></span><br><span class="line">    CvCapture* capture = <span class="number">0</span>;</span><br><span class="line">    capture = cvCreateFileCapture( VideoName_Input );</span><br><span class="line">    <span class="keyword">if</span>(!capture)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IplImage* bgr_frame = cvQueryFrame(capture);</span><br><span class="line">    <span class="comment">/* 取得视频文件的帧数并输出 */</span></span><br><span class="line">    <span class="keyword">double</span> fps = cvGetCaptureProperty(</span><br><span class="line">        capture,</span><br><span class="line">        CV_CAP_PROP_FPS</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fps=%d\n"</span>,(<span class="keyword">int</span>)fps);</span><br><span class="line">    <span class="comment">/* 取得视频文件的大小并输出 */</span></span><br><span class="line">    CvSize size = cvSize(</span><br><span class="line">        (<span class="keyword">int</span>)cvGetCaptureProperty( capture, CV_CAP_PROP_FRAME_WIDTH),</span><br><span class="line">        (<span class="keyword">int</span>)cvGetCaptureProperty( capture, CV_CAP_PROP_FRAME_HEIGHT)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"frame (w, h) = (%d, %d)\n"</span>,size.width,size.height);</span><br><span class="line">    <span class="comment">/* 创建视频文件读入器 */</span></span><br><span class="line">    CvVideoWriter* writer = cvCreateVideoWriter(</span><br><span class="line">        VideoName_Output,</span><br><span class="line">        CV_FOURCC(<span class="string">'M'</span>,<span class="string">'J'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>),</span><br><span class="line">        fps,</span><br><span class="line">        size</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">/* 为logpolar创建图像 */</span></span><br><span class="line">    IplImage* logpolar_frame = cvCreateImage(</span><br><span class="line">        size,</span><br><span class="line">        IPL_DEPTH_8U,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 为gray创建图像 */</span></span><br><span class="line">    IplImage* gray_frame = cvCreateImage(</span><br><span class="line">        size,</span><br><span class="line">        IPL_DEPTH_8U,</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">/* 图像转换并显示 */</span></span><br><span class="line">    <span class="keyword">while</span>( (bgr_frame = cvQueryFrame(capture)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        cvShowImage(<span class="string">"原视频"</span>, bgr_frame );</span><br><span class="line">        <span class="comment">/* 将原图像格式转换为灰度格式并显示 */</span></span><br><span class="line">        cvConvertImage(  </span><br><span class="line">            bgr_frame,</span><br><span class="line">            gray_frame</span><br><span class="line">            );</span><br><span class="line">        cvShowImage(<span class="string">"gray"</span>, gray_frame );</span><br><span class="line">        <span class="comment">/* 将原图像格式转换为对数极坐标格式并显示 */</span></span><br><span class="line">        cvLogPolar( </span><br><span class="line">            bgr_frame,</span><br><span class="line">            logpolar_frame,</span><br><span class="line">            cvPoint2D32f(bgr_frame-&gt;width/<span class="number">2</span>,bgr_frame-&gt;height/<span class="number">2</span>),</span><br><span class="line">            <span class="number">40</span>,</span><br><span class="line">            CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS </span><br><span class="line">            );</span><br><span class="line">        cvShowImage(<span class="string">"logpolar"</span>, logpolar_frame );</span><br><span class="line">        <span class="comment">/* 将对数极坐标格式的图像写入指定视频文件中 */</span></span><br><span class="line">        cvWriteFrame( writer, logpolar_frame );</span><br><span class="line">        <span class="comment">/* 等待按键触发 */</span></span><br><span class="line">        <span class="keyword">char</span> c = cvWaitKey(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="number">27</span> ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放资源 */</span></span><br><span class="line">    cvReleaseVideoWriter( &amp;writer );</span><br><span class="line">    cvReleaseImage( &amp;gray_frame );</span><br><span class="line">    cvReleaseImage( &amp;logpolar_frame );</span><br><span class="line">    cvReleaseCapture( &amp;capture );</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="cvCreateVideoWriter"><a href="#cvCreateVideoWriter" class="headerlink" title="cvCreateVideoWriter"></a>cvCreateVideoWriter</h2><p><strong>函数原型</strong>：<code>CvVideoWriter* cvCreateVideoWriter(const char* filename, int fourcc, double fps, CvSize frame_size,int is_color=1 )</code><br><strong>函数说明</strong>：创建视频文件写入器结构。<br><code>filename</code>：输出视频文件名称。<br><code>fourcc</code>：四个字符用来表示压缩帧的<code>codec</code> 例如，<code>CV_FOURCC``(‘P’,’I’,’M’,’1’)</code>是<code>MPEG-1 codec</code>， <code>CV_FOURCC``(‘M’,’J’,’P’,’G’)</code>是<code>motion-jpeg codec</code>等。 在Win32下，如果传入参数-1，可以从一个对话框中选择压缩方法和压缩参数。具体可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">http://www.fourcc.org/codecs.php</a><br><code>fps</code>：被创建视频流的帧率。<br><code>frame_size</code>：视频流的大小。<br><code>is_color</code>：如果非零，编码器将希望得到彩色帧并进行编码；否则，是灰度帧（只有在Windows下支持这个标志）。 默认为1。</p>
<h2 id="cvConvertImage"><a href="#cvConvertImage" class="headerlink" title="cvConvertImage"></a>cvConvertImage</h2><p><strong>函数原型</strong>：<code>void cvConvertImage( const CvArr* src, CvArr* dst, int flags=0 )</code><br><strong>函数说明</strong>：把一幅图像转换为另外一幅图像，并可以选择同时对其进行垂直翻转 。<br><code>src</code>：输入图像。<br><code>dst</code>：目标图像。必须为单通道或者3通道8位图像。<br><code>flags</code>：操作标志。<br><code>CV_CVTIMG_FLIP</code> ： 垂直翻转图像。<br><code>CV_CVTIMG_SWAP_RB</code> ：交换红蓝通道。在OpenCV中，彩色图像的通道顺序是 <code>BGR</code> 然而在一些系统中，在显示图像之前通道顺序应该被翻转（<code>cvShowImage</code>能够自动转换）。</p>
<h2 id="cvLogPolar"><a href="#cvLogPolar" class="headerlink" title="cvLogPolar"></a>cvLogPolar</h2><p><strong>函数原型</strong>：<code>void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double M, int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS )</code><br><strong>函数说明</strong>：把图像映射到对数极坐标空间。此函数模仿人类视网膜中央凹视力，并且对于目标跟踪等可用于快速尺度和旋转变换不变模板匹配。<br><code>src</code>：输入图像。<br><code>dst</code>：输出图像。<br><code>center</code>：变换的中心，输出图像在此处最精确。<br><code>M</code>：幅度的尺度参数。<br><code>flags</code>：插值方法。</p>
<h2 id="cvWriteFrame"><a href="#cvWriteFrame" class="headerlink" title="cvWriteFrame"></a>cvWriteFrame</h2><p><strong>函数原型</strong>：<code>int cvWriteFrame(CvVideoWriter* writer, const IplImage* image)</code><br><strong>函数说明</strong>：写入一帧到一个视频文件中<br><code>writer</code>：视频文件写入器结构。<br><code>image</code>：被写入的帧。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://i.imgur.com/NpsP1Md.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第三篇 学习OpenCV之图像变换（2）]]></title>
      <url>http://gongchuangsu.com/2015/06/28/OpenCV/%E7%AC%AC%E4%B8%89%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>上一节中，我们对图像进行了简单的高斯模糊处理，关键是创建图像并进行高斯处理。本节中，我们将对图像进行其他变换，实现对原图像进行宽、高减半处理，并在此基础上进行<code>canny</code>边缘检测处理，可通过控制滑动条对检测程度进行调节。 </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Canny边缘检测</strong>：Canny边缘检测算子是John F. Canny于 1986 年开发出来的一个多级边缘检测算法。Canny 的目标是找到一个最优的边缘检测算法，最优边缘检测的含义是：<br><strong>好的检测</strong>- 算法能够尽可能多地标识出图像中的实际边缘。<br><strong>好的定位</strong>- 标识出的边缘要尽可能与实际图像中的实际边缘尽可能接近。<br><strong>最小响应</strong>- 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。</p>
<a id="more"></a>
<p><strong>源代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.06.28</span></span><br><span class="line"><span class="comment">// 说明：图像宽、高减半并进行canny边缘检测</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)  <span class="comment">//用于屏蔽控制台应用程序的窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> slider_position=<span class="number">0</span>;</span><br><span class="line">IplImage* src, * dst_canny, * dst_down;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图像宽、高减半函数</span></span><br><span class="line"><span class="function">IplImage* <span class="title">doPyrDown</span><span class="params">(IplImage* in )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//确认输入图像的宽、高能够被2整除</span></span><br><span class="line">    assert( in-&gt;width%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; in-&gt;height%<span class="number">2</span> == <span class="number">0</span> );</span><br><span class="line">    IplImage* out = cvCreateImage(</span><br><span class="line">        cvSize( in-&gt;width/<span class="number">2</span> , in-&gt;height/<span class="number">2</span>),</span><br><span class="line">        in-&gt;depth,</span><br><span class="line">        in-&gt;nChannels</span><br><span class="line">        );</span><br><span class="line">    cvPyrDown( in , out );</span><br><span class="line">    <span class="keyword">return</span>( out );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义边缘检测函数</span></span><br><span class="line"><span class="function">IplImage* <span class="title">doCanny</span><span class="params">(</span><br><span class="line">    IplImage* in,</span><br><span class="line">    <span class="keyword">double</span> lowThresh,</span><br><span class="line">    <span class="keyword">double</span> highThresh,</span><br><span class="line">    <span class="keyword">double</span> aperture</span><br><span class="line">    )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( in-&gt;nChannels != <span class="number">1</span>)  <span class="comment">//Canny只能处理灰度图片</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">        IplImage* out = cvCreateImage(</span><br><span class="line">            cvGetSize( in ),</span><br><span class="line">            in-&gt;depth,</span><br><span class="line">            in-&gt;nChannels</span><br><span class="line">            );</span><br><span class="line">        cvCanny( in, out, lowThresh, highThresh, aperture );</span><br><span class="line">        <span class="keyword">return</span>( out );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTrackbarSlide</span><span class="params">(<span class="keyword">int</span> threshhold)</span></span>&#123;</span><br><span class="line">    dst_canny = doCanny( dst_down, threshhold, threshhold*<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    cvNamedWindow( <span class="string">"边缘检测图"</span>, <span class="number">1</span>);</span><br><span class="line">    cvShowImage( <span class="string">"边缘检测图"</span>, dst_canny);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*ImageName=<span class="string">"人物.jpg"</span>;</span><br><span class="line">    src = cvLoadImage( ImageName, <span class="number">0</span>);  <span class="comment">//注意读入图像的颜色应设置为灰色</span></span><br><span class="line">    cvNamedWindow( <span class="string">"原图"</span>, <span class="number">1</span>);</span><br><span class="line">    cvShowImage( <span class="string">"原图"</span>, src);</span><br><span class="line">    <span class="comment">//图像宽、高减半处理</span></span><br><span class="line">    dst_down = doPyrDown( src );</span><br><span class="line">    <span class="comment">//图像边缘检测处理</span></span><br><span class="line">    dst_canny = doCanny( dst_down, slider_position, slider_position*<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    cvNamedWindow( <span class="string">"边缘检测图"</span>, <span class="number">1</span>);</span><br><span class="line">    cvShowImage( <span class="string">"边缘检测图"</span>, dst_canny);</span><br><span class="line">    <span class="comment">//创建滑动条</span></span><br><span class="line">    cvCreateTrackbar(</span><br><span class="line">        <span class="string">"滑动条"</span>,</span><br><span class="line">        <span class="string">"原图"</span>,</span><br><span class="line">        &amp;slider_position,</span><br><span class="line">        <span class="number">200</span>,</span><br><span class="line">        onTrackbarSlide</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//等待按键触发</span></span><br><span class="line">    cvWaitKey();</span><br><span class="line">    cvReleaseImage(&amp;src);</span><br><span class="line">    cvReleaseImage(&amp;dst_down);</span><br><span class="line">    cvReleaseImage(&amp;dst_canny);</span><br><span class="line">    cvDestroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="cvPyrDown"><a href="#cvPyrDown" class="headerlink" title="cvPyrDown"></a>cvPyrDown</h2><p><strong>函数原型</strong>：<code>void cvPyrDown(const CvArr* src, CvArr* dst, int filter=CV_GAUSSIAN_5x5 )</code><br><strong>函数说明</strong>：使用高斯金字塔分解对输入图像向下采样。首先对输入图像用指定的滤波器进行卷积，然后通过拒绝偶数的行与列来向下采样图像。<br><code>src</code>：输入图像。<br><code>dst</code>：输出图像，其宽度和高度应是输入图像的一半，传入前必须完成初始化。<br><code>filter</code>:卷积滤波器的类型，目前仅支持<code>CV_GAUSSIAN_5x5</code>（默认） 。</p>
<h2 id="cvCanny"><a href="#cvCanny" class="headerlink" title="cvCanny"></a>cvCanny</h2><p><strong>函数原型</strong>：<code>void cvCanny(const CvArr* image, CvArr* edges, double threshold1, double threshold2, int aperture_size=3 )</code><br><strong>函数说明</strong>：采用Canny算法发现输入图像的边缘而且在输出图像中标识这些边缘。<br><code>image</code>：单通路-8位输入图像。<br><code>edges</code>：输出的边缘图像；跟输入图像有一样的大小和类型。<br><code>threshold1</code>：第一个阈值。<br><code>threshold2</code>：第二个阈值。<br><code>aperture_size</code>：Sobel算子内核大小。<br>注：两个阈值当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><strong>原图：</strong><br><img src="http://i.imgur.com/ETLCFRx.jpg" alt=""></p>
<p><strong>边缘检测图：</strong><br><img src="http://i.imgur.com/M0BNlGN.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第三篇 学习OpenCV之图像变换（1）]]></title>
      <url>http://gongchuangsu.com/2015/06/22/OpenCV/%E7%AC%AC%E4%B8%89%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>图像可以进行多种方式的变换，其中一种简单的变换就是对图像进行平滑处理，通过对图像数据与高斯或者其他核函数进行卷积，有效的减少图像信息内容。<br><strong>高斯模糊</strong>，也叫高斯平滑，根据高斯曲线调节象素色值，有选择地模糊图像，通常用它来减少图像噪声以及降低细节层次。<br>接下来，将编程实现载入一幅图像并进行平滑处理。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu (http://gongchuangsu.com/)</span></span><br><span class="line"><span class="comment">// 时间：2015.06.22</span></span><br><span class="line"><span class="comment">// 说明：载入图像并利用高斯模糊进行平滑处理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图像平滑处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSmooth</span><span class="params">(IplImage* in)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    cvNamedWindow(<span class="string">"Image_dst"</span>);</span><br><span class="line">    <span class="comment">//为处理后的图像分配存储空间</span></span><br><span class="line">    IplImage* dst = cvCreateImage(</span><br><span class="line">        cvGetSize(in),</span><br><span class="line">        IPL_DEPTH_8U,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//平滑处理</span></span><br><span class="line">    cvSmooth( in, dst, CV_GAUSSIAN, <span class="number">5</span>, <span class="number">5</span> );</span><br><span class="line">    cvShowImage(<span class="string">"Image_dst"</span>,dst);</span><br><span class="line">    cvReleaseImage( &amp;dst );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*ImageName=<span class="string">"人物.jpg"</span>;</span><br><span class="line">    IplImage* src = cvLoadImage( ImageName );</span><br><span class="line">    cvNamedWindow(<span class="string">"Image_src"</span>);</span><br><span class="line">    cvShowImage(<span class="string">"Image_src"</span>,src);</span><br><span class="line">    <span class="comment">//调用处理函数</span></span><br><span class="line">    doSmooth( src );</span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    cvReleaseImage( &amp;src );</span><br><span class="line">    cvDestroyAllWindows();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="cvCreateImage"><a href="#cvCreateImage" class="headerlink" title="cvCreateImage"></a>cvCreateImage</h1><p><strong>函数原型</strong>：<code>IplImage* cvCreateImage(CvSize size, int depth, int channels)</code><br><strong>函数说明</strong>：创建图像头并分配数据。<br><code>size</code>：图像的宽度和高度。可直接用函数<code>CvGetSize</code>取得某个图像的大小并返回，也可用函数<code>cvSize( int width, int height )</code>赋值，具体如下。该函数<code>cvSize</code>内部已定义，可直接调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSize  <span class="title">cvSize</span><span class="params">( <span class="keyword">int</span> width, <span class="keyword">int</span> height )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    CvSize s;</span><br><span class="line"></span><br><span class="line">    s.width = width;</span><br><span class="line">    s.height = height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>depth</code>：图像元素的位深度，可以是下面的其中之一：<br><code>IPL_DEPTH_8U</code> - 无符号8位整型<br><code>IPL_DEPTH_8S</code> - 有符号8位整型<br><code>IPL_DEPTH_16U</code> - 无符号16位整型<br><code>IPL_DEPTH_16S</code> - 有符号16位整型<br><code>IPL_DEPTH_32S</code> - 有符号32位整型<br><code>IPL_DEPTH_32F</code> - 单精度浮点数<br><code>IPL_DEPTH_64F</code> - 双精度浮点数<br><code>channels</code>：每个像素的颜色通道数。可选择1,2,3或4。该函数只能创建通道是交叉存取的图像，例如通常的彩色图像数据排列是：<code>b0 g0 r0 b1 g1 r1···</code></p>
<h1 id="CvSize"><a href="#CvSize" class="headerlink" title="CvSize"></a>CvSize</h1><p>结构体<code>CvSize</code>表示一个矩阵或一个图像的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strcut CvSize</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> width;   <span class="comment">//宽度</span></span><br><span class="line">  <span class="keyword">int</span> height;  <span class="comment">//高度</span></span><br><span class="line">&#125;size;</span><br></pre></td></tr></table></figure>
<h1 id="CvGetSize"><a href="#CvGetSize" class="headerlink" title="CvGetSize"></a>CvGetSize</h1><p><strong>函数原型</strong>：<code>CvSize cvGetSize(const CvArr* arr)</code><br><strong>函数说明</strong>：返回矩阵或图像ROI的大小（ROI：Region Of Interest 感兴趣区）。函数返回矩阵或图像的行数（<code>CvSize::height</code>）和列数（<code>CvSize::width</code>），如果是图像就返回ROI的大小。</p>
<h1 id="CvArr"><a href="#CvArr" class="headerlink" title="CvArr"></a>CvArr</h1><p>不确定数组 <code>typedef void CvArr</code>;<br><code>CvArr*</code> 仅仅是被用于作函数的参数，用于指示函数接收的数组类型可以不止一个，如 <code>IplImage*</code>, <code>CvMat*</code> 甚至 <code>CvSeq*</code>. 最终的数组类型是在运行时通过分析数组头的前4 个字节判断。</p>
<h1 id="cvSmooth"><a href="#cvSmooth" class="headerlink" title="cvSmooth"></a>cvSmooth</h1><p><strong>函数原型</strong>：<code>void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype=CV_GAUSSIAN, int param1=3, int param2=0, double param3=0, double param4=0 )</code><br><strong>函数说明</strong>：图像平滑处理的各种方法。<br><code>src</code>：输入图像。<br><code>dst</code>：输出图像。<br><code>smoothtype</code>：平滑方法。<br><code>CV_BLUR_NO_SCALE</code> (简单不带尺度变换的模糊) - 对每个象素的<code>param1×param2</code> 领域求和。如果邻域大小是变化的，可以事先利用函数 <code>cvIntegral</code> 计算积分图像；<br><code>CV_BLUR (simple blur)</code> - 对每个象素<code>param1×param2</code>邻域求和并做尺度变换<code>1/(param1?param2)</code>；<br><code>CV_GAUSSIAN (gaussian blur)</code> - 对图像进行核大小为 <code>param1×param2</code> 的高斯卷积 ；<br><code>CV_MEDIAN (median blur)</code> - 对图像进行核大小为<code>param1×param1</code> 的中值滤波；<br><code>CV_BILATERAL</code> (双向滤波) - 应用双向 3x3 滤波，彩色 <code>sigma=param1</code>，空间 <code>sigma=param2</code>。<br><code>param1</code>：平滑操作的第一个参数，孔径的宽度。一定是个正奇数（1,3,5···）<br><code>param2</code>：平滑操作的第二个参数，孔径的高度。对于<code>CV_MEDIAN</code> 和<code>CV_BILATERAL</code> ，该参数被忽略；对于简单/非尺度变换的高斯模糊的情况，如果<code>param2</code>的值为零，则表示其被设定为<code>param1</code>。其他情况下，它一定是个正奇数。<br><code>param3</code>：对应高斯参数的 <code>Gaussian sigma</code> (标准差)。具体参考手册。<br>注：简单模糊和高斯模糊支持1-或3-通道，8-比特和32-比特浮点图像。中值和双向滤波工作于1-或3-通道，8-位图像。</p>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><strong>处理前：</strong><br><img src="http://i.imgur.com/WDV7C2w.jpg" alt=""></p>
<p><strong>处理后：</strong><br><img src="http://i.imgur.com/I80bVXx.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第二篇 学习OpenCV之视频播放]]></title>
      <url>http://gongchuangsu.com/2015/06/21/OpenCV/%E7%AC%AC%E4%BA%8C%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</url>
      <content type="html"><![CDATA[<p>使用OpenCV播放视频，就是将视频中的每一帧顺序的读取出来。<br>例1：一个简单的OpenCV程序，用于播放事先存储在特定位置的视频文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)  <span class="comment">//用于屏蔽控制台应用程序的窗口</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*AviName=<span class="string">"MV.mp4"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*WindowsTitle=<span class="string">"MV"</span>;</span><br><span class="line">    cvNamedWindow(WindowsTitle,<span class="number">0</span>);</span><br><span class="line">    CvCapture*capture=cvCreateFileCapture(AviName);</span><br><span class="line">    IplImage*frame;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        frame=cvQueryFrame(capture);</span><br><span class="line">        <span class="keyword">if</span>(!frame)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cvShowImage(WindowsTitle,frame);</span><br><span class="line">        <span class="keyword">char</span> c=cvWaitKey(<span class="number">33</span>);  <span class="comment">//当前帧被显示后，等待33ms，如果其间触发了一个按键，则返回该键的ASCII码值；否则，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">27</span>)  <span class="comment">//如果用户触发了ESC键（ASCII 27），跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cvReleaseCapture(&amp;capture);</span><br><span class="line">    cvDestroyWindow(<span class="string">"WindowsTitle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="cvCreateFileCapture"><a href="#cvCreateFileCapture" class="headerlink" title="cvCreateFileCapture"></a>cvCreateFileCapture</h2><p><strong>函数原型</strong>：<code>CVAPI(CvCapture*) cvCreateFileCapture( const char* filename )</code><br><strong>函数说明</strong>：初始化从视频文件获取帧。其中，<code>filename</code>为视频文件名。通过参数设置确定要读入的视频文件，返回一个<code>CvCapture</code>结构的指针。该结构包含了关于要读入视频文件的所有信息。当分配的结构不再使用时，应当使用函数<code>cvReleaseCapture</code>释放掉。</p>
<h2 id="cvQueryFrame"><a href="#cvQueryFrame" class="headerlink" title="cvQueryFrame"></a>cvQueryFrame</h2><p><strong>函数原型</strong>：<code>IplImage* cvQueryFrame( CvCapture* capture )</code><br><strong>函数说明</strong>：从摄像头或者文件中抓取一帧，然后解压并返回这一帧。返回的图像不可以被用户释放或修改。抓取后，<code>capture</code>被指向下一帧，可用<code>cvSetCaptureProperty</code>调整<code>capture</code>到合适的帧。如果没有帧可以被获取（摄像头断开或文件中的帧已读完），函数返回<code>NULL</code>。这个函数可以看做是函数<code>cvGrabFrame</code>和函数<code>cvRetrieveFrame</code>的组合。</p>
<h2 id="cvSetCaptureProperty"><a href="#cvSetCaptureProperty" class="headerlink" title="cvSetCaptureProperty"></a>cvSetCaptureProperty</h2><p><strong>函数原型</strong>：<code>int cvSetCaptureProperty(CvCapture* capture, int property_id, double value)</code><br><strong>函数说明</strong>：设置指定获取视频的属性。<br><code>capture</code>：获取视频结构。<br><code>property_id</code>：属性标识符。可以是下面参数之一。<br><code>CV_CAP_PROP_POS_MSEC</code> - 从文件开始的位置，单位为毫秒<br><code>CV_CAP_PROP_POS_FRAMES</code> - 单位为帧数的位置（只对视频文件有效）<br><code>CV_CAP_PROP_POS_AVI_RATIO</code> - 视频文件的相对位置（0 - 影片的开始，1 - 影片的结尾)<br><code>CV_CAP_PROP_FRAME_WIDTH</code> - 视频流的帧宽度（只对摄像头有效）<br><code>CV_CAP_PROP_FRAME_HEIGHT</code> - 视频流的帧高度（只对摄像头有效）<br><code>CV_CAP_PROP_FPS</code> - 帧率（只对摄像头有效）<br><code>CV_CAP_PROP_FOURCC</code> - 表示codec的四个字符（只对摄像头有效）<br><code>value</code>：属性的值。</p>
<h2 id="cvGetCaptureProperty"><a href="#cvGetCaptureProperty" class="headerlink" title="cvGetCaptureProperty"></a>cvGetCaptureProperty</h2><p><strong>函数原型</strong>：<code>double cvGetCaptureProperty(CvCapture* capture, int property_id)</code><br><strong>函数说明</strong>：获得摄像头或视频文件的指定属性。当查询不支持所使用的VideoCapture类后端的属性时，返回0。<br><code>capture</code>：获取视频结构。<br><code>property_id</code>：属性标识符。可以是下面参数之一。<br><code>CV_CAP_PROP_POS_MSEC</code> - 影片目前位置，为毫秒数或者视频获取时间戳<br><code>CV_CAP_PROP_POS_FRAMES</code> - 将被下一步解压／获取的帧索引，以0为起点<br><code>CV_CAP_PROP_POS_AVI_RATIO</code> - 视频文件的相对位置（0 - 影片的开始，1 - 影片的结尾)<br><code>CV_CAP_PROP_FRAME_WIDTH</code> - 视频流中的帧宽度<br><code>CV_CAP_PROP_FRAME_HEIGHT</code> - 视频流中的帧高度<br><code>CV_CAP_PROP_FPS</code> - 帧率<br><code>CV_CAP_PROP_FOURCC</code> - 表示codec的四个字符<br><code>CV_CAP_PROP_FRAME_COUNT</code> - 视频文件中帧的总数</p>
<h2 id="cvGrabFrame"><a href="#cvGrabFrame" class="headerlink" title="cvGrabFrame"></a>cvGrabFrame</h2><p><strong>函数原型</strong>：<code>int cvGrabFrame(CvCapture* capture)</code><br><strong>函数说明</strong>：从摄像头或视频文件中抓取帧。主要用于快速的抓取帧，被抓取的帧存储在视频获取结构中。在多个摄像机环境下，特别是摄像机没有硬件同步功能时显得很重要。由于被抓取的帧可能是压缩格式（由摄像头/驱动定义），这时需要调用函数<code>cvRetrieveFrame</code>来解码并获取帧。</p>
<h2 id="cvRetrieveFrame"><a href="#cvRetrieveFrame" class="headerlink" title="cvRetrieveFrame"></a>cvRetrieveFrame</h2><p><strong>函数原型</strong>：<code>IplImage* cvRetrieveFrame(CvCapture* capture, int streamIdx=0 )</code><br><strong>函数说明</strong>：解码并返回刚才被抓取的帧。如果没有帧被抓取（摄像头断开或文件中的帧已读完），函数返回<code>NULL</code>。函数返回的帧存储在视频获取结构中。返回的图像不可以被用户释放或修改。</p>
<h1 id="CvCapture"><a href="#CvCapture" class="headerlink" title="CvCapture"></a>CvCapture</h1><p><code>CvCapture</code>是一种视频获取结构体，用来保存捕获图像的相关信息，在处理视频时，让程序一帧帧的读取并更新。没有公共接口，只能用来作为视频获取函数的一个参数。</p>
<p>上面的例程只是简单的利用OpenCV实现视频的播放，并不能对视频的播放进度进行控制。下面，将编程实现添加进度条到基本浏览窗口，进度条可显示并控制视频播放的进度。<br>例2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：GongchuangSu ( http://gongchuangsu.com/ )</span></span><br><span class="line"><span class="comment">// 时间：2015.06.21                          </span></span><br><span class="line"><span class="comment">// 说明：通过创建进度条显示并控制视频播放的进度。实质上，是通过添加一个全局</span></span><br><span class="line"><span class="comment">//      变量（获取视频结构的指针g_capture ）来表示进度条位置并添加一个回</span></span><br><span class="line"><span class="comment">//      调函数更新变量以及重新设置视频读入的位置。                                        </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)  <span class="comment">//用于屏蔽控制台应用程序的窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_slider_position=<span class="number">0</span>;</span><br><span class="line">CvCapture* g_capture=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTrackbarSlide</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    cvSetCaptureProperty(</span><br><span class="line">        g_capture,</span><br><span class="line">        CV_CAP_PROP_POS_FRAMES,</span><br><span class="line">        pos</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*AviName=<span class="string">"MV.mp4"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*WindowsTitle=<span class="string">"视频播放控制"</span>;</span><br><span class="line"></span><br><span class="line">    cvNamedWindow(WindowsTitle,<span class="number">0</span>);</span><br><span class="line">    g_capture = cvCreateFileCapture( AviName );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询视频文件的总帧数</span></span><br><span class="line">    <span class="keyword">int</span> frames = (<span class="keyword">int</span>) cvGetCaptureProperty(</span><br><span class="line">        g_capture,</span><br><span class="line">        CV_CAP_PROP_FRAME_COUNT</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( frames!= <span class="number">0</span> )&#123;</span><br><span class="line">        IplImage* frame;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            frame=cvQueryFrame(g_capture);</span><br><span class="line">            <span class="keyword">if</span>(!frame) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//取得将被获取帧的帧数（第N帧）</span></span><br><span class="line">            <span class="keyword">int</span> g_slider_position = (<span class="keyword">int</span>)cvGetCaptureProperty(</span><br><span class="line">                g_capture,</span><br><span class="line">                CV_CAP_PROP_POS_FRAMES</span><br><span class="line">                );</span><br><span class="line">            <span class="comment">//创建进度条，实时显示并控制视频播放进度</span></span><br><span class="line">            cvCreateTrackbar(</span><br><span class="line">                <span class="string">"进度条"</span>,</span><br><span class="line">                WindowsTitle,</span><br><span class="line">                &amp;g_slider_position,</span><br><span class="line">                frames,</span><br><span class="line">                onTrackbarSlide</span><br><span class="line">                );</span><br><span class="line">            <span class="comment">//显示图像</span></span><br><span class="line">            cvShowImage(WindowsTitle,frame);</span><br><span class="line">            <span class="keyword">char</span> c=cvWaitKey(<span class="number">33</span>);</span><br><span class="line">            <span class="keyword">if</span>( c ==<span class="number">27</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    cvReleaseCapture(&amp;g_capture);</span><br><span class="line">    <span class="comment">//销毁窗口</span></span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整个编程实现关键在于函数<code>cvCreateTrackbar</code>的使用，以下是该函数的原型和说明。</strong><br><strong>函数原型</strong>：<code>int cvCreateTrackbar(const char* trackbar_name, const char* window_name, int* value, int count,CvTrackbarCallback on_change=NULL )</code><br><strong>函数说明</strong>：创建<code>trackbar</code>并将它添加到指定的窗口，同时设置回调函数。<br><code>trackbar_name</code>：被创建的进度条名称。<br><code>window_name</code>：窗口名字，这个窗口将为被创建<code>trackbar</code>的父对象。<br><code>value</code>：整型变量指针，其值反应进度条的位置。<br><code>count</code>：进度条的最大值。最小值总为<code>0</code>。<br><code>on_change</code>：每次进度条改变位置时，函数指针将被调用。这个函数的原型应为<code>void Foo（int）</code>，其函数中的参数是进度条改变后的位置（内部自动获取）。获取进度条改变后的位置后，然后再更新全局变量<code>g_capture</code>，读取的帧便从改变后的位置开始。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一篇 学习OpenCV之图像显示]]></title>
      <url>http://gongchuangsu.com/2015/06/14/OpenCV/%E7%AC%AC%E4%B8%80%E7%AF%87%20%E5%AD%A6%E4%B9%A0OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>OpenCV开发包提供了读取各类型的图像文件、视频内容以及摄像机输入的功能，这些功能都包含在OpenCV所包含的HighGUI库中。下面，利用其中的一些功能编写一段简单的用于读取并在屏幕上显示一张图像的程序。 </p>
<p>例：从指定文件夹中读取图片并显示在屏幕上</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//用于屏蔽控制台应用程序的窗口</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*ImageName=<span class="string">"蓝天白云.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*WindowsTitle=<span class="string">"ImageDisplay"</span>;</span><br><span class="line">    <span class="comment">//加载图片至内存</span></span><br><span class="line">    IplImage* img=cvLoadImage(ImageName);</span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    cvNamedWindow(WindowsTitle,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//显示图片</span></span><br><span class="line">    cvShowImage(WindowsTitle,img);</span><br><span class="line">    <span class="comment">//使程序暂停，等待触发按键操作</span></span><br><span class="line">    cvWaitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    cvReleaseImage(&amp;img);</span><br><span class="line">    <span class="comment">//销毁窗口</span></span><br><span class="line">    cvDestroyWindow(WindowsTitle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="cvLoadImage"><a href="#cvLoadImage" class="headerlink" title="cvLoadImage"></a>cvLoadImage</h2><p><strong>函数原型</strong>：<code>CVAPI(IplImage*) cvLoadImage( const char* filename, int iscolor CV_DEFAULT(CV_LOAD_IMAGE_COLOR))</code><br><strong>函数说明</strong>：从文件中读取图像，加载至内存。<br><code>filename</code>：要被读入的文件名。<br><code>iscolor</code>：指定读入图像的颜色。默认为<code>CV_LOAD_IMAGE_COLOR</code>，也即彩色。<br><code>IplImage</code>：来源于Intel Image Processing Library函数库，该结构体包含了一系列图像信息，是整个OpenCV函数库的基础。<br>该函数执行完后将返回一个指针，此指针指向一块为描述该图像文件的数据结构(IplImage*)而分配的内存块。</p>
<h2 id="cvNamedWindow"><a href="#cvNamedWindow" class="headerlink" title="cvNamedWindow"></a>cvNamedWindow</h2><p><strong>函数原型</strong>：<code>CVAPI(int) cvNamedWindow( const char* name, int flags CV_DEFAULT(CV_WINDOW_AUTOSIZE) )</code><br><strong>函数功能</strong>：创建窗口。<br><code>name</code>:窗口的名称，用来区分不同的窗口，并被显示为窗口标题。<br><code>flags</code>:窗口属性标志。当其为<code>CV_WINDOW_NORMAL(0)</code>时，则表示可以手动调整窗口大小；当其为<code>CV_WINDOW_AUTOSIZE(1)</code>时，则表示会根据图像自动调整窗口大小，不能手动调整；当其为<code>CV_WINDOW_OPENGL</code>，则表示窗口支持opengl。</p>
<h2 id="cvShowImage"><a href="#cvShowImage" class="headerlink" title="cvShowImage"></a>cvShowImage</h2><p><strong>函数原型</strong>：<code>CVAPI(void) cvShowImage( const char* name, const CvArr* image )</code><br><strong>函数功能</strong>：在指定窗口中显示图像。<br><code>name</code>:窗口的名字。<br><code>image</code>：被显示的图像。</p>
<h2 id="cvWaitKey"><a href="#cvWaitKey" class="headerlink" title="cvWaitKey"></a>cvWaitKey</h2><p><strong>函数原型</strong>：<code>CVAPI(int) cvWaitKey(int delay CV_DEFAULT(0))</code><br><strong>函数功能</strong>：等待按键事件。<br><code>delay</code>:延迟的毫秒数。当delay&lt;=0时，表示无限制的等待按键事件；否则延迟“delay”毫秒。返回值为被按键的值，如果超过指定时间则返回-1.</p>
<h2 id="cvReleaseImage"><a href="#cvReleaseImage" class="headerlink" title="cvReleaseImage"></a>cvReleaseImage</h2><p><strong>函数原型</strong>：<code>CVAPI(void) cvReleaseImage( IplImage** image )</code><br><strong>函数功能</strong>：释放该图像文件所分配的内存。</p>
<h2 id="cvDestroyWindow"><a href="#cvDestroyWindow" class="headerlink" title="cvDestroyWindow"></a>cvDestroyWindow</h2><p><strong>函数原型</strong>：<code>CVAPI(void) cvDestroyWindow( const char* name )</code><br><strong>函数功能</strong>：销毁窗口。</p>
<h1 id="IplImage"><a href="#IplImage" class="headerlink" title="IplImage"></a>IplImage</h1><p>IplImage结构来自于Intel Image Processing Library。OpenCV只支持其中的一个子集。<br>以下就是IplImage结构体的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IplImage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nSize; <span class="comment">/* 图像结构大小 */</span></span><br><span class="line"><span class="keyword">int</span> ID;    <span class="comment">/* 版本 (=0)*/</span></span><br><span class="line"><span class="keyword">int</span> nChannels;    <span class="comment">/* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span></span><br><span class="line"><span class="keyword">int</span> alphaChannel; <span class="comment">/* 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">int</span> depth; <span class="comment">/* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span></span><br><span class="line"><span class="keyword">char</span> colorModel[<span class="number">4</span>]; <span class="comment">/* 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">char</span> channelSeq[<span class="number">4</span>]; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">int</span> dataOrder;      <span class="comment">/* 0 - 交叉存取颜色通道, 1 - 分开的颜色通道.</span><br><span class="line">cvCreateImage只能创建交叉存取图像 */</span></span><br><span class="line"><span class="keyword">int</span> origin; <span class="comment">/* 0 - 顶—左结构,</span><br><span class="line">               1 - 底—左结构 (Windows bitmaps 风格) */</span></span><br><span class="line"><span class="keyword">int</span> align;  <span class="comment">/* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span></span><br><span class="line"><span class="keyword">int</span> width;  <span class="comment">/* 图像宽像素数 */</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">/* 图像高像素数*/</span></span><br><span class="line"><span class="keyword">struct</span> _IplROI *roi;  <span class="comment">/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span></span><br><span class="line"><span class="keyword">struct</span> _IplImage *maskROI; <span class="comment">/* 在 OpenCV中必须置NULL */</span></span><br><span class="line"><span class="keyword">void</span> *imageId; <span class="comment">/* 同上*/</span></span><br><span class="line"><span class="keyword">struct</span> _IplTileInfo *tileInfo; <span class="comment">/*同上*/</span></span><br><span class="line"><span class="keyword">int</span> imageSize; <span class="comment">/* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span></span><br><span class="line"><span class="keyword">char</span> *imageData; <span class="comment">/* 指向排列的图像数据 */</span></span><br><span class="line"><span class="keyword">int</span> widthStep;   <span class="comment">/* 排列的图像行大小，以字节为单位 */</span></span><br><span class="line"><span class="keyword">int</span> BorderMode[<span class="number">4</span>];  <span class="comment">/* 边际结束模式, 被OpenCV忽略 */</span></span><br><span class="line"><span class="keyword">int</span> BorderConst[<span class="number">4</span>]; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">char</span> *imageDataOrigin; <span class="comment">/* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span></span><br><span class="line">&#125;</span><br><span class="line">IplImage;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenCV(2.4.11)的安装与配置]]></title>
      <url>http://gongchuangsu.com/2015/05/26/OpenCV/OpenCV(2.4.11)%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h1><p>下载VS2010+OpenCV(2.4.11),并安装。</p>
<h1 id="配置OpenCV"><a href="#配置OpenCV" class="headerlink" title="配置OpenCV"></a>配置OpenCV</h1><p>双击“计算机”，打开“系统属性”，点击“高级系统设置”，然后打开“环境变量”，编辑path,在变量值中添加以下语句：<code>D:\opencv\opencv\build\x86\vc10\bin;D:\opencv\opencv\build\x86\mingw\bin;D:\opencv\opencv\build\common\tbb\ia32\vc10</code><br>注意：<code>“D:\opencv”</code>具体应由软件OpenCV安装目录决定。若你安装在<code>D:\program\opencv</code>路径下，应将上面的<code>“D:\opencv”改为“D:\program\opencv”</code>。 </p>
<a id="more"></a>
<p><img src="http://i.imgur.com/xOobDpK.jpg" alt=""><br><img src="http://i.imgur.com/EiN4UQK.jpg" alt=""><br><img src="http://i.imgur.com/Oyy3y4g.jpg" alt=""></p>
<h1 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h1><p>1.打开文件-&gt;新建-&gt;项目-&gt;Visual C++-&gt;Win32-&gt;Win32控制台应用程序，输入名称“example”。 </p>
<p><img src="http://i.imgur.com/hR0iabs.jpg" alt=""></p>
<p>2.点击确定，并进行下一步，在附加选项中勾选”空项目”，其他默认不变。点击完成。 </p>
<p><img src="http://i.imgur.com/db0VNmE.jpg" alt=""></p>
<p>3.在源文件中添加新建项，新建一个C++文件。 </p>
<p><img src="http://i.imgur.com/L0gp2lg.jpg" alt=""></p>
<p><img src="http://i.imgur.com/gRJYv2L.jpg" alt=""></p>
<p>4.在VS2010中配置OpenCV</p>
<p>4.1打开项目下的属性（Alt+F7）,并打开属性页中配置属性下的VC++目录。 </p>
<p><img src="http://i.imgur.com/0l2risi.jpg" alt=""></p>
<p>4.2配置包含目录<br>编辑包含目录并添加以下语句:<br>    D:\opencv\opencv\build\include<br>    D:\opencv\opencv\build\include\opencv<br>    D:\opencv\opencv\build\include\opencv2 </p>
<p><img src="http://i.imgur.com/4SStnEZ.jpg" alt=""></p>
<p>4.3配置库目录<br>编辑库目录并添加以下语句：<br>    D:\opencv\opencv\build\x86\vc10\lib</p>
<p><img src="http://i.imgur.com/wxIsBE9.jpg" alt=""></p>
<p>4.4配置链接器<br>打开属性页中链接器下的输入，编辑附加依赖项并添加以下语句：<br>    opencv_calib3d2411d.lib<br>    opencv_contrib2411d.lib<br>    opencv_core2411d.lib<br>    opencv_features2d2411d.lib<br>    opencv_flann2411d.lib<br>    opencv_gpu2411d.lib<br>    opencv_highgui2411d.lib<br>    opencv_imgproc2411d.lib<br>    opencv_legacy2411d.lib<br>    opencv_ml2411d.lib<br>    opencv_objdetect2411d.lib<br>    opencv_ts2411d.lib<br>    opencv_video2411d.lib </p>
<p><img src="http://i.imgur.com/eDlm46P.jpg" alt=""></p>
<p>特别注意：上面语句中2411是安装OpenCV的版本号，所以要根据具体安装的版本来填写。</p>
<p>4.5编程测试</p>
<p>下面就来写一个简单的图片显示的程序，在编程前将要显示的图片放在<code>D:\Documents\Visual Studio 2010\Projects\example\example</code>目录下，具体位置要根据你安装的位置决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//显示图像文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstrImageName = <span class="string">"蓝天白云.jpg"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstrWindowsTitle = <span class="string">"OpenCV第一个程序"</span>;</span><br><span class="line">    <span class="comment">//从文件中读取图像</span></span><br><span class="line">    IplImage *pImage = cvLoadImage(pstrImageName, CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    cvNamedWindow(pstrWindowsTitle, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在指定窗口中显示图像</span></span><br><span class="line">    cvShowImage(pstrWindowsTitle, pImage);</span><br><span class="line">    <span class="comment">//等待按键事件</span></span><br><span class="line">    cvWaitKey();</span><br><span class="line">    cvDestroyWindow(pstrWindowsTitle);</span><br><span class="line">    cvReleaseImage(&amp;pImage);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成并运行可得： </p>
<p><img src="http://i.imgur.com/HJWWs3N.jpg" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.csdn.net/morewindows/article/details/8225783" target="_blank" rel="external">【OpenCV入门指南】第一篇 安装OpenCV </a></li>
<li><a href="http://www.cnblogs.com/freedomshe/archive/2012/04/25/2470540.html" target="_blank" rel="external">VS2010+Opencv-2.4.0的配置攻略</a> </li>
</ol>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://gongchuangsu.com/404.html</url>
      <content type="html"><![CDATA[<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8;">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="robots" content="all">
  <meta name="robots" content="index,follow">
</head>
<body>

<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="your site url " homepagename="回到我的主页">
</script>

</body>
</html>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>http://gongchuangsu.com/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://gongchuangsu.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[about]]></title>
      <url>http://gongchuangsu.com/about/index.html</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/hChnLrh.gif" alt=""></p>
<blockquote class="blockquote-center">书写是为了更好的思考。<br></blockquote>

<h1 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h1><p>一枚爱折腾、爱思考的小码农，愿结识各路好友，分享各自的知识与快乐。<br>目前专注于<strong>Java后台开发</strong>。</p>
<h1 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h1><p><strong>Email</strong>: sgc0515@gmail.com<br><strong>CSDN</strong>: <a href="http://blog.csdn.net/gongchuangsu" target="_blank" rel="external">贱贱的梦想</a><br><strong>GitHub</strong>: <a href="https://github.com/GongchuangSu" target="_blank" rel="external">GongchuangSu</a></p>
<h1 id="我的阅读书单"><a href="#我的阅读书单" class="headerlink" title="我的阅读书单"></a>我的阅读书单</h1><table width="95%" border="1" cellspacing="0" cellpadding="0" style="margin:0;padding:0;word-break:break-all; word-wrap:break-all; "><br><tr align="center"> <th rowspan="2" width="150">书名</th> <th colspan="2">阅读时间</th> <th rowspan="2" width="30">阅读进度</th> <th rowspan="2">评价</th> </tr> <tr> <th width="80">起始时间</th> <th width="80">终止时间</th> </tr> <tr align="center"> <td><img src="http://i.imgur.com/OIH4pqu.jpg" width="200" height="280" alt="Java编程思想"></td> <td>2016.04.01</td> <td>至今</td> <td>50%</td> <td>经典之作！内容讲的很深刻！但是个人感觉内容太杂，没有条理性，阅读起来可能会迷迷糊糊！</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/wSy2vCw.jpg" width="200" height="280" alt="Effective Java中文版（第2版）"></td> <td>2016.04.01</td> <td>至今</td> <td>5%</td> <td>值得仔细研读！对Java编程思想有深刻的认识！</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/KZw0u5n.jpg" width="200" height="280" alt="java核心技术卷I"></td> <td>2016.04.01</td> <td>至今</td> <td>10 </td> <td>这本要比Java编程思想有条理，内容也比较浅显，适合入门。</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/MYJNv9F.jpg" width="200" height="280" alt="java核心技术卷Ⅱ"></td> <td>待定</td> <td>待定</td> <td>未读</td> <td>待定</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/2Hn8P6J.jpg" width="200" height="280" alt="Java Web从入门到精通"></td> <td>2016.6.15</td> <td>至今</td> <td>80%</td> <td>这本书对Java Web技术进行了系统的介绍，涉及到很多技术，但讲的都是最基本的，要想有更深入的学习，还得进一步的对应地学习。</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/7mtAHB8.jpg" width="200" height="280" alt="Spring实战（第四版）"></td> <td>2016.10.20</td> <td>至今</td> <td>10%</td> <td>还在研读中。。。</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/MCwvAGE.jpg" width="200" height="280" alt="Redis实战"></td> <td>2016.10.20</td> <td>至今</td> <td>10%</td> <td>还在研读中。。。</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/50fSILT.jpg" width="200" height="280" alt="Spring技术内幕：深入解析Spring架构与设计原理（第2版）"></td> <td>2016.6.15</td> <td>至今</td> <td>5%</td> <td>系统的对Spring框架的使用进行了介绍和分析，从原理到应用，逐步实现</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/gWynkNJ.jpg" width="200" height="280" alt="Servlet JSP深入详解 基于Tomcat的Web开发"></td> <td>2016.6.15</td> <td>至今</td> <td>5%</td> <td>学习Servlet和JSP技术很好的一本教材</td> </tr> <tr align="center"> <td><img src="http://i.imgur.com/6ianpBn.jpg" width="200" height="280" alt="大话数据结构"></td> <td>2016.3.15</td> <td>至今</td> <td>90%</td> <td>通俗易懂的对数据结构进行了全面的介绍，很好的一本教材！</td> </tr></table>
]]></content>
    </entry>
    
  
</search>
